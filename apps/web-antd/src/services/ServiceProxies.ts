/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {ServiceProxyBase} from './ServiceProxyBase'
import axios, { AxiosError } from 'axios';
import type {AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken} from 'axios';
import dayjs from 'dayjs';

export class AbpApiDefinitionServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeTypes (optional) 
     * @return Success
     */
    apiDefinition(includeTypes: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition?";
        if (includeTypes === null)
            throw new Error("The parameter 'includeTypes' cannot be null.");
        else if (includeTypes !== undefined)
            url_ += "IncludeTypes=" + encodeURIComponent("" + includeTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processApiDefinition(_response));
        });
    }

    protected processApiDefinition(response: AxiosResponse): Promise<ApplicationApiDescriptionModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationApiDescriptionModel.fromJS(resultData200);
            return Promise.resolve<ApplicationApiDescriptionModel>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationApiDescriptionModel>(null as any);
    }
}

export class AbpApplicationConfigurationServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeLocalizationResources (optional) 
     * @return Success
     */
    applicationConfiguration(includeLocalizationResources: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration?";
        if (includeLocalizationResources === null)
            throw new Error("The parameter 'includeLocalizationResources' cannot be null.");
        else if (includeLocalizationResources !== undefined)
            url_ += "IncludeLocalizationResources=" + encodeURIComponent("" + includeLocalizationResources) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processApplicationConfiguration(_response));
        });
    }

    protected processApplicationConfiguration(response: AxiosResponse): Promise<ApplicationConfigurationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationConfigurationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationConfigurationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationConfigurationDto>(null as any);
    }
}

export class AbpApplicationLocalizationServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyDynamics (optional) 
     * @return Success
     */
    applicationLocalization(cultureName: string, onlyDynamics: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationLocalizationDto> {
        let url_ = this.baseUrl + "/api/abp/application-localization?";
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined and cannot be null.");
        else
            url_ += "CultureName=" + encodeURIComponent("" + cultureName) + "&";
        if (onlyDynamics === null)
            throw new Error("The parameter 'onlyDynamics' cannot be null.");
        else if (onlyDynamics !== undefined)
            url_ += "OnlyDynamics=" + encodeURIComponent("" + onlyDynamics) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processApplicationLocalization(_response));
        });
    }

    protected processApplicationLocalization(response: AxiosResponse): Promise<ApplicationLocalizationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationLocalizationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationLocalizationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationLocalizationDto>(null as any);
    }
}

export class AccountServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 登录
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginInput | undefined , cancelToken?: CancelToken | undefined): Promise<LoginOutput> {
        let url_ = this.baseUrl + "/api/app/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processLogin(_response));
        });
    }

    protected processLogin(response: AxiosResponse): Promise<LoginOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginOutput.fromJS(resultData200);
            return Promise.resolve<LoginOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginOutput>(null as any);
    }
}

export class AlarmServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页查询报警记录
     * @param body (optional) 
     * @return Success
     */
    page(body: PageAlarmInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<AlarmOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/alarm/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<AlarmOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AlarmOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<AlarmOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AlarmOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 下拉人员
     * @return Success
     */
    user(  cancelToken?: CancelToken | undefined): Promise<NameIdDto[]> {
        let url_ = this.baseUrl + "/alarm/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser(_response));
        });
    }

    protected processUser(response: AxiosResponse): Promise<NameIdDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NameIdDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameIdDto[]>(null as any);
    }

    /**
     * 下拉设备
     * @return Success
     */
    device(  cancelToken?: CancelToken | undefined): Promise<NameIdDto[]> {
        let url_ = this.baseUrl + "/alarm/device";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDevice(_response));
        });
    }

    protected processDevice(response: AxiosResponse): Promise<NameIdDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NameIdDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameIdDto[]>(null as any);
    }

    /**
     * 下拉遥测属性
     * @return Success
     */
    telemetry(  cancelToken?: CancelToken | undefined): Promise<NameIdDto[]> {
        let url_ = this.baseUrl + "/alarm/telemetry";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTelemetry(_response));
        });
    }

    protected processTelemetry(response: AxiosResponse): Promise<NameIdDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NameIdDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameIdDto[]>(null as any);
    }

    /**
     * 下拉设备遥测
     * @param body (optional) 
     * @return Success
     */
    deviceTelemetry(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<NameIdDto[]> {
        let url_ = this.baseUrl + "/alarm/device-telemetry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeviceTelemetry(_response));
        });
    }

    protected processDeviceTelemetry(response: AxiosResponse): Promise<NameIdDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NameIdDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameIdDto[]>(null as any);
    }

    /**
     * 新增报警规则
     * @param body (optional) 
     * @return Success
     */
    createAlarmRule(body: AlarmRuleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/create-alarm-rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreateAlarmRule(_response));
        });
    }

    protected processCreateAlarmRule(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除报警规则
     * @param body (optional) 
     * @return Success
     */
    deleteAlarmRule(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/delete-alarm-rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteAlarmRule(_response));
        });
    }

    protected processDeleteAlarmRule(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑报警规则
     * @param body (optional) 
     * @return Success
     */
    editAlarmRule(body: AlarmRuleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/edit-alarm-rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEditAlarmRule(_response));
        });
    }

    protected processEditAlarmRule(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 查询报警规则
     * @param body (optional) 
     * @return Success
     */
    pageAlarmRule(body: PageAlarmRuleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<AlarmRuleOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/alarm/page-alarm-rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPageAlarmRule(_response));
        });
    }

    protected processPageAlarmRule(response: AxiosResponse): Promise<AlarmRuleOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AlarmRuleOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<AlarmRuleOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AlarmRuleOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 编辑报警规则
     * @param body (optional) 
     * @return Success
     */
    updateJson(body: UpdateContentInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/update-json";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdateJson(_response));
        });
    }

    protected processUpdateJson(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 新增推送人
     * @param body (optional) 
     * @return Success
     */
    addNotify(body: AddNotifyInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/add-notify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddNotify(_response));
        });
    }

    protected processAddNotify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 推送人列表
     * @param body (optional) 
     * @return Success
     */
    pageNotify(body: PageAlarmNotifyInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<AlarmNotifyOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/alarm/page-notify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPageNotify(_response));
        });
    }

    protected processPageNotify(response: AxiosResponse): Promise<AlarmNotifyOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AlarmNotifyOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<AlarmNotifyOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AlarmNotifyOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 移除推送人
     * @param body (optional) 
     * @return Success
     */
    removeNotify(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/remove-notify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRemoveNotify(_response));
        });
    }

    protected processRemoveNotify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 批量建数据
     * @param jsonFileName (optional) 
     * @return Success
     */
    alarmRuleBuild(jsonFileName: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/alarmRule-build?";
        if (jsonFileName === null)
            throw new Error("The parameter 'jsonFileName' cannot be null.");
        else if (jsonFileName !== undefined)
            url_ += "jsonFileName=" + encodeURIComponent("" + jsonFileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAlarmRuleBuild(_response));
        });
    }

    protected processAlarmRuleBuild(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 批量建数据
     * @param ruleId (optional) 
     * @return Success
     */
    alarmNotifyBuild(ruleId: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/alarmNotify-build?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAlarmNotifyBuild(_response));
        });
    }

    protected processAlarmNotifyBuild(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 测试邮件模板
     * @param to (optional) 
     * @return Success
     */
    testMail(to: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/test-mail?";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTestMail(_response));
        });
    }

    protected processTestMail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 清除告警
     * @param body (optional) 
     * @return Success
     */
    clear(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/alarm/clear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processClear(_response));
        });
    }

    protected processClear(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuditLogsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页获取审计日志信息
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingAuditLogInput | undefined , cancelToken?: CancelToken | undefined): Promise<PagingAuditLogOutputPagedResultDto> {
        let url_ = this.baseUrl + "/AuditLogs/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<PagingAuditLogOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagingAuditLogOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PagingAuditLogOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagingAuditLogOutputPagedResultDto>(null as any);
    }
}

export class BatteryServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 开关信号
     * @param body (optional) 
     * @return Success
     */
    switchDetail(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/switch-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSwitchDetail(_response));
        });
    }

    protected processSwitchDetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 开关消息
     * @param body (optional) 
     * @return Success
     */
    switchHead(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/switch-head";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSwitchHead(_response));
        });
    }

    protected processSwitchHead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 新增信号
     * @param body (optional) 
     * @return Success
     */
    createDetail(body: ProtocolDetailInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/create-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreateDetail(_response));
        });
    }

    protected processCreateDetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 新增消息
     * @param body (optional) 
     * @return Success
     */
    createHead(body: ProtocolHeadInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/create-head";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreateHead(_response));
        });
    }

    protected processCreateHead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除信号
     * @param body (optional) 
     * @return Success
     */
    deleteDetail(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/delete-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteDetail(_response));
        });
    }

    protected processDeleteDetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除消息
     * @param body (optional) 
     * @return Success
     */
    deleteHead(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/delete-head";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteHead(_response));
        });
    }

    protected processDeleteHead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取通信协议
     * @return Success
     */
    listProtocol(  cancelToken?: CancelToken | undefined): Promise<BatteryProtocolDto[]> {
        let url_ = this.baseUrl + "/battery/list-protocol";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processListProtocol(_response));
        });
    }

    protected processListProtocol(response: AxiosResponse): Promise<BatteryProtocolDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BatteryProtocolDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BatteryProtocolDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryProtocolDto[]>(null as any);
    }

    /**
     * 获取通信协议body
     * @param body (optional) 
     * @return Success
     */
    detailProtocol(body: PageProtocolDetailInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<BatteryProtocolDetailOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/battery/detail-protocol";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDetailProtocol(_response));
        });
    }

    protected processDetailProtocol(response: AxiosResponse): Promise<BatteryProtocolDetailOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatteryProtocolDetailOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<BatteryProtocolDetailOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryProtocolDetailOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 获取通信协议head
     * @param body (optional) 
     * @return Success
     */
    headProtocol(body: PageProtocolHeadInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<BatteryProtocolHeadOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/battery/head-protocol";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processHeadProtocol(_response));
        });
    }

    protected processHeadProtocol(response: AxiosResponse): Promise<BatteryProtocolHeadOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatteryProtocolHeadOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<BatteryProtocolHeadOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryProtocolHeadOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 编辑信号
     * @param body (optional) 
     * @return Success
     */
    updateDetail(body: ProtocolDetailInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/update-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdateDetail(_response));
        });
    }

    protected processUpdateDetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑消息
     * @param body (optional) 
     * @return Success
     */
    updateHead(body: ProtocolHeadInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/update-head";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdateHead(_response));
        });
    }

    protected processUpdateHead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 上传dbc文件
     * @param protocolId (optional) 
     * @param uploadedFile (optional) 
     * @return Success
     */
    uploadDbc(protocolId: string | undefined, uploadedFile: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/upload-dbc?";
        if (protocolId === null)
            throw new Error("The parameter 'protocolId' cannot be null.");
        else if (protocolId !== undefined)
            url_ += "protocolId=" + encodeURIComponent("" + protocolId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (uploadedFile === null || uploadedFile === undefined)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else
            content_.append("uploadedFile", uploadedFile.data, uploadedFile.fileName ? uploadedFile.fileName : "uploadedFile");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUploadDbc(_response));
        });
    }

    protected processUploadDbc(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 缓存
     * @return Success
     */
    cacheProtocol(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/battery/cache-protocol";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCacheProtocol(_response));
        });
    }

    protected processCacheProtocol(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CommonServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * mongo的Luuid转成Guid
     * @param mongoLuuid (optional) 
     * @return Success
     */
    getGuid(mongoLuuid: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/common/get-guid?";
        if (mongoLuuid === null)
            throw new Error("The parameter 'mongoLuuid' cannot be null.");
        else if (mongoLuuid !== undefined)
            url_ += "mongoLuuid=" + encodeURIComponent("" + mongoLuuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetGuid(_response));
        });
    }

    protected processGetGuid(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * 下拉选择电池
     * @return Success
     */
    selectBattery(  cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/common/select-battery";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectBattery(_response));
        });
    }

    protected processSelectBattery(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 下拉选择车辆
     * @return Success
     */
    selectVehicle(  cancelToken?: CancelToken | undefined): Promise<VehicleBatteryDto[]> {
        let url_ = this.baseUrl + "/common/select-vehicle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectVehicle(_response));
        });
    }

    protected processSelectVehicle(response: AxiosResponse): Promise<VehicleBatteryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleBatteryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<VehicleBatteryDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VehicleBatteryDto[]>(null as any);
    }

    /**
     * 下拉选择客户
     * @return Success
     */
    selectCustomer(  cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/common/select-customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectCustomer(_response));
        });
    }

    protected processSelectCustomer(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 下拉选择设备
     * @return Success
     */
    selectDevice(  cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/common/select-device";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectDevice(_response));
        });
    }

    protected processSelectDevice(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 下拉选择产品
     * @return Success
     */
    selectProduct(  cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/common/select-product";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectProduct(_response));
        });
    }

    protected processSelectProduct(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 下拉选择规则
     * @return Success
     */
    selectRule(  cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/common/select-rule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectRule(_response));
        });
    }

    protected processSelectRule(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * test
     * @param value (optional) 
     * @return Success
     */
    testRabbit(value: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/common/test-rabbit?";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTestRabbit(_response));
        });
    }

    protected processTestRabbit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 用户密码重置
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/common/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processResetPassword(_response));
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * catl故障码文件Http路径
     * @return Success
     */
    catlFileUrl(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/common/catl-file-url";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCatlFileUrl(_response));
        });
    }

    protected processCatlFileUrl(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class CustomersServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 创建客户
     * @param body (optional) 
     * @return Success
     */
    create(body: CustomerInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除客户
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑客户
     * @param body (optional) 
     * @return Success
     */
    edit(body: CustomerInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEdit(_response));
        });
    }

    protected processEdit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 分页查询客户
     * @param body (optional) 
     * @return Success
     */
    page(body: PageCustomerInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<CustomerOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/customer/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<CustomerOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<CustomerOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 中国省市数据
     * @return Success
     */
    china(  cancelToken?: CancelToken | undefined): Promise<ChinaDataDto> {
        let url_ = this.baseUrl + "/customer/china";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processChina(_response));
        });
    }

    protected processChina(response: AxiosResponse): Promise<ChinaDataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChinaDataDto.fromJS(resultData200);
            return Promise.resolve<ChinaDataDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChinaDataDto>(null as any);
    }

    /**
     * 创建租户管理员
     * @param body (optional) 
     * @return Success
     */
    tenant(body: BuildTenantAdminInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/tenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTenant(_response));
        });
    }

    protected processTenant(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 关闭租户管理员
     * @param body (optional) 
     * @return Success
     */
    close(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/close";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processClose(_response));
        });
    }

    protected processClose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 为客户添加车辆
     * @param body (optional) 
     * @return Success
     */
    addVehicle(body: CustomerAddVehicleDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/add-vehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddVehicle(_response));
        });
    }

    protected processAddVehicle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 为客户添加账号
     * @param body (optional) 
     * @return Success
     */
    addUser(body: CustomerAddUserDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/add-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddUser(_response));
        });
    }

    protected processAddUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 为客户移除车辆
     * @param body (optional) 
     * @return Success
     */
    removeVehicle(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/remove-vehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRemoveVehicle(_response));
        });
    }

    protected processRemoveVehicle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 为客户移除用户
     * @param body (optional) 
     * @return Success
     */
    removeUser(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/customer/remove-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRemoveUser(_response));
        });
    }

    protected processRemoveUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 客户分配账号列表
     * @param body (optional) 
     * @return Success
     */
    pageUser(body: PageCustomerUserInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<CustomerUserOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/customer/page-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPageUser(_response));
        });
    }

    protected processPageUser(response: AxiosResponse): Promise<CustomerUserOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerUserOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<CustomerUserOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerUserOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 客户分配设备车辆
     * @param body (optional) 
     * @return Success
     */
    pageVehicle(body: PageCustomerVehicleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<CustomerVehicleOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/customer/page-vehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPageVehicle(_response));
        });
    }

    protected processPageVehicle(response: AxiosResponse): Promise<CustomerVehicleOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerVehicleOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<CustomerVehicleOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerVehicleOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 客户一级树
     * @return Success
     */
    tree(  cancelToken?: CancelToken | undefined): Promise<CustomerTreeDataDto[]> {
        let url_ = this.baseUrl + "/customer/tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTree(_response));
        });
    }

    protected processTree(response: AxiosResponse): Promise<CustomerTreeDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerTreeDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CustomerTreeDataDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerTreeDataDto[]>(null as any);
    }

    /**
     * 未分配客户的账户
     * @param body (optional) 
     * @return Success
     */
    unCustomerUser(body: PageCustomerUserInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<NoCustomerUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/customer/un-customer-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUnCustomerUser(_response));
        });
    }

    protected processUnCustomerUser(response: AxiosResponse): Promise<NoCustomerUserDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NoCustomerUserDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<NoCustomerUserDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NoCustomerUserDtoPagedResultDto>(null as any);
    }

    /**
     * 未分配客户的车辆
     * @param body (optional) 
     * @return Success
     */
    unCustomerVehicle(body: PageCustomerVehicleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<NoCustomerVehicleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/customer/un-customer-vehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUnCustomerVehicle(_response));
        });
    }

    protected processUnCustomerVehicle(response: AxiosResponse): Promise<NoCustomerVehicleDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NoCustomerVehicleDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<NoCustomerVehicleDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NoCustomerVehicleDtoPagedResultDto>(null as any);
    }
}

export class DashboardServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 仪表盘卡片信息
     * @return Success
     */
    cardInfo(  cancelToken?: CancelToken | undefined): Promise<DashboardCardDto> {
        let url_ = this.baseUrl + "/dashboard/card-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCardInfo(_response));
        });
    }

    protected processCardInfo(response: AxiosResponse): Promise<DashboardCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardCardDto.fromJS(resultData200);
            return Promise.resolve<DashboardCardDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardCardDto>(null as any);
    }

    /**
     * 电芯电压图表
     * @param body (optional) 
     * @return Success
     */
    cellVoltage(body: CheckDeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<CellChartDto> {
        let url_ = this.baseUrl + "/dashboard/cell-voltage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCellVoltage(_response));
        });
    }

    protected processCellVoltage(response: AxiosResponse): Promise<CellChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CellChartDto.fromJS(resultData200);
            return Promise.resolve<CellChartDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CellChartDto>(null as any);
    }

    /**
     * 电芯温度图表
     * @param body (optional) 
     * @return Success
     */
    cellTemperature(body: CheckDeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<CellChartDto> {
        let url_ = this.baseUrl + "/dashboard/cell-temperature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCellTemperature(_response));
        });
    }

    protected processCellTemperature(response: AxiosResponse): Promise<CellChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CellChartDto.fromJS(resultData200);
            return Promise.resolve<CellChartDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CellChartDto>(null as any);
    }

    /**
     * 电池SOC图表
     * @param body (optional) 
     * @return Success
     */
    soc(body: CheckDeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/dashboard/soc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSoc(_response));
        });
    }

    protected processSoc(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * 电池SOH图表
     * @param body (optional) 
     * @return Success
     */
    soh(body: CheckDeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/dashboard/soh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSoh(_response));
        });
    }

    protected processSoh(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * 电池包汇总信息
     * @param body (optional) 
     * @return Success
     */
    packInfo(body: CheckDeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<BatteryPackInfoDto> {
        let url_ = this.baseUrl + "/dashboard/pack-info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPackInfo(_response));
        });
    }

    protected processPackInfo(response: AxiosResponse): Promise<BatteryPackInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatteryPackInfoDto.fromJS(resultData200);
            return Promise.resolve<BatteryPackInfoDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryPackInfoDto>(null as any);
    }

    /**
     * 车辆分布散点图
     * @return Success
     */
    vehicleScatterChart(  cancelToken?: CancelToken | undefined): Promise<VehicleScatterChartDto> {
        let url_ = this.baseUrl + "/dashboard/vehicle-scatter-chart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVehicleScatterChart(_response));
        });
    }

    protected processVehicleScatterChart(response: AxiosResponse): Promise<VehicleScatterChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VehicleScatterChartDto.fromJS(resultData200);
            return Promise.resolve<VehicleScatterChartDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VehicleScatterChartDto>(null as any);
    }

    /**
     * 上下线记录
     * @return Success
     */
    conncetLog(  cancelToken?: CancelToken | undefined): Promise<MongoConnectLog[]> {
        let url_ = this.baseUrl + "/dashboard/conncet-log";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processConncetLog(_response));
        });
    }

    protected processConncetLog(response: AxiosResponse): Promise<MongoConnectLog[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MongoConnectLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MongoConnectLog[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MongoConnectLog[]>(null as any);
    }
}

export class DataDictionaryServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页字典类型
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingDataDictionaryInput | undefined , cancelToken?: CancelToken | undefined): Promise<PagingDataDictionaryOutputPagedResultDto> {
        let url_ = this.baseUrl + "/DataDictionary/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<PagingDataDictionaryOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagingDataDictionaryOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PagingDataDictionaryOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagingDataDictionaryOutputPagedResultDto>(null as any);
    }

    /**
     * 分页字典明细
     * @param body (optional) 
     * @return Success
     */
    pageDetail(body: PagingDataDictionaryDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<PagingDataDictionaryDetailOutputPagedResultDto> {
        let url_ = this.baseUrl + "/DataDictionary/pageDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPageDetail(_response));
        });
    }

    protected processPageDetail(response: AxiosResponse): Promise<PagingDataDictionaryDetailOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagingDataDictionaryDetailOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PagingDataDictionaryDetailOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagingDataDictionaryDetailOutputPagedResultDto>(null as any);
    }

    /**
     * 创建字典类型
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDataDictinaryInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/DataDictionary/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 创建字典明细
     * @param body (optional) 
     * @return Success
     */
    createDetail(body: CreateDataDictinaryDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/DataDictionary/createDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreateDetail(_response));
        });
    }

    protected processCreateDetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 设置字典明细状态
     * @param body (optional) 
     * @return Success
     */
    status(body: SetDataDictinaryDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/DataDictionary/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processStatus(_response));
        });
    }

    protected processStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 更新字典明细
     * @param body (optional) 
     * @return Success
     */
    updateDetail(body: UpdateDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/DataDictionary/updateDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdateDetail(_response));
        });
    }

    protected processUpdateDetail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除字典明细
     * @param body (optional) 
     * @return Success
     */
    delete(body: DeleteDataDictionaryDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/DataDictionary/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除字典类型
     * @param body (optional) 
     * @return Success
     */
    deleteDataDictionaryType(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/DataDictionary/deleteDataDictionaryType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteDataDictionaryType(_response));
        });
    }

    protected processDeleteDataDictionaryType(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 修改字典类型
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDataDictinaryInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/DataDictionary/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeviceServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 创建设备
     * @param body (optional) 
     * @return Success
     */
    create(body: DeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/device/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除设备
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/device/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑设备
     * @param body (optional) 
     * @return Success
     */
    edit(body: DeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/device/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEdit(_response));
        });
    }

    protected processEdit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 分页查询设备
     * @param body (optional) 
     * @return Success
     */
    page(body: PageDeviceInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<DeviceOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/device/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<DeviceOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<DeviceOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 分页查询设备属性
     * @param body (optional) 
     * @return Success
     */
    attribute(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<AttributeOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/device/attribute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttribute(_response));
        });
    }

    protected processAttribute(response: AxiosResponse): Promise<AttributeOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttributeOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<AttributeOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttributeOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 设备树
     * @return Success
     */
    tree(  cancelToken?: CancelToken | undefined): Promise<TreeDataDto[]> {
        let url_ = this.baseUrl + "/device/tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTree(_response));
        });
    }

    protected processTree(response: AxiosResponse): Promise<TreeDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TreeDataDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreeDataDto[]>(null as any);
    }

    /**
     * 实时遥测数据
     * @param body (optional) 
     * @return Success
     */
    realTel(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<StringNameValue[]> {
        let url_ = this.baseUrl + "/device/real-tel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRealTel(_response));
        });
    }

    protected processRealTel(response: AxiosResponse): Promise<StringNameValue[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StringNameValue.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StringNameValue[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringNameValue[]>(null as any);
    }

    /**
     * 数字类型的遥测属性
     * @param body (optional) 
     * @return Success
     */
    telCurve(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<StringNameValue[]> {
        let url_ = this.baseUrl + "/device/tel-curve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTelCurve(_response));
        });
    }

    protected processTelCurve(response: AxiosResponse): Promise<StringNameValue[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StringNameValue.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StringNameValue[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringNameValue[]>(null as any);
    }

    /**
     * 遥测数据曲线图
     * @param body (optional) 
     * @return Success
     */
    chartTel(body: ListTelemetryChartDataInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<TelemetryChartDataDto> {
        let url_ = this.baseUrl + "/device/chart-tel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processChartTel(_response));
        });
    }

    protected processChartTel(response: AxiosResponse): Promise<TelemetryChartDataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TelemetryChartDataDto.fromJS(resultData200);
            return Promise.resolve<TelemetryChartDataDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TelemetryChartDataDto>(null as any);
    }

    /**
     * 上传设备图片
     * @return Success
     */
    uploadImg(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/device/upload-img";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUploadImg(_response));
        });
    }

    protected processUploadImg(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * 获取设备图片
     * @param body (optional) 
     * @return Success
     */
    getImg(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/device/get-img";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetImg(_response));
        });
    }

    protected processGetImg(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * 获取设备报警列表
     * @param body (optional) 
     * @return Success
     */
    alarm(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<RealTimeAlarmDto[]> {
        let url_ = this.baseUrl + "/device/alarm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAlarm(_response));
        });
    }

    protected processAlarm(response: AxiosResponse): Promise<RealTimeAlarmDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RealTimeAlarmDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RealTimeAlarmDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RealTimeAlarmDto[]>(null as any);
    }

    /**
     * 清除某笔报警
     * @param body (optional) 
     * @return Success
     */
    clear(body: ClearAlarmInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/device/clear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processClear(_response));
        });
    }

    protected processClear(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 分页查询设备规则
     * @param body (optional) 
     * @return Success
     */
    rule(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<DeviceRuleOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/device/rule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRule(_response));
        });
    }

    protected processRule(response: AxiosResponse): Promise<DeviceRuleOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceRuleOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<DeviceRuleOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceRuleOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 关联设备和规则
     * @param body (optional) 
     * @return Success
     */
    relate(body: RelateDeviceRuleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/device/relate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRelate(_response));
        });
    }

    protected processRelate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 开关启用
     * @param body (optional) 
     * @return Success
     */
    enable(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/device/enable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEnable(_response));
        });
    }

    protected processEnable(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 为网关添加设备
     * @param body (optional) 
     * @return Success
     */
    addSonDevice(body: GatewayAddDeviceDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/device/add-son-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddSonDevice(_response));
        });
    }

    protected processAddSonDevice(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取未绑定网关的设备
     * @return Success
     */
    noGatewayDevice(  cancelToken?: CancelToken | undefined): Promise<GuidNameValue[]> {
        let url_ = this.baseUrl + "/device/no-gateway-device";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNoGatewayDevice(_response));
        });
    }

    protected processNoGatewayDevice(response: AxiosResponse): Promise<GuidNameValue[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GuidNameValue.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GuidNameValue[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GuidNameValue[]>(null as any);
    }

    /**
     * 设备详情
     * @param body (optional) 
     * @return Success
     */
    deviceDetail(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<DeviceDetailInfoDto> {
        let url_ = this.baseUrl + "/device/device-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeviceDetail(_response));
        });
    }

    protected processDeviceDetail(response: AxiosResponse): Promise<DeviceDetailInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceDetailInfoDto.fromJS(resultData200);
            return Promise.resolve<DeviceDetailInfoDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceDetailInfoDto>(null as any);
    }

    /**
     * 获取绑定网关的设备和所有未绑定网关的设备
     * @param body (optional) 
     * @return Success
     */
    gatewayDevice(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<GatewayDeviceDto[]> {
        let url_ = this.baseUrl + "/device/gateway-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGatewayDevice(_response));
        });
    }

    protected processGatewayDevice(response: AxiosResponse): Promise<GatewayDeviceDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GatewayDeviceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GatewayDeviceDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GatewayDeviceDto[]>(null as any);
    }
}

export class FileServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 车辆关键参数分析导出
     * @param body (optional) 
     * @return Success
     */
    analysisExport(body: KeyParameterAnalysisInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/file/analysis-export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAnalysisExport(_response));
        });
    }

    protected processAnalysisExport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class HistoryServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 下拉设备
     * @return Success
     */
    deviceSelect(  cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/history/device-select";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeviceSelect(_response));
        });
    }

    protected processDeviceSelect(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 下拉设备的遥测属性
     * @param body (optional) 
     * @return Success
     */
    deviceTelemetrySelect(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/history/device-telemetry-select";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeviceTelemetrySelect(_response));
        });
    }

    protected processDeviceTelemetrySelect(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 设备遥测历史
     * @param body (optional) 
     * @return Success
     */
    page(body: PageTelemetryHistoryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<DeviceTelemetryHistoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/history/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<DeviceTelemetryHistoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceTelemetryHistoryDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<DeviceTelemetryHistoryDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceTelemetryHistoryDtoPagedResultDto>(null as any);
    }

    /**
     * 遥测属性曲线
     * @param body (optional) 
     * @return Success
     */
    deviceTelemetryChart(body: PageTelemetryHistoryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<TelmetryHistoryChartDto> {
        let url_ = this.baseUrl + "/history/device-telemetry-chart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeviceTelemetryChart(_response));
        });
    }

    protected processDeviceTelemetryChart(response: AxiosResponse): Promise<TelmetryHistoryChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TelmetryHistoryChartDto.fromJS(resultData200);
            return Promise.resolve<TelmetryHistoryChartDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TelmetryHistoryChartDto>(null as any);
    }

    /**
     * 设备遥测历史
     * @param body (optional) 
     * @return Success
     */
    multiPage(body: PageTelemetryHistoryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<DeviceTelemetryHistoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/history/multi-page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMultiPage(_response));
        });
    }

    protected processMultiPage(response: AxiosResponse): Promise<DeviceTelemetryHistoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceTelemetryHistoryDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<DeviceTelemetryHistoryDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceTelemetryHistoryDtoPagedResultDto>(null as any);
    }

    /**
     * 遥测属性曲线
     * @param body (optional) 
     * @return Success
     */
    multiDeviceTelemetryChart(body: PageTelemetryHistoryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<TelmetryHistoryChartDto> {
        let url_ = this.baseUrl + "/history/multi-device-telemetry-chart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMultiDeviceTelemetryChart(_response));
        });
    }

    protected processMultiDeviceTelemetryChart(response: AxiosResponse): Promise<TelmetryHistoryChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TelmetryHistoryChartDto.fromJS(resultData200);
            return Promise.resolve<TelmetryHistoryChartDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TelmetryHistoryChartDto>(null as any);
    }
}

export class IdentitySecurityLogsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页获取登录日志信息
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingIdentitySecurityLogInput | undefined , cancelToken?: CancelToken | undefined): Promise<PagingIdentitySecurityLogOutputPagedResultDto> {
        let url_ = this.baseUrl + "/IdentitySecurityLogs/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<PagingIdentitySecurityLogOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagingIdentitySecurityLogOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PagingIdentitySecurityLogOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagingIdentitySecurityLogOutputPagedResultDto>(null as any);
    }
}

export class LanguagesServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取所有语言
     * @return Success
     */
    all(  cancelToken?: CancelToken | undefined): Promise<PageLanguageOutput[]> {
        let url_ = this.baseUrl + "/Languages/All";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAll(_response));
        });
    }

    protected processAll(response: AxiosResponse): Promise<PageLanguageOutput[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageLanguageOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PageLanguageOutput[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageLanguageOutput[]>(null as any);
    }

    /**
     * 分页查询语言
     * @param body (optional) 
     * @return Success
     */
    page(body: PageLanguageInput | undefined , cancelToken?: CancelToken | undefined): Promise<PageLanguageOutputPagedResultDto> {
        let url_ = this.baseUrl + "/Languages/Page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<PageLanguageOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageLanguageOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PageLanguageOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageLanguageOutputPagedResultDto>(null as any);
    }

    /**
     * 创建语言
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLanguageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Languages/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑语言
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLanguageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Languages/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除语言
     * @param body (optional) 
     * @return Success
     */
    delete(body: DeleteLanguageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Languages/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 设置默认语言
     * @param body (optional) 
     * @return Success
     */
    setDefault(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Languages/SetDefault";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSetDefault(_response));
        });
    }

    protected processSetDefault(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LanguageTextsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取所有资源
     * @return Success
     */
    allResource(  cancelToken?: CancelToken | undefined): Promise<StringStringFromSelector[]> {
        let url_ = this.baseUrl + "/LanguageTexts/AllResource";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAllResource(_response));
        });
    }

    protected processAllResource(response: AxiosResponse): Promise<StringStringFromSelector[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StringStringFromSelector.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StringStringFromSelector[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringStringFromSelector[]>(null as any);
    }

    /**
     * 分页查询语言文本
     * @param body (optional) 
     * @return Success
     */
    page(body: PageLanguageTextInput | undefined , cancelToken?: CancelToken | undefined): Promise<PageLanguageTextOutputPagedResultDto> {
        let url_ = this.baseUrl + "/LanguageTexts/Page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<PageLanguageTextOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageLanguageTextOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PageLanguageTextOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageLanguageTextOutputPagedResultDto>(null as any);
    }

    /**
     * 创建语言文本
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLanguageTextInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/LanguageTexts/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑语言文本
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLanguageTextInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/LanguageTexts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MiniProgramServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 电池包信息
     * @param body (optional) 
     * @return Success
     */
    pack(body: ScanVehicleCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<BatteryPackInfoDto> {
        let url_ = this.baseUrl + "/mp/pack";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPack(_response));
        });
    }

    protected processPack(response: AxiosResponse): Promise<BatteryPackInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatteryPackInfoDto.fromJS(resultData200);
            return Promise.resolve<BatteryPackInfoDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryPackInfoDto>(null as any);
    }

    /**
     * 扫码获取车辆实体
     * @param body (optional) 
     * @return Success
     */
    info(body: ScanVehicleCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<VehicleInfoDto> {
        let url_ = this.baseUrl + "/mp/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processInfo(_response));
        });
    }

    protected processInfo(response: AxiosResponse): Promise<VehicleInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VehicleInfoDto.fromJS(resultData200);
            return Promise.resolve<VehicleInfoDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VehicleInfoDto>(null as any);
    }

    /**
     * 同厂区其他车辆
     * @param body (optional) 
     * @return Success
     */
    other(body: ScanVehicleCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<VehicleInfoDto[]> {
        let url_ = this.baseUrl + "/mp/other";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processOther(_response));
        });
    }

    protected processOther(response: AxiosResponse): Promise<VehicleInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<VehicleInfoDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VehicleInfoDto[]>(null as any);
    }

    /**
     * 电芯电压
     * @param body (optional) 
     * @return Success
     */
    cellVoltage(body: ScanVehicleCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<CellChartDto> {
        let url_ = this.baseUrl + "/mp/cellVoltage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCellVoltage(_response));
        });
    }

    protected processCellVoltage(response: AxiosResponse): Promise<CellChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CellChartDto.fromJS(resultData200);
            return Promise.resolve<CellChartDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CellChartDto>(null as any);
    }

    /**
     * 电芯温度
     * @param body (optional) 
     * @return Success
     */
    cellTemperature(body: ScanVehicleCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<CellChartDto> {
        let url_ = this.baseUrl + "/mp/cellTemperature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCellTemperature(_response));
        });
    }

    protected processCellTemperature(response: AxiosResponse): Promise<CellChartDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CellChartDto.fromJS(resultData200);
            return Promise.resolve<CellChartDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CellChartDto>(null as any);
    }

    /**
     * 运行充电总时长
     * @param body (optional) 
     * @return Success
     */
    totalTime(body: ScanVehicleCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<RunTotalRecord> {
        let url_ = this.baseUrl + "/mp/totalTime";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTotalTime(_response));
        });
    }

    protected processTotalTime(response: AxiosResponse): Promise<RunTotalRecord> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RunTotalRecord.fromJS(resultData200);
            return Promise.resolve<RunTotalRecord>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RunTotalRecord>(null as any);
    }

    /**
     * 电池SOC
     * @param body (optional) 
     * @return Success
     */
    soc(body: ScanVehicleCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/mp/soc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSoc(_response));
        });
    }

    protected processSoc(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export class NotificationServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页查询普通消息
     * @param body (optional) 
     * @return Success
     */
    common(body: PagingNotificationListInput | undefined , cancelToken?: CancelToken | undefined): Promise<PagingNotificationListOutputPagedResultDto> {
        let url_ = this.baseUrl + "/Notification/Common";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCommon(_response));
        });
    }

    protected processCommon(response: AxiosResponse): Promise<PagingNotificationListOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagingNotificationListOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PagingNotificationListOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagingNotificationListOutputPagedResultDto>(null as any);
    }

    /**
     * 分页查询广播消息
     * @param body (optional) 
     * @return Success
     */
    broadCast(body: PagingNotificationListInput | undefined , cancelToken?: CancelToken | undefined): Promise<PagingNotificationListOutputPagedResultDto> {
        let url_ = this.baseUrl + "/Notification/BroadCast";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBroadCast(_response));
        });
    }

    protected processBroadCast(response: AxiosResponse): Promise<PagingNotificationListOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagingNotificationListOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<PagingNotificationListOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagingNotificationListOutputPagedResultDto>(null as any);
    }

    /**
     * 发送警告文本消息
     * @param body (optional) 
     * @return Success
     */
    sendCommonWarningMessage(body: SendCommonMessageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Notification/SendCommonWarningMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSendCommonWarningMessage(_response));
        });
    }

    protected processSendCommonWarningMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 发送普通文本消息
     * @param body (optional) 
     * @return Success
     */
    sendCommonInformationMessage(body: SendCommonMessageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Notification/SendCommonInformationMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSendCommonInformationMessage(_response));
        });
    }

    protected processSendCommonInformationMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 发送错误文本消息
     * @param body (optional) 
     * @return Success
     */
    sendCommonErrorMessage(body: SendCommonMessageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Notification/SendCommonErrorMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSendCommonErrorMessage(_response));
        });
    }

    protected processSendCommonErrorMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 发送警告广播消息
     * @param body (optional) 
     * @return Success
     */
    sendBroadCastWarningMessage(body: SendBroadCastMessageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Notification/SendBroadCastWarningMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSendBroadCastWarningMessage(_response));
        });
    }

    protected processSendBroadCastWarningMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 发送正常广播消息
     * @param body (optional) 
     * @return Success
     */
    sendBroadCastInformationMessage(body: SendBroadCastMessageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Notification/SendBroadCastInformationMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSendBroadCastInformationMessage(_response));
        });
    }

    protected processSendBroadCastInformationMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 发送错误广播消息
     * @param body (optional) 
     * @return Success
     */
    sendBroadCastErrorMessage(body: SendBroadCastMessageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Notification/SendBroadCastErrorMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSendBroadCastErrorMessage(_response));
        });
    }

    protected processSendBroadCastErrorMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 消息设置为已读
     * @param body (optional) 
     * @return Success
     */
    read(body: SetReadInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Notification/Read";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRead(_response));
        });
    }

    protected processRead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OrganizationUnitsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取组织机构树
     * @return Success
     */
    tree(  cancelToken?: CancelToken | undefined): Promise<TreeOutput[]> {
        let url_ = this.baseUrl + "/OrganizationUnits/tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTree(_response));
        });
    }

    protected processTree(response: AxiosResponse): Promise<TreeOutput[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TreeOutput[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreeOutput[]>(null as any);
    }

    /**
     * 创建组织机构
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/OrganizationUnits/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除组织机构
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/OrganizationUnits/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑组织机构
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/OrganizationUnits/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 向组织机构添加角色
     * @param body (optional) 
     * @return Success
     */
    addRoleToOrganizationUnit(body: AddRoleToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/OrganizationUnits/addRoleToOrganizationUnitAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddRoleToOrganizationUnit(_response));
        });
    }

    protected processAddRoleToOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 向组织机构删除角色
     * @param body (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(body: RemoveRoleToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/OrganizationUnits/removeRoleFromOrganizationUnitAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRemoveRoleFromOrganizationUnit(_response));
        });
    }

    protected processRemoveRoleFromOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 向组织机构添加用户
     * @param body (optional) 
     * @return Success
     */
    addUserToOrganizationUnit(body: AddUserToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/OrganizationUnits/addUserToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddUserToOrganizationUnit(_response));
        });
    }

    protected processAddUserToOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 向组织机构删除用户
     * @param body (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(body: RemoveUserToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/OrganizationUnits/removeUserFromOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRemoveUserFromOrganizationUnit(_response));
        });
    }

    protected processRemoveUserFromOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 分页获取组织机构下用户
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: GetOrganizationUnitUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<GetOrganizationUnitUserOutputPagedResultDto> {
        let url_ = this.baseUrl + "/OrganizationUnits/getUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetUsers(_response));
        });
    }

    protected processGetUsers(response: AxiosResponse): Promise<GetOrganizationUnitUserOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetOrganizationUnitUserOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<GetOrganizationUnitUserOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrganizationUnitUserOutputPagedResultDto>(null as any);
    }

    /**
     * 分页获取组织机构下角色
     * @param body (optional) 
     * @return Success
     */
    getRoles(body: GetOrganizationUnitRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<GetOrganizationUnitRoleOutputPagedResultDto> {
        let url_ = this.baseUrl + "/OrganizationUnits/getRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetRoles(_response));
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<GetOrganizationUnitRoleOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetOrganizationUnitRoleOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<GetOrganizationUnitRoleOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetOrganizationUnitRoleOutputPagedResultDto>(null as any);
    }

    /**
     * 获取不在组织机构的用户
     * @param body (optional) 
     * @return Success
     */
    getUnAddUsers(body: GetUnAddUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<GetUnAddUserOutputPagedResultDto> {
        let url_ = this.baseUrl + "/OrganizationUnits/getUnAddUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetUnAddUsers(_response));
        });
    }

    protected processGetUnAddUsers(response: AxiosResponse): Promise<GetUnAddUserOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUnAddUserOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<GetUnAddUserOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUnAddUserOutputPagedResultDto>(null as any);
    }

    /**
     * 获取不在组织机构的角色
     * @param body (optional) 
     * @return Success
     */
    getUnAddRoles(body: GetUnAddRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<GetUnAddRoleOutputPagedResultDto> {
        let url_ = this.baseUrl + "/OrganizationUnits/getUnAddRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetUnAddRoles(_response));
        });
    }

    protected processGetUnAddRoles(response: AxiosResponse): Promise<GetUnAddRoleOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUnAddRoleOutputPagedResultDto.fromJS(resultData200);
            return Promise.resolve<GetUnAddRoleOutputPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUnAddRoleOutputPagedResultDto>(null as any);
    }
}

export class PermissionsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取角色权限
     * @param body (optional) 
     * @return Success
     */
    tree(body: GetPermissionInput | undefined , cancelToken?: CancelToken | undefined): Promise<PermissionOutput> {
        let url_ = this.baseUrl + "/Permissions/tree";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTree(_response));
        });
    }

    protected processTree(response: AxiosResponse): Promise<PermissionOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PermissionOutput.fromJS(resultData200);
            return Promise.resolve<PermissionOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PermissionOutput>(null as any);
    }

    /**
     * 更新角色
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRolePermissionsInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Permissions/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProductServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 生成设备
     * @param body (optional) 
     * @return Success
     */
    build(body: BuildDeviceDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/product/build";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBuild(_response));
        });
    }

    protected processBuild(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 创建产品
     * @param body (optional) 
     * @return Success
     */
    create(body: ProductInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/product/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除产品
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/product/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑产品
     * @param body (optional) 
     * @return Success
     */
    edit(body: ProductInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/product/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEdit(_response));
        });
    }

    protected processEdit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取产品关联的设备
     * @param body (optional) 
     * @return Success
     */
    list(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<DeviceOutputDto[]> {
        let url_ = this.baseUrl + "/product/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processList(_response));
        });
    }

    protected processList(response: AxiosResponse): Promise<DeviceOutputDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceOutputDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceOutputDto[]>(null as any);
    }

    /**
     * 分页查询产品
     * @param body (optional) 
     * @return Success
     */
    page(body: PageProductInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<ProductOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/product/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<ProductOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<ProductOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductOutputDtoPagedResultDto>(null as any);
    }
}

export class RolesServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取所有角色
     * @return Success
     */
    all(  cancelToken?: CancelToken | undefined): Promise<IdentityRoleDtoListResultDto> {
        let url_ = this.baseUrl + "/Roles/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAll(_response));
        });
    }

    protected processAll(response: AxiosResponse): Promise<IdentityRoleDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDtoListResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDtoListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDtoListResultDto>(null as any);
    }

    /**
     * 分页获取角色
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingRoleListInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Roles/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<IdentityRoleDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDtoPagedResultDto>(null as any);
    }

    /**
     * 创建角色
     * @param body (optional) 
     * @return Success
     */
    create(body: IdentityRoleCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/Roles/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * 更新角色
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/Roles/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * 删除角色
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Roles/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RuleServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 创建规则
     * @param body (optional) 
     * @return Success
     */
    create(body: RuleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/rule/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除规则
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/rule/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑规则
     * @param body (optional) 
     * @return Success
     */
    edit(body: RuleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/rule/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEdit(_response));
        });
    }

    protected processEdit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 分页查询规则
     * @param body (optional) 
     * @return Success
     */
    page(body: PageRuleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/rule/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<RuleOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<RuleOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleOutputDtoPagedResultDto>(null as any);
    }

    /**
     * Json或者script上传
     * @param body (optional) 
     * @return Success
     */
    content(body: UpdateContentInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/rule/content";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContent(_response));
        });
    }

    protected processContent(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 查询规则挂载的设备
     * @param body (optional) 
     * @return Success
     */
    ruleDevice(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<GuidNameValue[]> {
        let url_ = this.baseUrl + "/rule/rule-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRuleDevice(_response));
        });
    }

    protected processRuleDevice(response: AxiosResponse): Promise<GuidNameValue[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GuidNameValue.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GuidNameValue[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GuidNameValue[]>(null as any);
    }

    /**
     * 查询规则日志
     * @param body (optional) 
     * @return Success
     */
    ruleLog(body: PageRuleLogInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<RuleLogOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/rule/rule-log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRuleLog(_response));
        });
    }

    protected processRuleLog(response: AxiosResponse): Promise<RuleLogOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RuleLogOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<RuleLogOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RuleLogOutputDtoPagedResultDto>(null as any);
    }
}

export class SettingsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取所有Setting
     * @return Success
     */
    all(  cancelToken?: CancelToken | undefined): Promise<SettingOutput[]> {
        let url_ = this.baseUrl + "/Settings/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAll(_response));
        });
    }

    protected processAll(response: AxiosResponse): Promise<SettingOutput[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SettingOutput[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SettingOutput[]>(null as any);
    }

    /**
     * 更新Setting
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSettingInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Settings/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TelemetryServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 设备树
     * @return Success
     */
    deviceTree(  cancelToken?: CancelToken | undefined): Promise<TreeDataDto[]> {
        let url_ = this.baseUrl + "/telemetry/device-tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeviceTree(_response));
        });
    }

    protected processDeviceTree(response: AxiosResponse): Promise<TreeDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TreeDataDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TreeDataDto[]>(null as any);
    }

    /**
     * 同步设备遥测属性
     * @param body (optional) 
     * @return Success
     */
    syncTelemetry(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/sync-telemetry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSyncTelemetry(_response));
        });
    }

    protected processSyncTelemetry(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 查询设备遥测
     * @param body (optional) 
     * @return Success
     */
    listTelemetry(body: ListDeviceTelemetryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<TelemetryOutputDto[]> {
        let url_ = this.baseUrl + "/telemetry/list-telemetry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processListTelemetry(_response));
        });
    }

    protected processListTelemetry(response: AxiosResponse): Promise<TelemetryOutputDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TelemetryOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TelemetryOutputDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TelemetryOutputDto[]>(null as any);
    }

    /**
     * 下拉选择设备
     * @param body (optional) 
     * @return Success
     */
    selectDevice(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/telemetry/select-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectDevice(_response));
        });
    }

    protected processSelectDevice(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 下拉选择数据字典
     * @return Success
     */
    selectTmdic(  cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/telemetry/select-tmdic";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectTmdic(_response));
        });
    }

    protected processSelectTmdic(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 数据字典明细
     * @param body (optional) 
     * @return Success
     */
    detailTmdic(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/telemetry/detail-tmdic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDetailTmdic(_response));
        });
    }

    protected processDetailTmdic(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 遥测分发
     * @param body (optional) 
     * @return Success
     */
    distributeTelemetry(body: DistributeTelemetryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/distribute-telemetry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDistributeTelemetry(_response));
        });
    }

    protected processDistributeTelemetry(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 遥测映射
     * @param body (optional) 
     * @return Success
     */
    mappingTelemetry(body: MappingTelemetryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/mapping-telemetry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMappingTelemetry(_response));
        });
    }

    protected processMappingTelemetry(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 开关显示
     * @param body (optional) 
     * @return Success
     */
    show(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/show";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processShow(_response));
        });
    }

    protected processShow(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 开关曲线
     * @param body (optional) 
     * @return Success
     */
    curve(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/curve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCurve(_response));
        });
    }

    protected processCurve(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * delete-distribute
     * @param body (optional) 
     * @return Success
     */
    deleteDistribute(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/delete-distribute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteDistribute(_response));
        });
    }

    protected processDeleteDistribute(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除遥测
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 更新遥测
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTelemetryInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 描述更新
     * @param body (optional) 
     * @return Success
     */
    updateDes(body: UpdateTelemetryDesInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/telemetry/update-des";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdateDes(_response));
        });
    }

    protected processUpdateDes(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TenantsServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 通过名称获取租户信息
     * @param body (optional) 
     * @return Success
     */
    find(body: FindTenantByNameInput | undefined , cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/Tenants/find";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processFind(_response));
        });
    }

    protected processFind(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }

    /**
     * 分页获取租户信息
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingTenantInput | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Tenants/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<TenantDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<TenantDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * 创建租户
     * @param body (optional) 
     * @return Success
     */
    create(body: TenantCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/Tenants/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200);
            return Promise.resolve<TenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * 更新租户
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTenantInput | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/Tenants/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200);
            return Promise.resolve<TenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * 删除租户
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tenants/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取租户连接字符串
     * @param body (optional) 
     * @return Success
     */
    getConnectionString(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Tenants/getConnectionString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetConnectionString(_response));
        });
    }

    protected processGetConnectionString(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * 更新租户连接字符串
     * @param body (optional) 
     * @return Success
     */
    updateConnectionString(body: UpdateConnectionStringInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tenants/updateConnectionString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdateConnectionString(_response));
        });
    }

    protected processUpdateConnectionString(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除租户连接字符串
     * @param body (optional) 
     * @return Success
     */
    deleteConnectionString(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tenants/deleteConnectionString";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteConnectionString(_response));
        });
    }

    protected processDeleteConnectionString(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UsersServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 分页获取用户信息
     * @param body (optional) 
     * @return Success
     */
    page(body: PagingUserListInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Users/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<IdentityUserDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDtoPagedResultDto>(null as any);
    }

    /**
     * 导出用户列表
     * @param body (optional) 
     * @return Success
     */
    export(body: PagingUserListInput | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Users/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processExport(_response));
        });
    }

    protected processExport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 创建用户
     * @param body (optional) 
     * @return Success
     */
    create(body: IdentityUserCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/Users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * 编辑用户
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/Users/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * 删除用户
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Users/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取用户角色信息
     * @param body (optional) 
     * @return Success
     */
    role(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDtoListResultDto> {
        let url_ = this.baseUrl + "/Users/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRole(_response));
        });
    }

    protected processRole(response: AxiosResponse): Promise<IdentityRoleDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDtoListResultDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDtoListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDtoListResultDto>(null as any);
    }

    /**
     * 修改当前用户密码
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Users/changePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processChangePassword(_response));
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * 锁定用户
     * @param body (optional) 
     * @return Success
     */
    lock(body: LockUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Users/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processLock(_response));
        });
    }

    protected processLock(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VariableServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * JSON
     * @return Success
     */
    json(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/variable/json";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processJson(_response));
        });
    }

    protected processJson(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 变量导入
     * @param uploadedFile (optional) 
     * @return Success
     */
    import(uploadedFile: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/variable/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (uploadedFile === null || uploadedFile === undefined)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else
            content_.append("uploadedFile", uploadedFile.data, uploadedFile.fileName ? uploadedFile.fileName : "uploadedFile");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processImport(_response));
        });
    }

    protected processImport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * JSON
     * @return Success
     */
    simplifyJson(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/variable/simplify-json";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSimplifyJson(_response));
        });
    }

    protected processSimplifyJson(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * 同步到协议表
     * @return Success
     */
    save(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/variable/save";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSave(_response));
        });
    }

    protected processSave(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VehicleServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 创建车辆
     * @param body (optional) 
     * @return Success
     */
    create(body: VehicleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Vehicle/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreate(_response));
        });
    }

    protected processCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 删除车辆
     * @param body (optional) 
     * @return Success
     */
    delete(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Vehicle/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDelete(_response));
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 编辑车辆
     * @param body (optional) 
     * @return Success
     */
    edit(body: VehicleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Vehicle/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEdit(_response));
        });
    }

    protected processEdit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 车联网设备
     * @param body (optional) 
     * @return Success
     */
    children(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<DeviceOutputDto[]> {
        let url_ = this.baseUrl + "/Vehicle/children";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processChildren(_response));
        });
    }

    protected processChildren(response: AxiosResponse): Promise<DeviceOutputDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceOutputDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceOutputDto[]>(null as any);
    }

    /**
     * 分页查询车辆
     * @param body (optional) 
     * @return Success
     */
    page(body: PageVehicleInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<VehicleOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Vehicle/page";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPage(_response));
        });
    }

    protected processPage(response: AxiosResponse): Promise<VehicleOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VehicleOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<VehicleOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VehicleOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 车辆类型
     * @return Success
     */
    selectType(  cancelToken?: CancelToken | undefined): Promise<Int32NameValue[]> {
        let url_ = this.baseUrl + "/Vehicle/select-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectType(_response));
        });
    }

    protected processSelectType(response: AxiosResponse): Promise<Int32NameValue[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32NameValue.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32NameValue[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32NameValue[]>(null as any);
    }

    /**
     * 为车辆添加设备
     * @param body (optional) 
     * @return Success
     */
    addDevice(body: VehicleAddDeviceDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Vehicle/add-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddDevice(_response));
        });
    }

    protected processAddDevice(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 获取未绑定车辆的设备
     * @return Success
     */
    noVehicleDevice(  cancelToken?: CancelToken | undefined): Promise<GuidNameValue[]> {
        let url_ = this.baseUrl + "/Vehicle/no-vehicle-device";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNoVehicleDevice(_response));
        });
    }

    protected processNoVehicleDevice(response: AxiosResponse): Promise<GuidNameValue[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GuidNameValue.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GuidNameValue[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GuidNameValue[]>(null as any);
    }

    /**
     * 为车辆移除设备
     * @param body (optional) 
     * @return Success
     */
    removeDevice(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Vehicle/remove-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRemoveDevice(_response));
        });
    }

    protected processRemoveDevice(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 同部到Mongo
     * @param body (optional) 
     * @return Success
     */
    sync(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Vehicle/sync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSync(_response));
        });
    }

    protected processSync(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 下拉车辆
     * @return Success
     */
    selectVehicle(  cancelToken?: CancelToken | undefined): Promise<NameIdDto[]> {
        let url_ = this.baseUrl + "/Vehicle/select-vehicle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectVehicle(_response));
        });
    }

    protected processSelectVehicle(response: AxiosResponse): Promise<NameIdDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameIdDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NameIdDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameIdDto[]>(null as any);
    }

    /**
     * 车辆上下线记录
     * @param body (optional) 
     * @return Success
     */
    pageRecord(body: PageVehicleOnlineAndOfflineRecordInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Vehicle/page-record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPageRecord(_response));
        });
    }

    protected processPageRecord(response: AxiosResponse): Promise<VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto>(null as any);
    }

    /**
     * 车辆关键参数
     * @param body (optional) 
     * @return Success
     */
    listKeyParameter(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<VehicleKeyParameterOutputDto[]> {
        let url_ = this.baseUrl + "/Vehicle/list-key-parameter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processListKeyParameter(_response));
        });
    }

    protected processListKeyParameter(response: AxiosResponse): Promise<VehicleKeyParameterOutputDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleKeyParameterOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<VehicleKeyParameterOutputDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VehicleKeyParameterOutputDto[]>(null as any);
    }

    /**
     * 下拉选择设备
     * @param body (optional) 
     * @return Success
     */
    selectDevice(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/Vehicle/select-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectDevice(_response));
        });
    }

    protected processSelectDevice(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 下拉选择设备遥测
     * @param body (optional) 
     * @return Success
     */
    selectDeviceTelemetry(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/Vehicle/select-deviceTelemetry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectDeviceTelemetry(_response));
        });
    }

    protected processSelectDeviceTelemetry(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }

    /**
     * 新增或编辑关键参数
     * @param body (optional) 
     * @return Success
     */
    addEditKeyParameter(body: VehicleKeyParameterInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Vehicle/add-edit-keyParameter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAddEditKeyParameter(_response));
        });
    }

    protected processAddEditKeyParameter(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 车辆关键参数分析表
     * @param body (optional) 
     * @return Success
     */
    analysisTable(body: KeyParameterAnalysisInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<KeyParamTableDataDtoPagedResultDto> {
        let url_ = this.baseUrl + "/Vehicle/analysis-table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAnalysisTable(_response));
        });
    }

    protected processAnalysisTable(response: AxiosResponse): Promise<KeyParamTableDataDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = KeyParamTableDataDtoPagedResultDto.fromJS(resultData200);
            return Promise.resolve<KeyParamTableDataDtoPagedResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<KeyParamTableDataDtoPagedResultDto>(null as any);
    }

    /**
     * 车辆关键参数分析图
     * @param body (optional) 
     * @return Success
     */
    analysisChart(body: KeyParameterAnalysisInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<KeyParamChartDataDto> {
        let url_ = this.baseUrl + "/Vehicle/analysis-chart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAnalysisChart(_response));
        });
    }

    protected processAnalysisChart(response: AxiosResponse): Promise<KeyParamChartDataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = KeyParamChartDataDto.fromJS(resultData200);
            return Promise.resolve<KeyParamChartDataDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<KeyParamChartDataDto>(null as any);
    }

    /**
     * 下拉选择车辆参数
     * @param body (optional) 
     * @return Success
     */
    selectVehicleParameter(body: IdInput | undefined , cancelToken?: CancelToken | undefined): Promise<LabelValueDto[]> {
        let url_ = this.baseUrl + "/Vehicle/select-vehicle-parameter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSelectVehicleParameter(_response));
        });
    }

    protected processSelectVehicleParameter(response: AxiosResponse): Promise<LabelValueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LabelValueDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelValueDto[]>(null as any);
    }
}

export class VisionDataServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param uploadedFile (optional) 
     * @return Success
     */
    importExcelFile1(uploadedFile: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/vision-data/import-excel-file1";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (uploadedFile === null || uploadedFile === undefined)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else
            content_.append("uploadedFile", uploadedFile.data, uploadedFile.fileName ? uploadedFile.fileName : "uploadedFile");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processImportExcelFile1(_response));
        });
    }

    protected processImportExcelFile1(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param uploadedFile (optional) 
     * @return Success
     */
    importExcelFile2(uploadedFile: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/vision-data/import-excel-file2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (uploadedFile === null || uploadedFile === undefined)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else
            content_.append("uploadedFile", uploadedFile.data, uploadedFile.fileName ? uploadedFile.fileName : "uploadedFile");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processImportExcelFile2(_response));
        });
    }

    protected processImportExcelFile2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param uploadedFile (optional) 
     * @return Success
     */
    importExcelFile3(uploadedFile: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/vision-data/import-excel-file3";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (uploadedFile === null || uploadedFile === undefined)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else
            content_.append("uploadedFile", uploadedFile.data, uploadedFile.fileName ? uploadedFile.fileName : "uploadedFile");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processImportExcelFile3(_response));
        });
    }

    protected processImportExcelFile3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param uploadedFile (optional) 
     * @return Success
     */
    importExcelFile4(uploadedFile: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/vision-data/import-excel-file4";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (uploadedFile === null || uploadedFile === undefined)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else
            content_.append("uploadedFile", uploadedFile.data, uploadedFile.fileName ? uploadedFile.fileName : "uploadedFile");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processImportExcelFile4(_response));
        });
    }

    protected processImportExcelFile4(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VisionDemoServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 地图数据demo
     * @return Success
     */
    mapData_Bak(  cancelToken?: CancelToken | undefined): Promise<MapDataDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/map-data_Bak";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMapData_Bak(_response));
        });
    }

    protected processMapData_Bak(response: AxiosResponse): Promise<MapDataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MapDataDto.fromJS(resultData200);
            return Promise.resolve<MapDataDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MapDataDto>(null as any);
    }

    /**
     * @return Success
     */
    mapData(  cancelToken?: CancelToken | undefined): Promise<MapDataDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/map-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMapData(_response));
        });
    }

    protected processMapData(response: AxiosResponse): Promise<MapDataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MapDataDto.fromJS(resultData200);
            return Promise.resolve<MapDataDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MapDataDto>(null as any);
    }

    /**
     * 根据客户返回设备状态汇总
     * @param customName (optional) 
     * @return Success
     */
    customState(customName: string | undefined , cancelToken?: CancelToken | undefined): Promise<Int32NameValue[]> {
        let url_ = this.baseUrl + "/api/app/vision-demo/custom-state?";
        if (customName === null)
            throw new Error("The parameter 'customName' cannot be null.");
        else if (customName !== undefined)
            url_ += "customName=" + encodeURIComponent("" + customName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCustomState(_response));
        });
    }

    protected processCustomState(response: AxiosResponse): Promise<Int32NameValue[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int32NameValue.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Int32NameValue[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32NameValue[]>(null as any);
    }

    /**
     * 新能源电池组运行记录
     * @return Success
     */
    batterySummary(  cancelToken?: CancelToken | undefined): Promise<TotalBatteryInfoDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/battery-summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBatterySummary(_response));
        });
    }

    protected processBatterySummary(response: AxiosResponse): Promise<TotalBatteryInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TotalBatteryInfoDto.fromJS(resultData200);
            return Promise.resolve<TotalBatteryInfoDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TotalBatteryInfoDto>(null as any);
    }

    /**
     * 获取一笔报警
     * @return Success
     */
    oneAlarm(  cancelToken?: CancelToken | undefined): Promise<AlarmDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/one-alarm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processOneAlarm(_response));
        });
    }

    protected processOneAlarm(response: AxiosResponse): Promise<AlarmDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AlarmDto.fromJS(resultData200);
            return Promise.resolve<AlarmDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AlarmDto>(null as any);
    }

    /**
     * 产品市场占比 demo
     * @return Success
     */
    marketShare(  cancelToken?: CancelToken | undefined): Promise<TotalStateDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/market-share";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMarketShare(_response));
        });
    }

    protected processMarketShare(response: AxiosResponse): Promise<TotalStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TotalStateDto.fromJS(resultData200);
            return Promise.resolve<TotalStateDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TotalStateDto>(null as any);
    }

    /**
     * @return Success
     */
    sendAlarmMessage(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/app/vision-demo/send-alarm-message";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSendAlarmMessage(_response));
        });
    }

    protected processSendAlarmMessage(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * 电压折线图
     * @return Success
     */
    voltageData(  cancelToken?: CancelToken | undefined): Promise<TotalVoltageDto[]> {
        let url_ = this.baseUrl + "/api/app/vision-demo/voltage-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processVoltageData(_response));
        });
    }

    protected processVoltageData(response: AxiosResponse): Promise<TotalVoltageDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TotalVoltageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TotalVoltageDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TotalVoltageDto[]>(null as any);
    }

    /**
     * @param customName (optional) 
     * @return Success
     */
    monthTime(customName: string | undefined , cancelToken?: CancelToken | undefined): Promise<MonthTimeDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/month-time?";
        if (customName === null)
            throw new Error("The parameter 'customName' cannot be null.");
        else if (customName !== undefined)
            url_ += "customName=" + encodeURIComponent("" + customName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMonthTime(_response));
        });
    }

    protected processMonthTime(response: AxiosResponse): Promise<MonthTimeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MonthTimeDto.fromJS(resultData200);
            return Promise.resolve<MonthTimeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MonthTimeDto>(null as any);
    }

    /**
     * @param machineCode (optional) 
     * @return Success
     */
    batteryEnergy(machineCode: string | undefined , cancelToken?: CancelToken | undefined): Promise<BatteryEnergyDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/battery-energy?";
        if (machineCode === null)
            throw new Error("The parameter 'machineCode' cannot be null.");
        else if (machineCode !== undefined)
            url_ += "machineCode=" + encodeURIComponent("" + machineCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBatteryEnergy(_response));
        });
    }

    protected processBatteryEnergy(response: AxiosResponse): Promise<BatteryEnergyDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatteryEnergyDto.fromJS(resultData200);
            return Promise.resolve<BatteryEnergyDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryEnergyDto>(null as any);
    }

    /**
     * @param machineCode (optional) 
     * @return Success
     */
    cellVoltage(machineCode: string | undefined , cancelToken?: CancelToken | undefined): Promise<TotalVoltageDto> {
        let url_ = this.baseUrl + "/api/app/vision-demo/cell-voltage?";
        if (machineCode === null)
            throw new Error("The parameter 'machineCode' cannot be null.");
        else if (machineCode !== undefined)
            url_ += "machineCode=" + encodeURIComponent("" + machineCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCellVoltage(_response));
        });
    }

    protected processCellVoltage(response: AxiosResponse): Promise<TotalVoltageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TotalVoltageDto.fromJS(resultData200);
            return Promise.resolve<TotalVoltageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TotalVoltageDto>(null as any);
    }

    /**
     * @return Success
     */
    doIt(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/vision-demo/do-it";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDoIt(_response));
        });
    }

    protected processDoIt(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    doItTemplate(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/app/vision-demo/do-it-template";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDoItTemplate(_response));
        });
    }

    protected processDoItTemplate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param password (optional) 
     * @return Success
     */
    encryptMailingSmtpPassword(password: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/app/vision-demo/encrypt-mailing-smtp-password?";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processEncryptMailingSmtpPassword(_response));
        });
    }

    protected processEncryptMailingSmtpPassword(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class WeatherServiceProxy extends ServiceProxyBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        super();
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 城市实时天气
     * @param cityAdCode (optional) 
     * @return Success
     */
    cityWeather(cityAdCode: string | undefined , cancelToken?: CancelToken | undefined): Promise<WeatherResponseDto> {
        let url_ = this.baseUrl + "/weather/city-weather?";
        if (cityAdCode === null)
            throw new Error("The parameter 'cityAdCode' cannot be null.");
        else if (cityAdCode !== undefined)
            url_ += "cityAdCode=" + encodeURIComponent("" + cityAdCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCityWeather(_response));
        });
    }

    protected processCityWeather(response: AxiosResponse): Promise<WeatherResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WeatherResponseDto.fromJS(resultData200);
            return Promise.resolve<WeatherResponseDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WeatherResponseDto>(null as any);
    }
}

export class AbpLoginResult implements IAbpLoginResult {
    result!: LoginResultType;
    readonly description!: string | undefined;

    constructor(data?: IAbpLoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            (<any>this).description = _data["description"];
        }
    }

    static fromJS(data: any): AbpLoginResult {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLoginResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["description"] = this.description;
        return data;
    }
}

export interface IAbpLoginResult {
    result: LoginResultType;
    description: string | undefined;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
    uniqueName!: string | undefined;
    name!: string | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    supportedVersions!: string[] | undefined;
    parametersOnMethod!: MethodParameterApiDescriptionModel[] | undefined;
    parameters!: ParameterApiDescriptionModel[] | undefined;
    returnValue!: ReturnValueApiDescriptionModel;
    allowAnonymous!: boolean | undefined;
    implementFrom!: string | undefined;

    constructor(data?: IActionApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"];
            this.name = _data["name"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            if (Array.isArray(_data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of _data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
            this.allowAnonymous = _data["allowAnonymous"];
            this.implementFrom = _data["implementFrom"];
        }
    }

    static fromJS(data: any): ActionApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName;
        data["name"] = this.name;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        data["allowAnonymous"] = this.allowAnonymous;
        data["implementFrom"] = this.implementFrom;
        return data;
    }
}

export interface IActionApiDescriptionModel {
    uniqueName: string | undefined;
    name: string | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    supportedVersions: string[] | undefined;
    parametersOnMethod: MethodParameterApiDescriptionModel[] | undefined;
    parameters: ParameterApiDescriptionModel[] | undefined;
    returnValue: ReturnValueApiDescriptionModel;
    allowAnonymous: boolean | undefined;
    implementFrom: string | undefined;
}

export class AddNotifyInputDto implements IAddNotifyInputDto {
    alarmRuleId!: string;
    userId!: string;
    noticeTypes!: NoticeType[] | undefined;

    constructor(data?: IAddNotifyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alarmRuleId = _data["alarmRuleId"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["noticeTypes"])) {
                this.noticeTypes = [] as any;
                for (let item of _data["noticeTypes"])
                    this.noticeTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): AddNotifyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddNotifyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alarmRuleId"] = this.alarmRuleId;
        data["userId"] = this.userId;
        if (Array.isArray(this.noticeTypes)) {
            data["noticeTypes"] = [];
            for (let item of this.noticeTypes)
                data["noticeTypes"].push(item);
        }
        return data;
    }
}

export interface IAddNotifyInputDto {
    alarmRuleId: string;
    userId: string;
    noticeTypes: NoticeType[] | undefined;
}

export class AddRoleToOrganizationUnitInput implements IAddRoleToOrganizationUnitInput {
    roleId!: string[] | undefined;
    organizationUnitId!: string;

    constructor(data?: IAddRoleToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleId"])) {
                this.roleId = [] as any;
                for (let item of _data["roleId"])
                    this.roleId!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): AddRoleToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddRoleToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleId)) {
            data["roleId"] = [];
            for (let item of this.roleId)
                data["roleId"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IAddRoleToOrganizationUnitInput {
    roleId: string[] | undefined;
    organizationUnitId: string;
}

export class AddUserToOrganizationUnitInput implements IAddUserToOrganizationUnitInput {
    userId!: string[] | undefined;
    organizationUnitId!: string;

    constructor(data?: IAddUserToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userId"])) {
                this.userId = [] as any;
                for (let item of _data["userId"])
                    this.userId!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): AddUserToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userId)) {
            data["userId"] = [];
            for (let item of this.userId)
                data["userId"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IAddUserToOrganizationUnitInput {
    userId: string[] | undefined;
    organizationUnitId: string;
}

export class AggregateRouteConfig implements IAggregateRouteConfig {
    routeKey!: string | undefined;
    parameter!: string | undefined;
    jsonPath!: string | undefined;

    constructor(data?: IAggregateRouteConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeKey = _data["routeKey"];
            this.parameter = _data["parameter"];
            this.jsonPath = _data["jsonPath"];
        }
    }

    static fromJS(data: any): AggregateRouteConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AggregateRouteConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeKey"] = this.routeKey;
        data["parameter"] = this.parameter;
        data["jsonPath"] = this.jsonPath;
        return data;
    }
}

export interface IAggregateRouteConfig {
    routeKey: string | undefined;
    parameter: string | undefined;
    jsonPath: string | undefined;
}

export class AlarmDto implements IAlarmDto {
    id!: number;
    custom!: string | undefined;
    alarmText!: string | undefined;
    alarmStatus!: string | undefined;
    creationTime!: string | undefined;

    constructor(data?: IAlarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.custom = _data["custom"];
            this.alarmText = _data["alarmText"];
            this.alarmStatus = _data["alarmStatus"];
            this.creationTime = _data["creationTime"];
        }
    }

    static fromJS(data: any): AlarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["custom"] = this.custom;
        data["alarmText"] = this.alarmText;
        data["alarmStatus"] = this.alarmStatus;
        data["creationTime"] = this.creationTime;
        return data;
    }
}

export interface IAlarmDto {
    id: number;
    custom: string | undefined;
    alarmText: string | undefined;
    alarmStatus: string | undefined;
    creationTime: string | undefined;
}

export class AlarmNotifyOutputDto implements IAlarmNotifyOutputDto {
    id!: string;
    userName!: string | undefined;
    target!: string | undefined;
    noticeType!: NoticeType;
    userId!: string;

    constructor(data?: IAlarmNotifyOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.target = _data["target"];
            this.noticeType = _data["noticeType"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AlarmNotifyOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmNotifyOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["target"] = this.target;
        data["noticeType"] = this.noticeType;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IAlarmNotifyOutputDto {
    id: string;
    userName: string | undefined;
    target: string | undefined;
    noticeType: NoticeType;
    userId: string;
}

export class AlarmNotifyOutputDtoPagedResultDto implements IAlarmNotifyOutputDtoPagedResultDto {
    items!: AlarmNotifyOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAlarmNotifyOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AlarmNotifyOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AlarmNotifyOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmNotifyOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IAlarmNotifyOutputDtoPagedResultDto {
    items: AlarmNotifyOutputDto[] | undefined;
    totalCount: number;
}

export class AlarmOutputDto implements IAlarmOutputDto {
    id!: string;
    alarmContent!: string | undefined;
    startTime!: dayjs.Dayjs;
    endTime!: dayjs.Dayjs | undefined;
    duration!: number | undefined;
    durationDisplay!: string | undefined;
    alarmStatus!: AlarmStatus;
    severity!: SeverityLevel;
    originator!: string | undefined;
    deviceName!: string | undefined;
    originatorId!: string | undefined;
    deviceId!: string;

    constructor(data?: IAlarmOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.alarmContent = _data["alarmContent"];
            this.startTime = _data["startTime"] ? dayjs(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? dayjs(_data["endTime"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.durationDisplay = _data["durationDisplay"];
            this.alarmStatus = _data["alarmStatus"];
            this.severity = _data["severity"];
            this.originator = _data["originator"];
            this.deviceName = _data["deviceName"];
            this.originatorId = _data["originatorId"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): AlarmOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["alarmContent"] = this.alarmContent;
        data["startTime"] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toLocaleString() : <any>undefined;
        data["duration"] = this.duration;
        data["durationDisplay"] = this.durationDisplay;
        data["alarmStatus"] = this.alarmStatus;
        data["severity"] = this.severity;
        data["originator"] = this.originator;
        data["deviceName"] = this.deviceName;
        data["originatorId"] = this.originatorId;
        data["deviceId"] = this.deviceId;
        return data;
    }
}

export interface IAlarmOutputDto {
    id: string;
    alarmContent: string | undefined;
    startTime: dayjs.Dayjs;
    endTime: dayjs.Dayjs | undefined;
    duration: number | undefined;
    durationDisplay: string | undefined;
    alarmStatus: AlarmStatus;
    severity: SeverityLevel;
    originator: string | undefined;
    deviceName: string | undefined;
    originatorId: string | undefined;
    deviceId: string;
}

export class AlarmOutputDtoPagedResultDto implements IAlarmOutputDtoPagedResultDto {
    items!: AlarmOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAlarmOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AlarmOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AlarmOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IAlarmOutputDtoPagedResultDto {
    items: AlarmOutputDto[] | undefined;
    totalCount: number;
}

export class AlarmRuleInputDto implements IAlarmRuleInputDto {
    id!: string;
    deviceId!: string;
    deviceName!: string | undefined;
    telemetryId!: string;
    telemetry!: string | undefined;
    displayText!: string | undefined;
    jsonContent!: string | undefined;

    constructor(data?: IAlarmRuleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.telemetryId = _data["telemetryId"];
            this.telemetry = _data["telemetry"];
            this.displayText = _data["displayText"];
            this.jsonContent = _data["jsonContent"];
        }
    }

    static fromJS(data: any): AlarmRuleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmRuleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["telemetryId"] = this.telemetryId;
        data["telemetry"] = this.telemetry;
        data["displayText"] = this.displayText;
        data["jsonContent"] = this.jsonContent;
        return data;
    }
}

export interface IAlarmRuleInputDto {
    id: string;
    deviceId: string;
    deviceName: string | undefined;
    telemetryId: string;
    telemetry: string | undefined;
    displayText: string | undefined;
    jsonContent: string | undefined;
}

export class AlarmRuleOutputDto implements IAlarmRuleOutputDto {
    id!: string;
    deviceId!: string;
    deviceName!: string | undefined;
    telemetryId!: string;
    telemetry!: string | undefined;
    description!: string | undefined;
    displayText!: string | undefined;
    jsonContent!: string | undefined;

    constructor(data?: IAlarmRuleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.telemetryId = _data["telemetryId"];
            this.telemetry = _data["telemetry"];
            this.description = _data["description"];
            this.displayText = _data["displayText"];
            this.jsonContent = _data["jsonContent"];
        }
    }

    static fromJS(data: any): AlarmRuleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmRuleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["telemetryId"] = this.telemetryId;
        data["telemetry"] = this.telemetry;
        data["description"] = this.description;
        data["displayText"] = this.displayText;
        data["jsonContent"] = this.jsonContent;
        return data;
    }
}

export interface IAlarmRuleOutputDto {
    id: string;
    deviceId: string;
    deviceName: string | undefined;
    telemetryId: string;
    telemetry: string | undefined;
    description: string | undefined;
    displayText: string | undefined;
    jsonContent: string | undefined;
}

export class AlarmRuleOutputDtoPagedResultDto implements IAlarmRuleOutputDtoPagedResultDto {
    items!: AlarmRuleOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAlarmRuleOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AlarmRuleOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AlarmRuleOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmRuleOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IAlarmRuleOutputDtoPagedResultDto {
    items: AlarmRuleOutputDto[] | undefined;
    totalCount: number;
}

export enum AlarmStatus {
    Active = "Active",
    Clear = "Clear",
    End = "End",
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
    modules!: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types!: { [key: string]: TypeApiDescriptionModel; } | undefined;

    constructor(data?: IApplicationApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleApiDescriptionModel.fromJS(_data["modules"][key]) : new ModuleApiDescriptionModel();
                }
            }
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeApiDescriptionModel.fromJS(_data["types"][key]) : new TypeApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationApiDescriptionModel {
    modules: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types: { [key: string]: TypeApiDescriptionModel; } | undefined;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
    grantedPolicies!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationAuthConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in _data["grantedPolicies"]) {
                    if (_data["grantedPolicies"].hasOwnProperty(key))
                        (<any>this.grantedPolicies)![key] = _data["grantedPolicies"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationAuthConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAuthConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    (<any>data["grantedPolicies"])[key] = (<any>this.grantedPolicies)[key];
            }
        }
        return data;
    }
}

export interface IApplicationAuthConfigurationDto {
    grantedPolicies: { [key: string]: boolean; } | undefined;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
    localization!: ApplicationLocalizationConfigurationDto;
    auth!: ApplicationAuthConfigurationDto;
    setting!: ApplicationSettingConfigurationDto;
    currentUser!: CurrentUserDto;
    features!: ApplicationFeatureConfigurationDto;
    globalFeatures!: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy!: MultiTenancyInfoDto;
    currentTenant!: CurrentTenantDto;
    timing!: TimingDto;
    clock!: ClockDto;
    objectExtensions!: ObjectExtensionsDto;
    extraProperties!: { [key: string]: any; } | undefined;

    constructor(data?: IApplicationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(_data["localization"]) : <any>undefined;
            this.auth = _data["auth"] ? ApplicationAuthConfigurationDto.fromJS(_data["auth"]) : <any>undefined;
            this.setting = _data["setting"] ? ApplicationSettingConfigurationDto.fromJS(_data["setting"]) : <any>undefined;
            this.currentUser = _data["currentUser"] ? CurrentUserDto.fromJS(_data["currentUser"]) : <any>undefined;
            this.features = _data["features"] ? ApplicationFeatureConfigurationDto.fromJS(_data["features"]) : <any>undefined;
            this.globalFeatures = _data["globalFeatures"] ? ApplicationGlobalFeatureConfigurationDto.fromJS(_data["globalFeatures"]) : <any>undefined;
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyInfoDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.currentTenant = _data["currentTenant"] ? CurrentTenantDto.fromJS(_data["currentTenant"]) : <any>undefined;
            this.timing = _data["timing"] ? TimingDto.fromJS(_data["timing"]) : <any>undefined;
            this.clock = _data["clock"] ? ClockDto.fromJS(_data["clock"]) : <any>undefined;
            this.objectExtensions = _data["objectExtensions"] ? ObjectExtensionsDto.fromJS(_data["objectExtensions"]) : <any>undefined;
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["globalFeatures"] = this.globalFeatures ? this.globalFeatures.toJSON() : <any>undefined;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["currentTenant"] = this.currentTenant ? this.currentTenant.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["objectExtensions"] = this.objectExtensions ? this.objectExtensions.toJSON() : <any>undefined;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IApplicationConfigurationDto {
    localization: ApplicationLocalizationConfigurationDto;
    auth: ApplicationAuthConfigurationDto;
    setting: ApplicationSettingConfigurationDto;
    currentUser: CurrentUserDto;
    features: ApplicationFeatureConfigurationDto;
    globalFeatures: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy: MultiTenancyInfoDto;
    currentTenant: CurrentTenantDto;
    timing: TimingDto;
    clock: ClockDto;
    objectExtensions: ObjectExtensionsDto;
    extraProperties: { [key: string]: any; } | undefined;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationFeatureConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class ApplicationGlobalFeatureConfigurationDto implements IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures!: string[] | undefined;

    constructor(data?: IApplicationGlobalFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledFeatures"])) {
                this.enabledFeatures = [] as any;
                for (let item of _data["enabledFeatures"])
                    this.enabledFeatures!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationGlobalFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationGlobalFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledFeatures)) {
            data["enabledFeatures"] = [];
            for (let item of this.enabledFeatures)
                data["enabledFeatures"].push(item);
        }
        return data;
    }
}

export interface IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures: string[] | undefined;
}

export class ApplicationLocalizationConfigurationDto implements IApplicationLocalizationConfigurationDto {
    values!: { [key: string]: { [key: string]: string; }; } | undefined;
    resources!: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
    languages!: LanguageInfo[] | undefined;
    currentCulture!: CurrentCultureDto;
    defaultResourceName!: string | undefined;
    languagesMap!: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap!: { [key: string]: NameValue[]; } | undefined;

    constructor(data?: IApplicationLocalizationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] !== undefined ? _data["values"][key] : {};
                }
            }
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            this.currentCulture = _data["currentCulture"] ? CurrentCultureDto.fromJS(_data["currentCulture"]) : <any>undefined;
            this.defaultResourceName = _data["defaultResourceName"];
            if (_data["languagesMap"]) {
                this.languagesMap = {} as any;
                for (let key in _data["languagesMap"]) {
                    if (_data["languagesMap"].hasOwnProperty(key))
                        (<any>this.languagesMap)![key] = _data["languagesMap"][key] ? _data["languagesMap"][key].map((i: any) => NameValue.fromJS(i)) : [];
                }
            }
            if (_data["languageFilesMap"]) {
                this.languageFilesMap = {} as any;
                for (let key in _data["languageFilesMap"]) {
                    if (_data["languageFilesMap"].hasOwnProperty(key))
                        (<any>this.languageFilesMap)![key] = _data["languageFilesMap"][key] ? _data["languageFilesMap"][key].map((i: any) => NameValue.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        data["defaultResourceName"] = this.defaultResourceName;
        if (this.languagesMap) {
            data["languagesMap"] = {};
            for (let key in this.languagesMap) {
                if (this.languagesMap.hasOwnProperty(key))
                    (<any>data["languagesMap"])[key] = (<any>this.languagesMap)[key];
            }
        }
        if (this.languageFilesMap) {
            data["languageFilesMap"] = {};
            for (let key in this.languageFilesMap) {
                if (this.languageFilesMap.hasOwnProperty(key))
                    (<any>data["languageFilesMap"])[key] = (<any>this.languageFilesMap)[key];
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationConfigurationDto {
    values: { [key: string]: { [key: string]: string; }; } | undefined;
    resources: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
    languages: LanguageInfo[] | undefined;
    currentCulture: CurrentCultureDto;
    defaultResourceName: string | undefined;
    languagesMap: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap: { [key: string]: NameValue[]; } | undefined;
}

export class ApplicationLocalizationDto implements IApplicationLocalizationDto {
    resources!: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;

    constructor(data?: IApplicationLocalizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationDto {
    resources: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
}

export class ApplicationLocalizationResourceDto implements IApplicationLocalizationResourceDto {
    texts!: { [key: string]: string; } | undefined;
    baseResources!: string[] | undefined;

    constructor(data?: IApplicationLocalizationResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["texts"]) {
                this.texts = {} as any;
                for (let key in _data["texts"]) {
                    if (_data["texts"].hasOwnProperty(key))
                        (<any>this.texts)![key] = _data["texts"][key];
                }
            }
            if (Array.isArray(_data["baseResources"])) {
                this.baseResources = [] as any;
                for (let item of _data["baseResources"])
                    this.baseResources!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.texts) {
            data["texts"] = {};
            for (let key in this.texts) {
                if (this.texts.hasOwnProperty(key))
                    (<any>data["texts"])[key] = (<any>this.texts)[key];
            }
        }
        if (Array.isArray(this.baseResources)) {
            data["baseResources"] = [];
            for (let item of this.baseResources)
                data["baseResources"].push(item);
        }
        return data;
    }
}

export interface IApplicationLocalizationResourceDto {
    texts: { [key: string]: string; } | undefined;
    baseResources: string[] | undefined;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationSettingConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationSettingConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationSettingConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class AttributeOutputDto implements IAttributeOutputDto {
    id!: string;
    keyName!: string | undefined;
    description!: string | undefined;
    value!: string | undefined;
    dataSide!: DataSide;
    dataType!: DataType;
    propertyType!: PropertyType;
    isShow!: boolean;
    isCurve!: boolean;

    constructor(data?: IAttributeOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyName = _data["keyName"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.dataSide = _data["dataSide"];
            this.dataType = _data["dataType"];
            this.propertyType = _data["propertyType"];
            this.isShow = _data["isShow"];
            this.isCurve = _data["isCurve"];
        }
    }

    static fromJS(data: any): AttributeOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyName"] = this.keyName;
        data["description"] = this.description;
        data["value"] = this.value;
        data["dataSide"] = this.dataSide;
        data["dataType"] = this.dataType;
        data["propertyType"] = this.propertyType;
        data["isShow"] = this.isShow;
        data["isCurve"] = this.isCurve;
        return data;
    }
}

export interface IAttributeOutputDto {
    id: string;
    keyName: string | undefined;
    description: string | undefined;
    value: string | undefined;
    dataSide: DataSide;
    dataType: DataType;
    propertyType: PropertyType;
    isShow: boolean;
    isCurve: boolean;
}

export class AttributeOutputDtoPagedResultDto implements IAttributeOutputDtoPagedResultDto {
    items!: AttributeOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAttributeOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AttributeOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AttributeOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IAttributeOutputDtoPagedResultDto {
    items: AttributeOutputDto[] | undefined;
    totalCount: number;
}

export class BatteryEnergyDto implements IBatteryEnergyDto {
    city!: string | undefined;
    state!: string | undefined;
    value!: number;
    code!: string | undefined;

    constructor(data?: IBatteryEnergyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.city = _data["city"];
            this.state = _data["state"];
            this.value = _data["value"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): BatteryEnergyDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryEnergyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["state"] = this.state;
        data["value"] = this.value;
        data["code"] = this.code;
        return data;
    }
}

export interface IBatteryEnergyDto {
    city: string | undefined;
    state: string | undefined;
    value: number;
    code: string | undefined;
}

export class BatteryInfoDto implements IBatteryInfoDto {
    id!: number;
    name!: string | undefined;
    value!: number;
    unit!: string | undefined;

    constructor(data?: IBatteryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): BatteryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["unit"] = this.unit;
        return data;
    }
}

export interface IBatteryInfoDto {
    id: number;
    name: string | undefined;
    value: number;
    unit: string | undefined;
}

export class BatteryPackInfoDto implements IBatteryPackInfoDto {
    totalVoltage!: string | undefined;
    totalCurrent!: string | undefined;
    soc!: number;
    soh!: number;
    socStr!: string | undefined;
    sohStr!: string | undefined;
    faultCode!: string | undefined;
    singleHighVoltage!: string | undefined;
    singleHighVoltageCell!: string | undefined;
    singleLowVoltage!: string | undefined;
    singleLowVoltageCell!: string | undefined;
    singleHighTemperature!: string | undefined;
    singleHighTemperatureCell!: string | undefined;
    singleLowTemperature!: string | undefined;
    singleLowTemperatureCell!: string | undefined;
    alarmText!: string[] | undefined;

    constructor(data?: IBatteryPackInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalVoltage = _data["totalVoltage"];
            this.totalCurrent = _data["totalCurrent"];
            this.soc = _data["soc"];
            this.soh = _data["soh"];
            this.socStr = _data["socStr"];
            this.sohStr = _data["sohStr"];
            this.faultCode = _data["faultCode"];
            this.singleHighVoltage = _data["singleHighVoltage"];
            this.singleHighVoltageCell = _data["singleHighVoltageCell"];
            this.singleLowVoltage = _data["singleLowVoltage"];
            this.singleLowVoltageCell = _data["singleLowVoltageCell"];
            this.singleHighTemperature = _data["singleHighTemperature"];
            this.singleHighTemperatureCell = _data["singleHighTemperatureCell"];
            this.singleLowTemperature = _data["singleLowTemperature"];
            this.singleLowTemperatureCell = _data["singleLowTemperatureCell"];
            if (Array.isArray(_data["alarmText"])) {
                this.alarmText = [] as any;
                for (let item of _data["alarmText"])
                    this.alarmText!.push(item);
            }
        }
    }

    static fromJS(data: any): BatteryPackInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryPackInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalVoltage"] = this.totalVoltage;
        data["totalCurrent"] = this.totalCurrent;
        data["soc"] = this.soc;
        data["soh"] = this.soh;
        data["socStr"] = this.socStr;
        data["sohStr"] = this.sohStr;
        data["faultCode"] = this.faultCode;
        data["singleHighVoltage"] = this.singleHighVoltage;
        data["singleHighVoltageCell"] = this.singleHighVoltageCell;
        data["singleLowVoltage"] = this.singleLowVoltage;
        data["singleLowVoltageCell"] = this.singleLowVoltageCell;
        data["singleHighTemperature"] = this.singleHighTemperature;
        data["singleHighTemperatureCell"] = this.singleHighTemperatureCell;
        data["singleLowTemperature"] = this.singleLowTemperature;
        data["singleLowTemperatureCell"] = this.singleLowTemperatureCell;
        if (Array.isArray(this.alarmText)) {
            data["alarmText"] = [];
            for (let item of this.alarmText)
                data["alarmText"].push(item);
        }
        return data;
    }
}

export interface IBatteryPackInfoDto {
    totalVoltage: string | undefined;
    totalCurrent: string | undefined;
    soc: number;
    soh: number;
    socStr: string | undefined;
    sohStr: string | undefined;
    faultCode: string | undefined;
    singleHighVoltage: string | undefined;
    singleHighVoltageCell: string | undefined;
    singleLowVoltage: string | undefined;
    singleLowVoltageCell: string | undefined;
    singleHighTemperature: string | undefined;
    singleHighTemperatureCell: string | undefined;
    singleLowTemperature: string | undefined;
    singleLowTemperatureCell: string | undefined;
    alarmText: string[] | undefined;
}

export class BatteryProtocolDetailOutputDto implements IBatteryProtocolDetailOutputDto {
    id!: string;
    signalName!: string | undefined;
    startBit!: number;
    length!: number;
    factor!: number;
    offset!: number;
    initialValue!: string | undefined;
    unit!: string | undefined;
    min!: number;
    max!: number;
    comment!: string | undefined;
    enable!: boolean;

    constructor(data?: IBatteryProtocolDetailOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.signalName = _data["signalName"];
            this.startBit = _data["startBit"];
            this.length = _data["length"];
            this.factor = _data["factor"];
            this.offset = _data["offset"];
            this.initialValue = _data["initialValue"];
            this.unit = _data["unit"];
            this.min = _data["min"];
            this.max = _data["max"];
            this.comment = _data["comment"];
            this.enable = _data["enable"];
        }
    }

    static fromJS(data: any): BatteryProtocolDetailOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryProtocolDetailOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["signalName"] = this.signalName;
        data["startBit"] = this.startBit;
        data["length"] = this.length;
        data["factor"] = this.factor;
        data["offset"] = this.offset;
        data["initialValue"] = this.initialValue;
        data["unit"] = this.unit;
        data["min"] = this.min;
        data["max"] = this.max;
        data["comment"] = this.comment;
        data["enable"] = this.enable;
        return data;
    }
}

export interface IBatteryProtocolDetailOutputDto {
    id: string;
    signalName: string | undefined;
    startBit: number;
    length: number;
    factor: number;
    offset: number;
    initialValue: string | undefined;
    unit: string | undefined;
    min: number;
    max: number;
    comment: string | undefined;
    enable: boolean;
}

export class BatteryProtocolDetailOutputDtoPagedResultDto implements IBatteryProtocolDetailOutputDtoPagedResultDto {
    items!: BatteryProtocolDetailOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBatteryProtocolDetailOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BatteryProtocolDetailOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BatteryProtocolDetailOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryProtocolDetailOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IBatteryProtocolDetailOutputDtoPagedResultDto {
    items: BatteryProtocolDetailOutputDto[] | undefined;
    totalCount: number;
}

export class BatteryProtocolDto implements IBatteryProtocolDto {
    protocolId!: string;
    code!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IBatteryProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.protocolId = _data["protocolId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BatteryProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["protocolId"] = this.protocolId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBatteryProtocolDto {
    protocolId: string;
    code: string | undefined;
    displayName: string | undefined;
}

export class BatteryProtocolHeadOutputDto implements IBatteryProtocolHeadOutputDto {
    id!: string;
    msgId!: string | undefined;
    msgName!: string | undefined;
    enable!: boolean;

    constructor(data?: IBatteryProtocolHeadOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.msgId = _data["msgId"];
            this.msgName = _data["msgName"];
            this.enable = _data["enable"];
        }
    }

    static fromJS(data: any): BatteryProtocolHeadOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryProtocolHeadOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["msgId"] = this.msgId;
        data["msgName"] = this.msgName;
        data["enable"] = this.enable;
        return data;
    }
}

export interface IBatteryProtocolHeadOutputDto {
    id: string;
    msgId: string | undefined;
    msgName: string | undefined;
    enable: boolean;
}

export class BatteryProtocolHeadOutputDtoPagedResultDto implements IBatteryProtocolHeadOutputDtoPagedResultDto {
    items!: BatteryProtocolHeadOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBatteryProtocolHeadOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BatteryProtocolHeadOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BatteryProtocolHeadOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryProtocolHeadOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IBatteryProtocolHeadOutputDtoPagedResultDto {
    items: BatteryProtocolHeadOutputDto[] | undefined;
    totalCount: number;
}

export class BuildDeviceDto implements IBuildDeviceDto {
    id!: string;
    deviceName!: string | undefined;
    deviceType!: DeviceType;
    identityType!: IdentityType;
    timeout!: number;

    constructor(data?: IBuildDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceName = _data["deviceName"];
            this.deviceType = _data["deviceType"];
            this.identityType = _data["identityType"];
            this.timeout = _data["timeout"];
        }
    }

    static fromJS(data: any): BuildDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceName"] = this.deviceName;
        data["deviceType"] = this.deviceType;
        data["identityType"] = this.identityType;
        data["timeout"] = this.timeout;
        return data;
    }
}

export interface IBuildDeviceDto {
    id: string;
    deviceName: string | undefined;
    deviceType: DeviceType;
    identityType: IdentityType;
    timeout: number;
}

export class BuildTenantAdminInputDto implements IBuildTenantAdminInputDto {
    tenantName!: string | undefined;
    adminEmailAddress!: string | undefined;
    adminPassword!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IBuildTenantAdminInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): BuildTenantAdminInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildTenantAdminInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IBuildTenantAdminInputDto {
    tenantName: string | undefined;
    adminEmailAddress: string | undefined;
    adminPassword: string | undefined;
    phoneNumber: string | undefined;
}

export class CellChartDto implements ICellChartDto {
    xAxisData!: any[] | undefined;
    seriesData!: any[] | undefined;
    maxValue!: number;
    minValue!: number;

    constructor(data?: ICellChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["xAxisData"])) {
                this.xAxisData = [] as any;
                for (let item of _data["xAxisData"])
                    this.xAxisData!.push(item);
            }
            if (Array.isArray(_data["seriesData"])) {
                this.seriesData = [] as any;
                for (let item of _data["seriesData"])
                    this.seriesData!.push(item);
            }
            this.maxValue = _data["maxValue"];
            this.minValue = _data["minValue"];
        }
    }

    static fromJS(data: any): CellChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CellChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.xAxisData)) {
            data["xAxisData"] = [];
            for (let item of this.xAxisData)
                data["xAxisData"].push(item);
        }
        if (Array.isArray(this.seriesData)) {
            data["seriesData"] = [];
            for (let item of this.seriesData)
                data["seriesData"].push(item);
        }
        data["maxValue"] = this.maxValue;
        data["minValue"] = this.minValue;
        return data;
    }
}

export interface ICellChartDto {
    xAxisData: any[] | undefined;
    seriesData: any[] | undefined;
    maxValue: number;
    minValue: number;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string | undefined;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string | undefined;
    newPassword: string;
}

export class CheckDeviceInputDto implements ICheckDeviceInputDto {
    deviceId!: string;

    constructor(data?: ICheckDeviceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): CheckDeviceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDeviceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        return data;
    }
}

export interface ICheckDeviceInputDto {
    deviceId: string;
}

export class ChinaDataDto implements IChinaDataDto {
    provinceData!: any[] | undefined;
    cityData!: { [key: string]: any[]; } | undefined;

    constructor(data?: IChinaDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["provinceData"])) {
                this.provinceData = [] as any;
                for (let item of _data["provinceData"])
                    this.provinceData!.push(item);
            }
            if (_data["cityData"]) {
                this.cityData = {} as any;
                for (let key in _data["cityData"]) {
                    if (_data["cityData"].hasOwnProperty(key))
                        (<any>this.cityData)![key] = _data["cityData"][key];
                }
            }
        }
    }

    static fromJS(data: any): ChinaDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChinaDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.provinceData)) {
            data["provinceData"] = [];
            for (let item of this.provinceData)
                data["provinceData"].push(item);
        }
        if (this.cityData) {
            data["cityData"] = {};
            for (let key in this.cityData) {
                if (this.cityData.hasOwnProperty(key))
                    (<any>data["cityData"])[key] = (<any>this.cityData)[key];
            }
        }
        return data;
    }
}

export interface IChinaDataDto {
    provinceData: any[] | undefined;
    cityData: { [key: string]: any[]; } | undefined;
}

export class ClearAlarmInputDto implements IClearAlarmInputDto {
    deviceId!: string;
    alarmId!: string;
    deviceName!: string | undefined;
    telemetryName!: string | undefined;
    userId!: string | undefined;

    constructor(data?: IClearAlarmInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.alarmId = _data["alarmId"];
            this.deviceName = _data["deviceName"];
            this.telemetryName = _data["telemetryName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ClearAlarmInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClearAlarmInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["alarmId"] = this.alarmId;
        data["deviceName"] = this.deviceName;
        data["telemetryName"] = this.telemetryName;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IClearAlarmInputDto {
    deviceId: string;
    alarmId: string;
    deviceName: string | undefined;
    telemetryName: string | undefined;
    userId: string | undefined;
}

export class ClockDto implements IClockDto {
    kind!: string | undefined;

    constructor(data?: IClockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
        }
    }

    static fromJS(data: any): ClockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        return data;
    }
}

export interface IClockDto {
    kind: string | undefined;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
    controllerName!: string | undefined;
    controllerGroupName!: string | undefined;
    isRemoteService!: boolean;
    isIntegrationService!: boolean;
    apiVersion!: string | undefined;
    type!: string | undefined;
    interfaces!: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions!: { [key: string]: ActionApiDescriptionModel; } | undefined;

    constructor(data?: IControllerApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllerName = _data["controllerName"];
            this.controllerGroupName = _data["controllerGroupName"];
            this.isRemoteService = _data["isRemoteService"];
            this.isIntegrationService = _data["isIntegrationService"];
            this.apiVersion = _data["apiVersion"];
            this.type = _data["type"];
            if (Array.isArray(_data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of _data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
            }
            if (_data["actions"]) {
                this.actions = {} as any;
                for (let key in _data["actions"]) {
                    if (_data["actions"].hasOwnProperty(key))
                        (<any>this.actions)![key] = _data["actions"][key] ? ActionApiDescriptionModel.fromJS(_data["actions"][key]) : new ActionApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ControllerApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName;
        data["controllerGroupName"] = this.controllerGroupName;
        data["isRemoteService"] = this.isRemoteService;
        data["isIntegrationService"] = this.isIntegrationService;
        data["apiVersion"] = this.apiVersion;
        data["type"] = this.type;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    (<any>data["actions"])[key] = this.actions[key] ? this.actions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IControllerApiDescriptionModel {
    controllerName: string | undefined;
    controllerGroupName: string | undefined;
    isRemoteService: boolean;
    isIntegrationService: boolean;
    apiVersion: string | undefined;
    type: string | undefined;
    interfaces: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions: { [key: string]: ActionApiDescriptionModel; } | undefined;
}

export class ControllerInterfaceApiDescriptionModel implements IControllerInterfaceApiDescriptionModel {
    type!: string | undefined;
    name!: string | undefined;
    methods!: InterfaceMethodApiDescriptionModel[] | undefined;

    constructor(data?: IControllerInterfaceApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            if (Array.isArray(_data["methods"])) {
                this.methods = [] as any;
                for (let item of _data["methods"])
                    this.methods!.push(InterfaceMethodApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerInterfaceApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        if (Array.isArray(this.methods)) {
            data["methods"] = [];
            for (let item of this.methods)
                data["methods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IControllerInterfaceApiDescriptionModel {
    type: string | undefined;
    name: string | undefined;
    methods: InterfaceMethodApiDescriptionModel[] | undefined;
}

export class CreateDataDictinaryDetailInput implements ICreateDataDictinaryDetailInput {
    id!: string;
    code!: string | undefined;
    displayText!: string | undefined;
    description!: string | undefined;
    order!: number;

    constructor(data?: ICreateDataDictinaryDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.displayText = _data["displayText"];
            this.description = _data["description"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CreateDataDictinaryDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDataDictinaryDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayText"] = this.displayText;
        data["description"] = this.description;
        data["order"] = this.order;
        return data;
    }
}

export interface ICreateDataDictinaryDetailInput {
    id: string;
    code: string | undefined;
    displayText: string | undefined;
    description: string | undefined;
    order: number;
}

export class CreateDataDictinaryInput implements ICreateDataDictinaryInput {
    code!: string | undefined;
    displayText!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICreateDataDictinaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.displayText = _data["displayText"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateDataDictinaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDataDictinaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["displayText"] = this.displayText;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateDataDictinaryInput {
    code: string | undefined;
    displayText: string | undefined;
    description: string | undefined;
}

export class CreateLanguageInput implements ICreateLanguageInput {
    cultureName!: string | undefined;
    uiCultureName!: string | undefined;
    displayName!: string | undefined;
    flagIcon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: ICreateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): CreateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface ICreateLanguageInput {
    cultureName: string | undefined;
    uiCultureName: string | undefined;
    displayName: string | undefined;
    flagIcon: string | undefined;
    isEnabled: boolean;
}

export class CreateLanguageTextInput implements ICreateLanguageTextInput {
    resourceName!: string | undefined;
    cultureName!: string | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: ICreateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceName = _data["resourceName"];
            this.cultureName = _data["cultureName"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceName"] = this.resourceName;
        data["cultureName"] = this.cultureName;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateLanguageTextInput {
    resourceName: string | undefined;
    cultureName: string | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    displayName!: string | undefined;
    parentId!: string | undefined;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface ICreateOrganizationUnitInput {
    displayName: string | undefined;
    parentId: string | undefined;
}

export class CurrentCultureDto implements ICurrentCultureDto {
    displayName!: string | undefined;
    englishName!: string | undefined;
    threeLetterIsoLanguageName!: string | undefined;
    twoLetterIsoLanguageName!: string | undefined;
    isRightToLeft!: boolean;
    cultureName!: string | undefined;
    name!: string | undefined;
    nativeName!: string | undefined;
    dateTimeFormat!: DateTimeFormatDto;

    constructor(data?: ICurrentCultureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.englishName = _data["englishName"];
            this.threeLetterIsoLanguageName = _data["threeLetterIsoLanguageName"];
            this.twoLetterIsoLanguageName = _data["twoLetterIsoLanguageName"];
            this.isRightToLeft = _data["isRightToLeft"];
            this.cultureName = _data["cultureName"];
            this.name = _data["name"];
            this.nativeName = _data["nativeName"];
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatDto.fromJS(_data["dateTimeFormat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CurrentCultureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCultureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["englishName"] = this.englishName;
        data["threeLetterIsoLanguageName"] = this.threeLetterIsoLanguageName;
        data["twoLetterIsoLanguageName"] = this.twoLetterIsoLanguageName;
        data["isRightToLeft"] = this.isRightToLeft;
        data["cultureName"] = this.cultureName;
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICurrentCultureDto {
    displayName: string | undefined;
    englishName: string | undefined;
    threeLetterIsoLanguageName: string | undefined;
    twoLetterIsoLanguageName: string | undefined;
    isRightToLeft: boolean;
    cultureName: string | undefined;
    name: string | undefined;
    nativeName: string | undefined;
    dateTimeFormat: DateTimeFormatDto;
}

export class CurrentTenantDto implements ICurrentTenantDto {
    id!: string | undefined;
    name!: string | undefined;
    isAvailable!: boolean;

    constructor(data?: ICurrentTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): CurrentTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface ICurrentTenantDto {
    id: string | undefined;
    name: string | undefined;
    isAvailable: boolean;
}

export class CurrentUserDto implements ICurrentUserDto {
    isAuthenticated!: boolean;
    id!: string | undefined;
    tenantId!: string | undefined;
    impersonatorUserId!: string | undefined;
    impersonatorTenantId!: string | undefined;
    impersonatorUserName!: string | undefined;
    impersonatorTenantName!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surName!: string | undefined;
    email!: string | undefined;
    emailVerified!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberVerified!: boolean;
    roles!: string[] | undefined;

    constructor(data?: ICurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAuthenticated = _data["isAuthenticated"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserName = _data["impersonatorUserName"];
            this.impersonatorTenantName = _data["impersonatorTenantName"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surName = _data["surName"];
            this.email = _data["email"];
            this.emailVerified = _data["emailVerified"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberVerified = _data["phoneNumberVerified"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserName"] = this.impersonatorUserName;
        data["impersonatorTenantName"] = this.impersonatorTenantName;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surName"] = this.surName;
        data["email"] = this.email;
        data["emailVerified"] = this.emailVerified;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberVerified"] = this.phoneNumberVerified;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICurrentUserDto {
    isAuthenticated: boolean;
    id: string | undefined;
    tenantId: string | undefined;
    impersonatorUserId: string | undefined;
    impersonatorTenantId: string | undefined;
    impersonatorUserName: string | undefined;
    impersonatorTenantName: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surName: string | undefined;
    email: string | undefined;
    emailVerified: boolean;
    phoneNumber: string | undefined;
    phoneNumberVerified: boolean;
    roles: string[] | undefined;
}

export class CustomerAddUserDto implements ICustomerAddUserDto {
    id!: string;
    userIds!: string[] | undefined;

    constructor(data?: ICustomerAddUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerAddUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface ICustomerAddUserDto {
    id: string;
    userIds: string[] | undefined;
}

export class CustomerAddVehicleDto implements ICustomerAddVehicleDto {
    id!: string;
    vehicleIds!: string[] | undefined;

    constructor(data?: ICustomerAddVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["vehicleIds"])) {
                this.vehicleIds = [] as any;
                for (let item of _data["vehicleIds"])
                    this.vehicleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerAddVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.vehicleIds)) {
            data["vehicleIds"] = [];
            for (let item of this.vehicleIds)
                data["vehicleIds"].push(item);
        }
        return data;
    }
}

export interface ICustomerAddVehicleDto {
    id: string;
    vehicleIds: string[] | undefined;
}

export class CustomerInputDto implements ICustomerInputDto {
    id!: string;
    name!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    detailAddress!: string | undefined;
    longitude!: number;
    latitude!: number;
    adCode!: string | undefined;

    constructor(data?: ICustomerInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.detailAddress = _data["detailAddress"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.adCode = _data["adCode"];
        }
    }

    static fromJS(data: any): CustomerInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["province"] = this.province;
        data["city"] = this.city;
        data["detailAddress"] = this.detailAddress;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["adCode"] = this.adCode;
        return data;
    }
}

export interface ICustomerInputDto {
    id: string;
    name: string | undefined;
    province: string | undefined;
    city: string | undefined;
    detailAddress: string | undefined;
    longitude: number;
    latitude: number;
    adCode: string | undefined;
}

export class CustomerOutputDto implements ICustomerOutputDto {
    id!: string;
    name!: string | undefined;
    detailAddress!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    tenantId!: string | undefined;
    readonly tenant!: boolean;
    longitude!: number;
    latitude!: number;
    adCode!: string | undefined;

    constructor(data?: ICustomerOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.detailAddress = _data["detailAddress"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.tenantId = _data["tenantId"];
            (<any>this).tenant = _data["tenant"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.adCode = _data["adCode"];
        }
    }

    static fromJS(data: any): CustomerOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["detailAddress"] = this.detailAddress;
        data["province"] = this.province;
        data["city"] = this.city;
        data["tenantId"] = this.tenantId;
        data["tenant"] = this.tenant;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["adCode"] = this.adCode;
        return data;
    }
}

export interface ICustomerOutputDto {
    id: string;
    name: string | undefined;
    detailAddress: string | undefined;
    province: string | undefined;
    city: string | undefined;
    tenantId: string | undefined;
    tenant: boolean;
    longitude: number;
    latitude: number;
    adCode: string | undefined;
}

export class CustomerOutputDtoPagedResultDto implements ICustomerOutputDtoPagedResultDto {
    items!: CustomerOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICustomerOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ICustomerOutputDtoPagedResultDto {
    items: CustomerOutputDto[] | undefined;
    totalCount: number;
}

export class CustomerTreeDataDto implements ICustomerTreeDataDto {
    title!: string | undefined;
    key!: string | undefined;
    icon!: string | undefined;

    constructor(data?: ICustomerTreeDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.key = _data["key"];
            this.icon = _data["icon"];
        }
    }

    static fromJS(data: any): CustomerTreeDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTreeDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["key"] = this.key;
        data["icon"] = this.icon;
        return data;
    }
}

export interface ICustomerTreeDataDto {
    title: string | undefined;
    key: string | undefined;
    icon: string | undefined;
}

export class CustomerUserOutputDto implements ICustomerUserOutputDto {
    id!: string;
    userId!: string;
    userName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ICustomerUserOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomerUserOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerUserOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICustomerUserOutputDto {
    id: string;
    userId: string;
    userName: string | undefined;
    name: string | undefined;
}

export class CustomerUserOutputDtoPagedResultDto implements ICustomerUserOutputDtoPagedResultDto {
    items!: CustomerUserOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICustomerUserOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerUserOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerUserOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerUserOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ICustomerUserOutputDtoPagedResultDto {
    items: CustomerUserOutputDto[] | undefined;
    totalCount: number;
}

export class CustomerVehicleOutputDto implements ICustomerVehicleOutputDto {
    id!: string;
    vehicleId!: string;
    vehicleCode!: string | undefined;
    vehicleName!: string | undefined;

    constructor(data?: ICustomerVehicleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleId = _data["vehicleId"];
            this.vehicleCode = _data["vehicleCode"];
            this.vehicleName = _data["vehicleName"];
        }
    }

    static fromJS(data: any): CustomerVehicleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerVehicleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleId"] = this.vehicleId;
        data["vehicleCode"] = this.vehicleCode;
        data["vehicleName"] = this.vehicleName;
        return data;
    }
}

export interface ICustomerVehicleOutputDto {
    id: string;
    vehicleId: string;
    vehicleCode: string | undefined;
    vehicleName: string | undefined;
}

export class CustomerVehicleOutputDtoPagedResultDto implements ICustomerVehicleOutputDtoPagedResultDto {
    items!: CustomerVehicleOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICustomerVehicleOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerVehicleOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerVehicleOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerVehicleOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ICustomerVehicleOutputDtoPagedResultDto {
    items: CustomerVehicleOutputDto[] | undefined;
    totalCount: number;
}

export class DashboardCardDto implements IDashboardCardDto {
    totalDeviceCount!: number;
    onlineDeviceCount!: number;
    alarmDeviceCount!: number;
    totayAlarmTimes!: number;
    totalRuleCount!: number;
    enableRuleCount!: number;
    todayFlow!: number;
    monthFlow!: number;

    constructor(data?: IDashboardCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalDeviceCount = _data["totalDeviceCount"];
            this.onlineDeviceCount = _data["onlineDeviceCount"];
            this.alarmDeviceCount = _data["alarmDeviceCount"];
            this.totayAlarmTimes = _data["totayAlarmTimes"];
            this.totalRuleCount = _data["totalRuleCount"];
            this.enableRuleCount = _data["enableRuleCount"];
            this.todayFlow = _data["todayFlow"];
            this.monthFlow = _data["monthFlow"];
        }
    }

    static fromJS(data: any): DashboardCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalDeviceCount"] = this.totalDeviceCount;
        data["onlineDeviceCount"] = this.onlineDeviceCount;
        data["alarmDeviceCount"] = this.alarmDeviceCount;
        data["totayAlarmTimes"] = this.totayAlarmTimes;
        data["totalRuleCount"] = this.totalRuleCount;
        data["enableRuleCount"] = this.enableRuleCount;
        data["todayFlow"] = this.todayFlow;
        data["monthFlow"] = this.monthFlow;
        return data;
    }
}

export interface IDashboardCardDto {
    totalDeviceCount: number;
    onlineDeviceCount: number;
    alarmDeviceCount: number;
    totayAlarmTimes: number;
    totalRuleCount: number;
    enableRuleCount: number;
    todayFlow: number;
    monthFlow: number;
}

export enum DataSide {
    AnySide = "AnySide",
    EdgeSide = "EdgeSide",
    ServerSide = "ServerSide",
}

export enum DataType {
    Boolean = "Boolean",
    String = "String",
    Int = "Int",
    Long = "Long",
    Double = "Double",
}

export class DateTimeFormatDto implements IDateTimeFormatDto {
    calendarAlgorithmType!: string | undefined;
    dateTimeFormatLong!: string | undefined;
    shortDatePattern!: string | undefined;
    fullDateTimePattern!: string | undefined;
    dateSeparator!: string | undefined;
    shortTimePattern!: string | undefined;
    longTimePattern!: string | undefined;

    constructor(data?: IDateTimeFormatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calendarAlgorithmType = _data["calendarAlgorithmType"];
            this.dateTimeFormatLong = _data["dateTimeFormatLong"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.dateSeparator = _data["dateSeparator"];
            this.shortTimePattern = _data["shortTimePattern"];
            this.longTimePattern = _data["longTimePattern"];
        }
    }

    static fromJS(data: any): DateTimeFormatDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarAlgorithmType"] = this.calendarAlgorithmType;
        data["dateTimeFormatLong"] = this.dateTimeFormatLong;
        data["shortDatePattern"] = this.shortDatePattern;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["dateSeparator"] = this.dateSeparator;
        data["shortTimePattern"] = this.shortTimePattern;
        data["longTimePattern"] = this.longTimePattern;
        return data;
    }
}

export interface IDateTimeFormatDto {
    calendarAlgorithmType: string | undefined;
    dateTimeFormatLong: string | undefined;
    shortDatePattern: string | undefined;
    fullDateTimePattern: string | undefined;
    dateSeparator: string | undefined;
    shortTimePattern: string | undefined;
    longTimePattern: string | undefined;
}

export class DeleteDataDictionaryDetailInput implements IDeleteDataDictionaryDetailInput {
    dataDictionaryId!: string;
    dataDictionayDetailId!: string;

    constructor(data?: IDeleteDataDictionaryDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataDictionaryId = _data["dataDictionaryId"];
            this.dataDictionayDetailId = _data["dataDictionayDetailId"];
        }
    }

    static fromJS(data: any): DeleteDataDictionaryDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteDataDictionaryDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataDictionaryId"] = this.dataDictionaryId;
        data["dataDictionayDetailId"] = this.dataDictionayDetailId;
        return data;
    }
}

export interface IDeleteDataDictionaryDetailInput {
    dataDictionaryId: string;
    dataDictionayDetailId: string;
}

export class DeleteLanguageInput implements IDeleteLanguageInput {
    id!: string;

    constructor(data?: IDeleteLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteLanguageInput {
    id: string;
}

export class DeviceDetailInfoDto implements IDeviceDetailInfoDto {
    id!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    deviceType!: DeviceType;
    identityType!: IdentityType;
    timeout!: number;
    token!: string | undefined;
    account!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    lastConnectionTime!: string | undefined;
    isAlarm!: boolean;
    telemetryCount!: number;
    customer!: string | undefined;
    address!: string | undefined;

    constructor(data?: IDeviceDetailInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.deviceType = _data["deviceType"];
            this.identityType = _data["identityType"];
            this.timeout = _data["timeout"];
            this.token = _data["token"];
            this.account = _data["account"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.lastConnectionTime = _data["lastConnectionTime"];
            this.isAlarm = _data["isAlarm"];
            this.telemetryCount = _data["telemetryCount"];
            this.customer = _data["customer"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): DeviceDetailInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDetailInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["deviceType"] = this.deviceType;
        data["identityType"] = this.identityType;
        data["timeout"] = this.timeout;
        data["token"] = this.token;
        data["account"] = this.account;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["lastConnectionTime"] = this.lastConnectionTime;
        data["isAlarm"] = this.isAlarm;
        data["telemetryCount"] = this.telemetryCount;
        data["customer"] = this.customer;
        data["address"] = this.address;
        return data;
    }
}

export interface IDeviceDetailInfoDto {
    id: string | undefined;
    name: string | undefined;
    code: string | undefined;
    deviceType: DeviceType;
    identityType: IdentityType;
    timeout: number;
    token: string | undefined;
    account: string | undefined;
    password: string | undefined;
    isActive: boolean;
    lastConnectionTime: string | undefined;
    isAlarm: boolean;
    telemetryCount: number;
    customer: string | undefined;
    address: string | undefined;
}

export class DeviceInputDto implements IDeviceInputDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    deviceType!: DeviceType;
    identityType!: IdentityType;
    timeout!: number;

    constructor(data?: IDeviceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.deviceType = _data["deviceType"];
            this.identityType = _data["identityType"];
            this.timeout = _data["timeout"];
        }
    }

    static fromJS(data: any): DeviceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["deviceType"] = this.deviceType;
        data["identityType"] = this.identityType;
        data["timeout"] = this.timeout;
        return data;
    }
}

export interface IDeviceInputDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    deviceType: DeviceType;
    identityType: IdentityType;
    timeout: number;
}

export class DeviceOutputDto implements IDeviceOutputDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    deviceType!: DeviceType;
    deviceTypeStr!: string | undefined;
    identityType!: IdentityType;
    timeout!: number;
    creationTime!: dayjs.Dayjs;
    token!: string | undefined;
    account!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    imgUrl!: string | undefined;
    customer!: string | undefined;
    gateway!: string | undefined;
    customerId!: string | undefined;
    vehicleId!: string | undefined;
    vehicle!: string | undefined;

    constructor(data?: IDeviceOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.deviceType = _data["deviceType"];
            this.deviceTypeStr = _data["deviceTypeStr"];
            this.identityType = _data["identityType"];
            this.timeout = _data["timeout"];
            this.creationTime = _data["creationTime"] ? dayjs(_data["creationTime"].toString()) : <any>undefined;
            this.token = _data["token"];
            this.account = _data["account"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.imgUrl = _data["imgUrl"];
            this.customer = _data["customer"];
            this.gateway = _data["gateway"];
            this.customerId = _data["customerId"];
            this.vehicleId = _data["vehicleId"];
            this.vehicle = _data["vehicle"];
        }
    }

    static fromJS(data: any): DeviceOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["deviceType"] = this.deviceType;
        data["deviceTypeStr"] = this.deviceTypeStr;
        data["identityType"] = this.identityType;
        data["timeout"] = this.timeout;
        data["creationTime"] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
        data["token"] = this.token;
        data["account"] = this.account;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["imgUrl"] = this.imgUrl;
        data["customer"] = this.customer;
        data["gateway"] = this.gateway;
        data["customerId"] = this.customerId;
        data["vehicleId"] = this.vehicleId;
        data["vehicle"] = this.vehicle;
        return data;
    }
}

export interface IDeviceOutputDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    deviceType: DeviceType;
    deviceTypeStr: string | undefined;
    identityType: IdentityType;
    timeout: number;
    creationTime: dayjs.Dayjs;
    token: string | undefined;
    account: string | undefined;
    password: string | undefined;
    isActive: boolean;
    imgUrl: string | undefined;
    customer: string | undefined;
    gateway: string | undefined;
    customerId: string | undefined;
    vehicleId: string | undefined;
    vehicle: string | undefined;
}

export class DeviceOutputDtoPagedResultDto implements IDeviceOutputDtoPagedResultDto {
    items!: DeviceOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDeviceOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DeviceOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IDeviceOutputDtoPagedResultDto {
    items: DeviceOutputDto[] | undefined;
    totalCount: number;
}

export class DeviceRuleOutputDto implements IDeviceRuleOutputDto {
    id!: string;
    name!: string | undefined;
    ruleId!: string;
    ruleType!: RuleType;
    enable!: boolean;

    constructor(data?: IDeviceRuleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.ruleId = _data["ruleId"];
            this.ruleType = _data["ruleType"];
            this.enable = _data["enable"];
        }
    }

    static fromJS(data: any): DeviceRuleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRuleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["ruleId"] = this.ruleId;
        data["ruleType"] = this.ruleType;
        data["enable"] = this.enable;
        return data;
    }
}

export interface IDeviceRuleOutputDto {
    id: string;
    name: string | undefined;
    ruleId: string;
    ruleType: RuleType;
    enable: boolean;
}

export class DeviceRuleOutputDtoPagedResultDto implements IDeviceRuleOutputDtoPagedResultDto {
    items!: DeviceRuleOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDeviceRuleOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceRuleOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DeviceRuleOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRuleOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IDeviceRuleOutputDtoPagedResultDto {
    items: DeviceRuleOutputDto[] | undefined;
    totalCount: number;
}

export class DeviceTelemetryHistoryDto implements IDeviceTelemetryHistoryDto {
    deviceId!: string;
    deviceName!: string | undefined;
    telemetry!: string | undefined;
    collectionTime!: dayjs.Dayjs;
    value!: string | undefined;

    constructor(data?: IDeviceTelemetryHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.telemetry = _data["telemetry"];
            this.collectionTime = _data["collectionTime"] ? dayjs(_data["collectionTime"].toString()) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DeviceTelemetryHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTelemetryHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["telemetry"] = this.telemetry;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toLocaleString() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

export interface IDeviceTelemetryHistoryDto {
    deviceId: string;
    deviceName: string | undefined;
    telemetry: string | undefined;
    collectionTime: dayjs.Dayjs;
    value: string | undefined;
}

export class DeviceTelemetryHistoryDtoPagedResultDto implements IDeviceTelemetryHistoryDtoPagedResultDto {
    items!: DeviceTelemetryHistoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDeviceTelemetryHistoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceTelemetryHistoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DeviceTelemetryHistoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTelemetryHistoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IDeviceTelemetryHistoryDtoPagedResultDto {
    items: DeviceTelemetryHistoryDto[] | undefined;
    totalCount: number;
}

export enum DeviceType {
    Others = "Others",
    Gateway = "Gateway",
    Battery = "Battery",
    Sensor = "Sensor",
    Plc = "Plc",
    Inverter = "Inverter",
}

export class DistributeTelemetryInputDto implements IDistributeTelemetryInputDto {
    originalDeviceId!: string;
    originalDevice!: string | undefined;
    telemetryIds!: string[] | undefined;
    targetDeviceId!: string;
    targetDeviceName!: string | undefined;

    constructor(data?: IDistributeTelemetryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalDeviceId = _data["originalDeviceId"];
            this.originalDevice = _data["originalDevice"];
            if (Array.isArray(_data["telemetryIds"])) {
                this.telemetryIds = [] as any;
                for (let item of _data["telemetryIds"])
                    this.telemetryIds!.push(item);
            }
            this.targetDeviceId = _data["targetDeviceId"];
            this.targetDeviceName = _data["targetDeviceName"];
        }
    }

    static fromJS(data: any): DistributeTelemetryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistributeTelemetryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalDeviceId"] = this.originalDeviceId;
        data["originalDevice"] = this.originalDevice;
        if (Array.isArray(this.telemetryIds)) {
            data["telemetryIds"] = [];
            for (let item of this.telemetryIds)
                data["telemetryIds"].push(item);
        }
        data["targetDeviceId"] = this.targetDeviceId;
        data["targetDeviceName"] = this.targetDeviceName;
        return data;
    }
}

export interface IDistributeTelemetryInputDto {
    originalDeviceId: string;
    originalDevice: string | undefined;
    telemetryIds: string[] | undefined;
    targetDeviceId: string;
    targetDeviceName: string | undefined;
}

export class DoubleListNameValue implements IDoubleListNameValue {
    name!: string | undefined;
    value!: number[] | undefined;

    constructor(data?: IDoubleListNameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): DoubleListNameValue {
        data = typeof data === 'object' ? data : {};
        let result = new DoubleListNameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export interface IDoubleListNameValue {
    name: string | undefined;
    value: number[] | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityExtensionDto implements IEntityExtensionDto {
    properties!: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration!: { [key: string]: any; } | undefined;

    constructor(data?: IEntityExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? ExtensionPropertyDto.fromJS(_data["properties"][key]) : new ExtensionPropertyDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): EntityExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IEntityExtensionDto {
    properties: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration: { [key: string]: any; } | undefined;
}

export class ExtensionEnumDto implements IExtensionEnumDto {
    fields!: ExtensionEnumFieldDto[] | undefined;
    localizationResource!: string | undefined;

    constructor(data?: IExtensionEnumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ExtensionEnumFieldDto.fromJS(item));
            }
            this.localizationResource = _data["localizationResource"];
        }
    }

    static fromJS(data: any): ExtensionEnumDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["localizationResource"] = this.localizationResource;
        return data;
    }
}

export interface IExtensionEnumDto {
    fields: ExtensionEnumFieldDto[] | undefined;
    localizationResource: string | undefined;
}

export class ExtensionEnumFieldDto implements IExtensionEnumFieldDto {
    name!: string | undefined;
    value!: any | undefined;

    constructor(data?: IExtensionEnumFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExtensionEnumFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IExtensionEnumFieldDto {
    name: string | undefined;
    value: any | undefined;
}

export class ExtensionPropertyApiCreateDto implements IExtensionPropertyApiCreateDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiCreateDto {
    isAvailable: boolean;
}

export class ExtensionPropertyApiDto implements IExtensionPropertyApiDto {
    onGet!: ExtensionPropertyApiGetDto;
    onCreate!: ExtensionPropertyApiCreateDto;
    onUpdate!: ExtensionPropertyApiUpdateDto;

    constructor(data?: IExtensionPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onGet = _data["onGet"] ? ExtensionPropertyApiGetDto.fromJS(_data["onGet"]) : <any>undefined;
            this.onCreate = _data["onCreate"] ? ExtensionPropertyApiCreateDto.fromJS(_data["onCreate"]) : <any>undefined;
            this.onUpdate = _data["onUpdate"] ? ExtensionPropertyApiUpdateDto.fromJS(_data["onUpdate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onGet"] = this.onGet ? this.onGet.toJSON() : <any>undefined;
        data["onCreate"] = this.onCreate ? this.onCreate.toJSON() : <any>undefined;
        data["onUpdate"] = this.onUpdate ? this.onUpdate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyApiDto {
    onGet: ExtensionPropertyApiGetDto;
    onCreate: ExtensionPropertyApiCreateDto;
    onUpdate: ExtensionPropertyApiUpdateDto;
}

export class ExtensionPropertyApiGetDto implements IExtensionPropertyApiGetDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiGetDto {
    isAvailable: boolean;
}

export class ExtensionPropertyApiUpdateDto implements IExtensionPropertyApiUpdateDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiUpdateDto {
    isAvailable: boolean;
}

export class ExtensionPropertyAttributeDto implements IExtensionPropertyAttributeDto {
    typeSimple!: string | undefined;
    config!: { [key: string]: any; } | undefined;

    constructor(data?: IExtensionPropertyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeSimple = _data["typeSimple"];
            if (_data["config"]) {
                this.config = {} as any;
                for (let key in _data["config"]) {
                    if (_data["config"].hasOwnProperty(key))
                        (<any>this.config)![key] = _data["config"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExtensionPropertyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeSimple"] = this.typeSimple;
        if (this.config) {
            data["config"] = {};
            for (let key in this.config) {
                if (this.config.hasOwnProperty(key))
                    (<any>data["config"])[key] = (<any>this.config)[key];
            }
        }
        return data;
    }
}

export interface IExtensionPropertyAttributeDto {
    typeSimple: string | undefined;
    config: { [key: string]: any; } | undefined;
}

export class ExtensionPropertyDto implements IExtensionPropertyDto {
    type!: string | undefined;
    typeSimple!: string | undefined;
    displayName!: LocalizableStringDto;
    api!: ExtensionPropertyApiDto;
    ui!: ExtensionPropertyUiDto;
    attributes!: ExtensionPropertyAttributeDto[] | undefined;
    configuration!: { [key: string]: any; } | undefined;
    defaultValue!: any | undefined;

    constructor(data?: IExtensionPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.displayName = _data["displayName"] ? LocalizableStringDto.fromJS(_data["displayName"]) : <any>undefined;
            this.api = _data["api"] ? ExtensionPropertyApiDto.fromJS(_data["api"]) : <any>undefined;
            this.ui = _data["ui"] ? ExtensionPropertyUiDto.fromJS(_data["ui"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item));
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): ExtensionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["api"] = this.api ? this.api.toJSON() : <any>undefined;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IExtensionPropertyDto {
    type: string | undefined;
    typeSimple: string | undefined;
    displayName: LocalizableStringDto;
    api: ExtensionPropertyApiDto;
    ui: ExtensionPropertyUiDto;
    attributes: ExtensionPropertyAttributeDto[] | undefined;
    configuration: { [key: string]: any; } | undefined;
    defaultValue: any | undefined;
}

export class ExtensionPropertyUiDto implements IExtensionPropertyUiDto {
    onTable!: ExtensionPropertyUiTableDto;
    onCreateForm!: ExtensionPropertyUiFormDto;
    onEditForm!: ExtensionPropertyUiFormDto;
    lookup!: ExtensionPropertyUiLookupDto;

    constructor(data?: IExtensionPropertyUiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onTable = _data["onTable"] ? ExtensionPropertyUiTableDto.fromJS(_data["onTable"]) : <any>undefined;
            this.onCreateForm = _data["onCreateForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onCreateForm"]) : <any>undefined;
            this.onEditForm = _data["onEditForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onEditForm"]) : <any>undefined;
            this.lookup = _data["lookup"] ? ExtensionPropertyUiLookupDto.fromJS(_data["lookup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTable"] = this.onTable ? this.onTable.toJSON() : <any>undefined;
        data["onCreateForm"] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>undefined;
        data["onEditForm"] = this.onEditForm ? this.onEditForm.toJSON() : <any>undefined;
        data["lookup"] = this.lookup ? this.lookup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyUiDto {
    onTable: ExtensionPropertyUiTableDto;
    onCreateForm: ExtensionPropertyUiFormDto;
    onEditForm: ExtensionPropertyUiFormDto;
    lookup: ExtensionPropertyUiLookupDto;
}

export class ExtensionPropertyUiFormDto implements IExtensionPropertyUiFormDto {
    isVisible!: boolean;

    constructor(data?: IExtensionPropertyUiFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiFormDto {
    isVisible: boolean;
}

export class ExtensionPropertyUiLookupDto implements IExtensionPropertyUiLookupDto {
    url!: string | undefined;
    resultListPropertyName!: string | undefined;
    displayPropertyName!: string | undefined;
    valuePropertyName!: string | undefined;
    filterParamName!: string | undefined;

    constructor(data?: IExtensionPropertyUiLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.resultListPropertyName = _data["resultListPropertyName"];
            this.displayPropertyName = _data["displayPropertyName"];
            this.valuePropertyName = _data["valuePropertyName"];
            this.filterParamName = _data["filterParamName"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["resultListPropertyName"] = this.resultListPropertyName;
        data["displayPropertyName"] = this.displayPropertyName;
        data["valuePropertyName"] = this.valuePropertyName;
        data["filterParamName"] = this.filterParamName;
        return data;
    }
}

export interface IExtensionPropertyUiLookupDto {
    url: string | undefined;
    resultListPropertyName: string | undefined;
    displayPropertyName: string | undefined;
    valuePropertyName: string | undefined;
    filterParamName: string | undefined;
}

export class ExtensionPropertyUiTableDto implements IExtensionPropertyUiTableDto {
    isVisible!: boolean;

    constructor(data?: IExtensionPropertyUiTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiTableDto {
    isVisible: boolean;
}

export class FileAggregateRoute implements IFileAggregateRoute {
    routeKeys!: string[] | undefined;
    routeKeysConfig!: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate!: string | undefined;
    upstreamHost!: string | undefined;
    routeIsCaseSensitive!: boolean;
    aggregator!: string | undefined;
    readonly upstreamHttpMethod!: string[] | undefined;
    priority!: number;

    constructor(data?: IFileAggregateRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routeKeys"])) {
                this.routeKeys = [] as any;
                for (let item of _data["routeKeys"])
                    this.routeKeys!.push(item);
            }
            if (Array.isArray(_data["routeKeysConfig"])) {
                this.routeKeysConfig = [] as any;
                for (let item of _data["routeKeysConfig"])
                    this.routeKeysConfig!.push(AggregateRouteConfig.fromJS(item));
            }
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            this.upstreamHost = _data["upstreamHost"];
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.aggregator = _data["aggregator"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                (<any>this).upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    (<any>this).upstreamHttpMethod!.push(item);
            }
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): FileAggregateRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileAggregateRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routeKeys)) {
            data["routeKeys"] = [];
            for (let item of this.routeKeys)
                data["routeKeys"].push(item);
        }
        if (Array.isArray(this.routeKeysConfig)) {
            data["routeKeysConfig"] = [];
            for (let item of this.routeKeysConfig)
                data["routeKeysConfig"].push(item.toJSON());
        }
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        data["upstreamHost"] = this.upstreamHost;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["aggregator"] = this.aggregator;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["priority"] = this.priority;
        return data;
    }
}

export interface IFileAggregateRoute {
    routeKeys: string[] | undefined;
    routeKeysConfig: AggregateRouteConfig[] | undefined;
    upstreamPathTemplate: string | undefined;
    upstreamHost: string | undefined;
    routeIsCaseSensitive: boolean;
    aggregator: string | undefined;
    upstreamHttpMethod: string[] | undefined;
    priority: number;
}

export class FileAuthenticationOptions implements IFileAuthenticationOptions {
    authenticationProviderKey!: string | undefined;
    allowedScopes!: string[] | undefined;

    constructor(data?: IFileAuthenticationOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationProviderKey = _data["authenticationProviderKey"];
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
        }
    }

    static fromJS(data: any): FileAuthenticationOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileAuthenticationOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationProviderKey"] = this.authenticationProviderKey;
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        return data;
    }
}

export interface IFileAuthenticationOptions {
    authenticationProviderKey: string | undefined;
    allowedScopes: string[] | undefined;
}

export class FileCacheOptions implements IFileCacheOptions {
    ttlSeconds!: number;
    region!: string | undefined;

    constructor(data?: IFileCacheOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ttlSeconds = _data["ttlSeconds"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): FileCacheOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileCacheOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ttlSeconds"] = this.ttlSeconds;
        data["region"] = this.region;
        return data;
    }
}

export interface IFileCacheOptions {
    ttlSeconds: number;
    region: string | undefined;
}

export class FileConfiguration implements IFileConfiguration {
    routes!: FileRoute[] | undefined;
    dynamicRoutes!: FileDynamicRoute[] | undefined;
    aggregates!: FileAggregateRoute[] | undefined;
    globalConfiguration!: FileGlobalConfiguration;

    constructor(data?: IFileConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["routes"])) {
                this.routes = [] as any;
                for (let item of _data["routes"])
                    this.routes!.push(FileRoute.fromJS(item));
            }
            if (Array.isArray(_data["dynamicRoutes"])) {
                this.dynamicRoutes = [] as any;
                for (let item of _data["dynamicRoutes"])
                    this.dynamicRoutes!.push(FileDynamicRoute.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates!.push(FileAggregateRoute.fromJS(item));
            }
            this.globalConfiguration = _data["globalConfiguration"] ? FileGlobalConfiguration.fromJS(_data["globalConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.routes)) {
            data["routes"] = [];
            for (let item of this.routes)
                data["routes"].push(item.toJSON());
        }
        if (Array.isArray(this.dynamicRoutes)) {
            data["dynamicRoutes"] = [];
            for (let item of this.dynamicRoutes)
                data["dynamicRoutes"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["globalConfiguration"] = this.globalConfiguration ? this.globalConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileConfiguration {
    routes: FileRoute[] | undefined;
    dynamicRoutes: FileDynamicRoute[] | undefined;
    aggregates: FileAggregateRoute[] | undefined;
    globalConfiguration: FileGlobalConfiguration;
}

export class FileDynamicRoute implements IFileDynamicRoute {
    serviceName!: string | undefined;
    rateLimitRule!: FileRateLimitRule;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileDynamicRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.rateLimitRule = _data["rateLimitRule"] ? FileRateLimitRule.fromJS(_data["rateLimitRule"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileDynamicRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileDynamicRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["rateLimitRule"] = this.rateLimitRule ? this.rateLimitRule.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileDynamicRoute {
    serviceName: string | undefined;
    rateLimitRule: FileRateLimitRule;
    downstreamHttpVersion: string | undefined;
}

export class FileGlobalConfiguration implements IFileGlobalConfiguration {
    requestIdKey!: string | undefined;
    serviceDiscoveryProvider!: FileServiceDiscoveryProvider;
    rateLimitOptions!: FileRateLimitOptions;
    qoSOptions!: FileQoSOptions;
    baseUrl!: string | undefined;
    loadBalancerOptions!: FileLoadBalancerOptions;
    downstreamScheme!: string | undefined;
    httpHandlerOptions!: FileHttpHandlerOptions;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileGlobalConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestIdKey = _data["requestIdKey"];
            this.serviceDiscoveryProvider = _data["serviceDiscoveryProvider"] ? FileServiceDiscoveryProvider.fromJS(_data["serviceDiscoveryProvider"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitOptions.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.baseUrl = _data["baseUrl"];
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.downstreamScheme = _data["downstreamScheme"];
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileGlobalConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FileGlobalConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestIdKey"] = this.requestIdKey;
        data["serviceDiscoveryProvider"] = this.serviceDiscoveryProvider ? this.serviceDiscoveryProvider.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["baseUrl"] = this.baseUrl;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["downstreamScheme"] = this.downstreamScheme;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileGlobalConfiguration {
    requestIdKey: string | undefined;
    serviceDiscoveryProvider: FileServiceDiscoveryProvider;
    rateLimitOptions: FileRateLimitOptions;
    qoSOptions: FileQoSOptions;
    baseUrl: string | undefined;
    loadBalancerOptions: FileLoadBalancerOptions;
    downstreamScheme: string | undefined;
    httpHandlerOptions: FileHttpHandlerOptions;
    downstreamHttpVersion: string | undefined;
}

export class FileHostAndPort implements IFileHostAndPort {
    host!: string | undefined;
    port!: number;

    constructor(data?: IFileHostAndPort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): FileHostAndPort {
        data = typeof data === 'object' ? data : {};
        let result = new FileHostAndPort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        return data;
    }
}

export interface IFileHostAndPort {
    host: string | undefined;
    port: number;
}

export class FileHttpHandlerOptions implements IFileHttpHandlerOptions {
    allowAutoRedirect!: boolean;
    useCookieContainer!: boolean;
    useTracing!: boolean;
    useProxy!: boolean;
    maxConnectionsPerServer!: number;

    constructor(data?: IFileHttpHandlerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowAutoRedirect = _data["allowAutoRedirect"];
            this.useCookieContainer = _data["useCookieContainer"];
            this.useTracing = _data["useTracing"];
            this.useProxy = _data["useProxy"];
            this.maxConnectionsPerServer = _data["maxConnectionsPerServer"];
        }
    }

    static fromJS(data: any): FileHttpHandlerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileHttpHandlerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowAutoRedirect"] = this.allowAutoRedirect;
        data["useCookieContainer"] = this.useCookieContainer;
        data["useTracing"] = this.useTracing;
        data["useProxy"] = this.useProxy;
        data["maxConnectionsPerServer"] = this.maxConnectionsPerServer;
        return data;
    }
}

export interface IFileHttpHandlerOptions {
    allowAutoRedirect: boolean;
    useCookieContainer: boolean;
    useTracing: boolean;
    useProxy: boolean;
    maxConnectionsPerServer: number;
}

export class FileLoadBalancerOptions implements IFileLoadBalancerOptions {
    type!: string | undefined;
    key!: string | undefined;
    expiry!: number;

    constructor(data?: IFileLoadBalancerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.key = _data["key"];
            this.expiry = _data["expiry"];
        }
    }

    static fromJS(data: any): FileLoadBalancerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileLoadBalancerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["key"] = this.key;
        data["expiry"] = this.expiry;
        return data;
    }
}

export interface IFileLoadBalancerOptions {
    type: string | undefined;
    key: string | undefined;
    expiry: number;
}

export class FileQoSOptions implements IFileQoSOptions {
    exceptionsAllowedBeforeBreaking!: number;
    durationOfBreak!: number;
    timeoutValue!: number;

    constructor(data?: IFileQoSOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exceptionsAllowedBeforeBreaking = _data["exceptionsAllowedBeforeBreaking"];
            this.durationOfBreak = _data["durationOfBreak"];
            this.timeoutValue = _data["timeoutValue"];
        }
    }

    static fromJS(data: any): FileQoSOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileQoSOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exceptionsAllowedBeforeBreaking"] = this.exceptionsAllowedBeforeBreaking;
        data["durationOfBreak"] = this.durationOfBreak;
        data["timeoutValue"] = this.timeoutValue;
        return data;
    }
}

export interface IFileQoSOptions {
    exceptionsAllowedBeforeBreaking: number;
    durationOfBreak: number;
    timeoutValue: number;
}

export class FileRateLimitOptions implements IFileRateLimitOptions {
    clientIdHeader!: string | undefined;
    quotaExceededMessage!: string | undefined;
    rateLimitCounterPrefix!: string | undefined;
    disableRateLimitHeaders!: boolean;
    httpStatusCode!: number;

    constructor(data?: IFileRateLimitOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientIdHeader = _data["clientIdHeader"];
            this.quotaExceededMessage = _data["quotaExceededMessage"];
            this.rateLimitCounterPrefix = _data["rateLimitCounterPrefix"];
            this.disableRateLimitHeaders = _data["disableRateLimitHeaders"];
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): FileRateLimitOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientIdHeader"] = this.clientIdHeader;
        data["quotaExceededMessage"] = this.quotaExceededMessage;
        data["rateLimitCounterPrefix"] = this.rateLimitCounterPrefix;
        data["disableRateLimitHeaders"] = this.disableRateLimitHeaders;
        data["httpStatusCode"] = this.httpStatusCode;
        return data;
    }
}

export interface IFileRateLimitOptions {
    clientIdHeader: string | undefined;
    quotaExceededMessage: string | undefined;
    rateLimitCounterPrefix: string | undefined;
    disableRateLimitHeaders: boolean;
    httpStatusCode: number;
}

export class FileRateLimitRule implements IFileRateLimitRule {
    clientWhitelist!: string[] | undefined;
    enableRateLimiting!: boolean;
    period!: string | undefined;
    periodTimespan!: number;
    limit!: number;

    constructor(data?: IFileRateLimitRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientWhitelist"])) {
                this.clientWhitelist = [] as any;
                for (let item of _data["clientWhitelist"])
                    this.clientWhitelist!.push(item);
            }
            this.enableRateLimiting = _data["enableRateLimiting"];
            this.period = _data["period"];
            this.periodTimespan = _data["periodTimespan"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): FileRateLimitRule {
        data = typeof data === 'object' ? data : {};
        let result = new FileRateLimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientWhitelist)) {
            data["clientWhitelist"] = [];
            for (let item of this.clientWhitelist)
                data["clientWhitelist"].push(item);
        }
        data["enableRateLimiting"] = this.enableRateLimiting;
        data["period"] = this.period;
        data["periodTimespan"] = this.periodTimespan;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IFileRateLimitRule {
    clientWhitelist: string[] | undefined;
    enableRateLimiting: boolean;
    period: string | undefined;
    periodTimespan: number;
    limit: number;
}

export class FileRoute implements IFileRoute {
    downstreamPathTemplate!: string | undefined;
    upstreamPathTemplate!: string | undefined;
    upstreamHttpMethod!: string[] | undefined;
    downstreamHttpMethod!: string | undefined;
    addHeadersToRequest!: { [key: string]: string; } | undefined;
    upstreamHeaderTransform!: { [key: string]: string; } | undefined;
    downstreamHeaderTransform!: { [key: string]: string; } | undefined;
    addClaimsToRequest!: { [key: string]: string; } | undefined;
    routeClaimsRequirement!: { [key: string]: string; } | undefined;
    addQueriesToRequest!: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate!: { [key: string]: string; } | undefined;
    requestIdKey!: string | undefined;
    fileCacheOptions!: FileCacheOptions;
    routeIsCaseSensitive!: boolean;
    serviceName!: string | undefined;
    serviceNamespace!: string | undefined;
    downstreamScheme!: string | undefined;
    qoSOptions!: FileQoSOptions;
    loadBalancerOptions!: FileLoadBalancerOptions;
    rateLimitOptions!: FileRateLimitRule;
    authenticationOptions!: FileAuthenticationOptions;
    httpHandlerOptions!: FileHttpHandlerOptions;
    downstreamHostAndPorts!: FileHostAndPort[] | undefined;
    upstreamHost!: string | undefined;
    key!: string | undefined;
    delegatingHandlers!: string[] | undefined;
    priority!: number;
    timeout!: number;
    dangerousAcceptAnyServerCertificateValidator!: boolean;
    securityOptions!: FileSecurityOptions;
    downstreamHttpVersion!: string | undefined;

    constructor(data?: IFileRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downstreamPathTemplate = _data["downstreamPathTemplate"];
            this.upstreamPathTemplate = _data["upstreamPathTemplate"];
            if (Array.isArray(_data["upstreamHttpMethod"])) {
                this.upstreamHttpMethod = [] as any;
                for (let item of _data["upstreamHttpMethod"])
                    this.upstreamHttpMethod!.push(item);
            }
            this.downstreamHttpMethod = _data["downstreamHttpMethod"];
            if (_data["addHeadersToRequest"]) {
                this.addHeadersToRequest = {} as any;
                for (let key in _data["addHeadersToRequest"]) {
                    if (_data["addHeadersToRequest"].hasOwnProperty(key))
                        (<any>this.addHeadersToRequest)![key] = _data["addHeadersToRequest"][key];
                }
            }
            if (_data["upstreamHeaderTransform"]) {
                this.upstreamHeaderTransform = {} as any;
                for (let key in _data["upstreamHeaderTransform"]) {
                    if (_data["upstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.upstreamHeaderTransform)![key] = _data["upstreamHeaderTransform"][key];
                }
            }
            if (_data["downstreamHeaderTransform"]) {
                this.downstreamHeaderTransform = {} as any;
                for (let key in _data["downstreamHeaderTransform"]) {
                    if (_data["downstreamHeaderTransform"].hasOwnProperty(key))
                        (<any>this.downstreamHeaderTransform)![key] = _data["downstreamHeaderTransform"][key];
                }
            }
            if (_data["addClaimsToRequest"]) {
                this.addClaimsToRequest = {} as any;
                for (let key in _data["addClaimsToRequest"]) {
                    if (_data["addClaimsToRequest"].hasOwnProperty(key))
                        (<any>this.addClaimsToRequest)![key] = _data["addClaimsToRequest"][key];
                }
            }
            if (_data["routeClaimsRequirement"]) {
                this.routeClaimsRequirement = {} as any;
                for (let key in _data["routeClaimsRequirement"]) {
                    if (_data["routeClaimsRequirement"].hasOwnProperty(key))
                        (<any>this.routeClaimsRequirement)![key] = _data["routeClaimsRequirement"][key];
                }
            }
            if (_data["addQueriesToRequest"]) {
                this.addQueriesToRequest = {} as any;
                for (let key in _data["addQueriesToRequest"]) {
                    if (_data["addQueriesToRequest"].hasOwnProperty(key))
                        (<any>this.addQueriesToRequest)![key] = _data["addQueriesToRequest"][key];
                }
            }
            if (_data["changeDownstreamPathTemplate"]) {
                this.changeDownstreamPathTemplate = {} as any;
                for (let key in _data["changeDownstreamPathTemplate"]) {
                    if (_data["changeDownstreamPathTemplate"].hasOwnProperty(key))
                        (<any>this.changeDownstreamPathTemplate)![key] = _data["changeDownstreamPathTemplate"][key];
                }
            }
            this.requestIdKey = _data["requestIdKey"];
            this.fileCacheOptions = _data["fileCacheOptions"] ? FileCacheOptions.fromJS(_data["fileCacheOptions"]) : <any>undefined;
            this.routeIsCaseSensitive = _data["routeIsCaseSensitive"];
            this.serviceName = _data["serviceName"];
            this.serviceNamespace = _data["serviceNamespace"];
            this.downstreamScheme = _data["downstreamScheme"];
            this.qoSOptions = _data["qoSOptions"] ? FileQoSOptions.fromJS(_data["qoSOptions"]) : <any>undefined;
            this.loadBalancerOptions = _data["loadBalancerOptions"] ? FileLoadBalancerOptions.fromJS(_data["loadBalancerOptions"]) : <any>undefined;
            this.rateLimitOptions = _data["rateLimitOptions"] ? FileRateLimitRule.fromJS(_data["rateLimitOptions"]) : <any>undefined;
            this.authenticationOptions = _data["authenticationOptions"] ? FileAuthenticationOptions.fromJS(_data["authenticationOptions"]) : <any>undefined;
            this.httpHandlerOptions = _data["httpHandlerOptions"] ? FileHttpHandlerOptions.fromJS(_data["httpHandlerOptions"]) : <any>undefined;
            if (Array.isArray(_data["downstreamHostAndPorts"])) {
                this.downstreamHostAndPorts = [] as any;
                for (let item of _data["downstreamHostAndPorts"])
                    this.downstreamHostAndPorts!.push(FileHostAndPort.fromJS(item));
            }
            this.upstreamHost = _data["upstreamHost"];
            this.key = _data["key"];
            if (Array.isArray(_data["delegatingHandlers"])) {
                this.delegatingHandlers = [] as any;
                for (let item of _data["delegatingHandlers"])
                    this.delegatingHandlers!.push(item);
            }
            this.priority = _data["priority"];
            this.timeout = _data["timeout"];
            this.dangerousAcceptAnyServerCertificateValidator = _data["dangerousAcceptAnyServerCertificateValidator"];
            this.securityOptions = _data["securityOptions"] ? FileSecurityOptions.fromJS(_data["securityOptions"]) : <any>undefined;
            this.downstreamHttpVersion = _data["downstreamHttpVersion"];
        }
    }

    static fromJS(data: any): FileRoute {
        data = typeof data === 'object' ? data : {};
        let result = new FileRoute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downstreamPathTemplate"] = this.downstreamPathTemplate;
        data["upstreamPathTemplate"] = this.upstreamPathTemplate;
        if (Array.isArray(this.upstreamHttpMethod)) {
            data["upstreamHttpMethod"] = [];
            for (let item of this.upstreamHttpMethod)
                data["upstreamHttpMethod"].push(item);
        }
        data["downstreamHttpMethod"] = this.downstreamHttpMethod;
        if (this.addHeadersToRequest) {
            data["addHeadersToRequest"] = {};
            for (let key in this.addHeadersToRequest) {
                if (this.addHeadersToRequest.hasOwnProperty(key))
                    (<any>data["addHeadersToRequest"])[key] = (<any>this.addHeadersToRequest)[key];
            }
        }
        if (this.upstreamHeaderTransform) {
            data["upstreamHeaderTransform"] = {};
            for (let key in this.upstreamHeaderTransform) {
                if (this.upstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["upstreamHeaderTransform"])[key] = (<any>this.upstreamHeaderTransform)[key];
            }
        }
        if (this.downstreamHeaderTransform) {
            data["downstreamHeaderTransform"] = {};
            for (let key in this.downstreamHeaderTransform) {
                if (this.downstreamHeaderTransform.hasOwnProperty(key))
                    (<any>data["downstreamHeaderTransform"])[key] = (<any>this.downstreamHeaderTransform)[key];
            }
        }
        if (this.addClaimsToRequest) {
            data["addClaimsToRequest"] = {};
            for (let key in this.addClaimsToRequest) {
                if (this.addClaimsToRequest.hasOwnProperty(key))
                    (<any>data["addClaimsToRequest"])[key] = (<any>this.addClaimsToRequest)[key];
            }
        }
        if (this.routeClaimsRequirement) {
            data["routeClaimsRequirement"] = {};
            for (let key in this.routeClaimsRequirement) {
                if (this.routeClaimsRequirement.hasOwnProperty(key))
                    (<any>data["routeClaimsRequirement"])[key] = (<any>this.routeClaimsRequirement)[key];
            }
        }
        if (this.addQueriesToRequest) {
            data["addQueriesToRequest"] = {};
            for (let key in this.addQueriesToRequest) {
                if (this.addQueriesToRequest.hasOwnProperty(key))
                    (<any>data["addQueriesToRequest"])[key] = (<any>this.addQueriesToRequest)[key];
            }
        }
        if (this.changeDownstreamPathTemplate) {
            data["changeDownstreamPathTemplate"] = {};
            for (let key in this.changeDownstreamPathTemplate) {
                if (this.changeDownstreamPathTemplate.hasOwnProperty(key))
                    (<any>data["changeDownstreamPathTemplate"])[key] = (<any>this.changeDownstreamPathTemplate)[key];
            }
        }
        data["requestIdKey"] = this.requestIdKey;
        data["fileCacheOptions"] = this.fileCacheOptions ? this.fileCacheOptions.toJSON() : <any>undefined;
        data["routeIsCaseSensitive"] = this.routeIsCaseSensitive;
        data["serviceName"] = this.serviceName;
        data["serviceNamespace"] = this.serviceNamespace;
        data["downstreamScheme"] = this.downstreamScheme;
        data["qoSOptions"] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
        data["loadBalancerOptions"] = this.loadBalancerOptions ? this.loadBalancerOptions.toJSON() : <any>undefined;
        data["rateLimitOptions"] = this.rateLimitOptions ? this.rateLimitOptions.toJSON() : <any>undefined;
        data["authenticationOptions"] = this.authenticationOptions ? this.authenticationOptions.toJSON() : <any>undefined;
        data["httpHandlerOptions"] = this.httpHandlerOptions ? this.httpHandlerOptions.toJSON() : <any>undefined;
        if (Array.isArray(this.downstreamHostAndPorts)) {
            data["downstreamHostAndPorts"] = [];
            for (let item of this.downstreamHostAndPorts)
                data["downstreamHostAndPorts"].push(item.toJSON());
        }
        data["upstreamHost"] = this.upstreamHost;
        data["key"] = this.key;
        if (Array.isArray(this.delegatingHandlers)) {
            data["delegatingHandlers"] = [];
            for (let item of this.delegatingHandlers)
                data["delegatingHandlers"].push(item);
        }
        data["priority"] = this.priority;
        data["timeout"] = this.timeout;
        data["dangerousAcceptAnyServerCertificateValidator"] = this.dangerousAcceptAnyServerCertificateValidator;
        data["securityOptions"] = this.securityOptions ? this.securityOptions.toJSON() : <any>undefined;
        data["downstreamHttpVersion"] = this.downstreamHttpVersion;
        return data;
    }
}

export interface IFileRoute {
    downstreamPathTemplate: string | undefined;
    upstreamPathTemplate: string | undefined;
    upstreamHttpMethod: string[] | undefined;
    downstreamHttpMethod: string | undefined;
    addHeadersToRequest: { [key: string]: string; } | undefined;
    upstreamHeaderTransform: { [key: string]: string; } | undefined;
    downstreamHeaderTransform: { [key: string]: string; } | undefined;
    addClaimsToRequest: { [key: string]: string; } | undefined;
    routeClaimsRequirement: { [key: string]: string; } | undefined;
    addQueriesToRequest: { [key: string]: string; } | undefined;
    changeDownstreamPathTemplate: { [key: string]: string; } | undefined;
    requestIdKey: string | undefined;
    fileCacheOptions: FileCacheOptions;
    routeIsCaseSensitive: boolean;
    serviceName: string | undefined;
    serviceNamespace: string | undefined;
    downstreamScheme: string | undefined;
    qoSOptions: FileQoSOptions;
    loadBalancerOptions: FileLoadBalancerOptions;
    rateLimitOptions: FileRateLimitRule;
    authenticationOptions: FileAuthenticationOptions;
    httpHandlerOptions: FileHttpHandlerOptions;
    downstreamHostAndPorts: FileHostAndPort[] | undefined;
    upstreamHost: string | undefined;
    key: string | undefined;
    delegatingHandlers: string[] | undefined;
    priority: number;
    timeout: number;
    dangerousAcceptAnyServerCertificateValidator: boolean;
    securityOptions: FileSecurityOptions;
    downstreamHttpVersion: string | undefined;
}

export class FileSecurityOptions implements IFileSecurityOptions {
    ipAllowedList!: string[] | undefined;
    ipBlockedList!: string[] | undefined;

    constructor(data?: IFileSecurityOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ipAllowedList"])) {
                this.ipAllowedList = [] as any;
                for (let item of _data["ipAllowedList"])
                    this.ipAllowedList!.push(item);
            }
            if (Array.isArray(_data["ipBlockedList"])) {
                this.ipBlockedList = [] as any;
                for (let item of _data["ipBlockedList"])
                    this.ipBlockedList!.push(item);
            }
        }
    }

    static fromJS(data: any): FileSecurityOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FileSecurityOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ipAllowedList)) {
            data["ipAllowedList"] = [];
            for (let item of this.ipAllowedList)
                data["ipAllowedList"].push(item);
        }
        if (Array.isArray(this.ipBlockedList)) {
            data["ipBlockedList"] = [];
            for (let item of this.ipBlockedList)
                data["ipBlockedList"].push(item);
        }
        return data;
    }
}

export interface IFileSecurityOptions {
    ipAllowedList: string[] | undefined;
    ipBlockedList: string[] | undefined;
}

export class FileServiceDiscoveryProvider implements IFileServiceDiscoveryProvider {
    scheme!: string | undefined;
    host!: string | undefined;
    port!: number;
    type!: string | undefined;
    token!: string | undefined;
    configurationKey!: string | undefined;
    pollingInterval!: number;
    namespace!: string | undefined;

    constructor(data?: IFileServiceDiscoveryProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheme = _data["scheme"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.type = _data["type"];
            this.token = _data["token"];
            this.configurationKey = _data["configurationKey"];
            this.pollingInterval = _data["pollingInterval"];
            this.namespace = _data["namespace"];
        }
    }

    static fromJS(data: any): FileServiceDiscoveryProvider {
        data = typeof data === 'object' ? data : {};
        let result = new FileServiceDiscoveryProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheme"] = this.scheme;
        data["host"] = this.host;
        data["port"] = this.port;
        data["type"] = this.type;
        data["token"] = this.token;
        data["configurationKey"] = this.configurationKey;
        data["pollingInterval"] = this.pollingInterval;
        data["namespace"] = this.namespace;
        return data;
    }
}

export interface IFileServiceDiscoveryProvider {
    scheme: string | undefined;
    host: string | undefined;
    port: number;
    type: string | undefined;
    token: string | undefined;
    configurationKey: string | undefined;
    pollingInterval: number;
    namespace: string | undefined;
}

export class FindTenantByNameInput implements IFindTenantByNameInput {
    name!: string | undefined;

    constructor(data?: IFindTenantByNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FindTenantByNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantByNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IFindTenantByNameInput {
    name: string | undefined;
}

export class FindTenantResultDto implements IFindTenantResultDto {
    success!: boolean;
    tenantId!: string | undefined;
    name!: string | undefined;
    isActive!: boolean;

    constructor(data?: IFindTenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FindTenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFindTenantResultDto {
    success: boolean;
    tenantId: string | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class GatewayAddDeviceDto implements IGatewayAddDeviceDto {
    id!: string;
    deviceIds!: string[] | undefined;

    constructor(data?: IGatewayAddDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GatewayAddDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayAddDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        return data;
    }
}

export interface IGatewayAddDeviceDto {
    id: string;
    deviceIds: string[] | undefined;
}

export class GatewayDeviceDto implements IGatewayDeviceDto {
    deviceName!: string | undefined;
    deviceId!: string;
    checked!: boolean;

    constructor(data?: IGatewayDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceName = _data["deviceName"];
            this.deviceId = _data["deviceId"];
            this.checked = _data["checked"];
        }
    }

    static fromJS(data: any): GatewayDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName;
        data["deviceId"] = this.deviceId;
        data["checked"] = this.checked;
        return data;
    }
}

export interface IGatewayDeviceDto {
    deviceName: string | undefined;
    deviceId: string;
    checked: boolean;
}

export class GetOrganizationUnitRoleInput implements IGetOrganizationUnitRoleInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    organizationUnitId!: string;

    constructor(data?: IGetOrganizationUnitRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): GetOrganizationUnitRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUnitRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IGetOrganizationUnitRoleInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    organizationUnitId: string;
}

export class GetOrganizationUnitRoleOutput implements IGetOrganizationUnitRoleOutput {
    id!: string;
    name!: string | undefined;

    constructor(data?: IGetOrganizationUnitRoleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetOrganizationUnitRoleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUnitRoleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetOrganizationUnitRoleOutput {
    id: string;
    name: string | undefined;
}

export class GetOrganizationUnitRoleOutputPagedResultDto implements IGetOrganizationUnitRoleOutputPagedResultDto {
    items!: GetOrganizationUnitRoleOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IGetOrganizationUnitRoleOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOrganizationUnitRoleOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetOrganizationUnitRoleOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUnitRoleOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetOrganizationUnitRoleOutputPagedResultDto {
    items: GetOrganizationUnitRoleOutput[] | undefined;
    totalCount: number;
}

export class GetOrganizationUnitUserInput implements IGetOrganizationUnitUserInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    organizationUnitId!: string;
    filter!: string | undefined;

    constructor(data?: IGetOrganizationUnitUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): GetOrganizationUnitUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUnitUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["organizationUnitId"] = this.organizationUnitId;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IGetOrganizationUnitUserInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    organizationUnitId: string;
    filter: string | undefined;
}

export class GetOrganizationUnitUserOutput implements IGetOrganizationUnitUserOutput {
    id!: string;
    userName!: string | undefined;
    email!: string | undefined;

    constructor(data?: IGetOrganizationUnitUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetOrganizationUnitUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUnitUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetOrganizationUnitUserOutput {
    id: string;
    userName: string | undefined;
    email: string | undefined;
}

export class GetOrganizationUnitUserOutputPagedResultDto implements IGetOrganizationUnitUserOutputPagedResultDto {
    items!: GetOrganizationUnitUserOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IGetOrganizationUnitUserOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOrganizationUnitUserOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetOrganizationUnitUserOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationUnitUserOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetOrganizationUnitUserOutputPagedResultDto {
    items: GetOrganizationUnitUserOutput[] | undefined;
    totalCount: number;
}

export class GetPermissionInput implements IGetPermissionInput {
    providerName!: string | undefined;
    providerKey!: string | undefined;

    constructor(data?: IGetPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): GetPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        return data;
    }
}

export interface IGetPermissionInput {
    providerName: string | undefined;
    providerKey: string | undefined;
}

export class GetUnAddRoleInput implements IGetUnAddRoleInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    organizationUnitId!: string;
    filter!: string | undefined;

    constructor(data?: IGetUnAddRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): GetUnAddRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnAddRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["organizationUnitId"] = this.organizationUnitId;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IGetUnAddRoleInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    organizationUnitId: string;
    filter: string | undefined;
}

export class GetUnAddRoleOutput implements IGetUnAddRoleOutput {
    id!: string;
    name!: string | undefined;

    constructor(data?: IGetUnAddRoleOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetUnAddRoleOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnAddRoleOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetUnAddRoleOutput {
    id: string;
    name: string | undefined;
}

export class GetUnAddRoleOutputPagedResultDto implements IGetUnAddRoleOutputPagedResultDto {
    items!: GetUnAddRoleOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IGetUnAddRoleOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetUnAddRoleOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetUnAddRoleOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnAddRoleOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetUnAddRoleOutputPagedResultDto {
    items: GetUnAddRoleOutput[] | undefined;
    totalCount: number;
}

export class GetUnAddUserInput implements IGetUnAddUserInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    organizationUnitId!: string;
    filter!: string | undefined;

    constructor(data?: IGetUnAddUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): GetUnAddUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnAddUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["organizationUnitId"] = this.organizationUnitId;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IGetUnAddUserInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    organizationUnitId: string;
    filter: string | undefined;
}

export class GetUnAddUserOutput implements IGetUnAddUserOutput {
    id!: string;
    userName!: string | undefined;
    email!: string | undefined;

    constructor(data?: IGetUnAddUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetUnAddUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnAddUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetUnAddUserOutput {
    id: string;
    userName: string | undefined;
    email: string | undefined;
}

export class GetUnAddUserOutputPagedResultDto implements IGetUnAddUserOutputPagedResultDto {
    items!: GetUnAddUserOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IGetUnAddUserOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetUnAddUserOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetUnAddUserOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUnAddUserOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetUnAddUserOutputPagedResultDto {
    items: GetUnAddUserOutput[] | undefined;
    totalCount: number;
}

export class GuidNameValue implements IGuidNameValue {
    name!: string | undefined;
    value!: string;

    constructor(data?: IGuidNameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GuidNameValue {
        data = typeof data === 'object' ? data : {};
        let result = new GuidNameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IGuidNameValue {
    name: string | undefined;
    value: string;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 301,
    MovedPermanently = 302,
    Moved = 303,
    Found = 304,
    Redirect = 305,
    SeeOther = 306,
    RedirectMethod = 307,
    NotModified = 308,
    UseProxy = 400,
    Unused = 401,
    TemporaryRedirect = 402,
    RedirectKeepVerb = 403,
    PermanentRedirect = 404,
    BadRequest = 405,
    Unauthorized = 406,
    PaymentRequired = 407,
    Forbidden = 408,
    NotFound = 409,
    MethodNotAllowed = 410,
    NotAcceptable = 411,
    ProxyAuthenticationRequired = 412,
    RequestTimeout = 413,
    Conflict = 414,
    Gone = 415,
    LengthRequired = 416,
    PreconditionFailed = 417,
    RequestEntityTooLarge = 421,
    RequestUriTooLong = 422,
    UnsupportedMediaType = 423,
    RequestedRangeNotSatisfiable = 424,
    ExpectationFailed = 426,
    MisdirectedRequest = 428,
    UnprocessableEntity = 429,
    UnprocessableContent = 431,
    Locked = 451,
    FailedDependency = 500,
    UpgradeRequired = 501,
    PreconditionRequired = 502,
    TooManyRequests = 503,
    RequestHeaderFieldsTooLarge = 504,
    UnavailableForLegalReasons = 505,
    InternalServerError = 506,
    NotImplemented = 507,
    BadGateway = 508,
    ServiceUnavailable = 510,
    GatewayTimeout = 511,
}

export class IanaTimeZone implements IIanaTimeZone {
    timeZoneName!: string | undefined;

    constructor(data?: IIanaTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneName = _data["timeZoneName"];
        }
    }

    static fromJS(data: any): IanaTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new IanaTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneName"] = this.timeZoneName;
        return data;
    }
}

export interface IIanaTimeZone {
    timeZoneName: string | undefined;
}

export class IdInput implements IIdInput {
    id!: string;

    constructor(data?: IIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdInput {
        data = typeof data === 'object' ? data : {};
        let result = new IdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IIdInput {
    id: string;
}

export class IdentityRoleCreateDto implements IIdentityRoleCreateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    name!: string;
    isDefault!: boolean;
    isPublic!: boolean;

    constructor(data?: IIdentityRoleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): IdentityRoleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export interface IIdentityRoleCreateDto {
    extraProperties: { [key: string]: any; } | undefined;
    name: string;
    isDefault: boolean;
    isPublic: boolean;
}

export class IdentityRoleDto implements IIdentityRoleDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    id!: string;
    name!: string | undefined;
    isDefault!: boolean;
    isStatic!: boolean;
    isPublic!: boolean;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleDto {
    extraProperties: { [key: string]: any; } | undefined;
    id: string;
    name: string | undefined;
    isDefault: boolean;
    isStatic: boolean;
    isPublic: boolean;
    concurrencyStamp: string | undefined;
}

export class IdentityRoleDtoListResultDto implements IIdentityRoleDtoListResultDto {
    items!: IdentityRoleDto[] | undefined;

    constructor(data?: IIdentityRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityRoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityRoleDtoListResultDto {
    items: IdentityRoleDto[] | undefined;
}

export class IdentityRoleDtoPagedResultDto implements IIdentityRoleDtoPagedResultDto {
    items!: IdentityRoleDto[] | undefined;
    totalCount!: number;

    constructor(data?: IIdentityRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdentityRoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IIdentityRoleDtoPagedResultDto {
    items: IdentityRoleDto[] | undefined;
    totalCount: number;
}

export class IdentityRoleUpdateDto implements IIdentityRoleUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    name!: string;
    isDefault!: boolean;
    isPublic!: boolean;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityRoleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleUpdateDto {
    extraProperties: { [key: string]: any; } | undefined;
    name: string;
    isDefault: boolean;
    isPublic: boolean;
    concurrencyStamp: string | undefined;
}

export enum IdentityType {
    AccessToken = 0,
    AccountPassword = 1,
}

export class IdentityUserCreateDto implements IIdentityUserCreateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    userName!: string;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string;
    phoneNumber!: string | undefined;
    isActive!: boolean;
    lockoutEnabled!: boolean;
    roleNames!: string[] | undefined;
    password!: string;

    constructor(data?: IIdentityUserCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): IdentityUserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }
}

export interface IIdentityUserCreateDto {
    extraProperties: { [key: string]: any; } | undefined;
    userName: string;
    name: string | undefined;
    surname: string | undefined;
    email: string;
    phoneNumber: string | undefined;
    isActive: boolean;
    lockoutEnabled: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class IdentityUserDto implements IIdentityUserDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    id!: string;
    creationTime!: dayjs.Dayjs;
    creatorId!: string | undefined;
    lastModificationTime!: dayjs.Dayjs | undefined;
    lastModifierId!: string | undefined;
    isDeleted!: boolean;
    deleterId!: string | undefined;
    deletionTime!: dayjs.Dayjs | undefined;
    tenantId!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string | undefined;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    isActive!: boolean;
    lockoutEnabled!: boolean;
    accessFailedCount!: number;
    lockoutEnd!: dayjs.Dayjs | undefined;
    concurrencyStamp!: string | undefined;
    entityVersion!: number;
    lastPasswordChangeTime!: dayjs.Dayjs | undefined;

    constructor(data?: IIdentityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? dayjs(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? dayjs(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? dayjs(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.lockoutEnd = _data["lockoutEnd"] ? dayjs(_data["lockoutEnd"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.entityVersion = _data["entityVersion"];
            this.lastPasswordChangeTime = _data["lastPasswordChangeTime"] ? dayjs(_data["lastPasswordChangeTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toLocaleString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toLocaleString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toLocaleString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["entityVersion"] = this.entityVersion;
        data["lastPasswordChangeTime"] = this.lastPasswordChangeTime ? this.lastPasswordChangeTime.toLocaleString() : <any>undefined;
        return data;
    }
}

export interface IIdentityUserDto {
    extraProperties: { [key: string]: any; } | undefined;
    id: string;
    creationTime: dayjs.Dayjs;
    creatorId: string | undefined;
    lastModificationTime: dayjs.Dayjs | undefined;
    lastModifierId: string | undefined;
    isDeleted: boolean;
    deleterId: string | undefined;
    deletionTime: dayjs.Dayjs | undefined;
    tenantId: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    email: string | undefined;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    isActive: boolean;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    lockoutEnd: dayjs.Dayjs | undefined;
    concurrencyStamp: string | undefined;
    entityVersion: number;
    lastPasswordChangeTime: dayjs.Dayjs | undefined;
}

export class IdentityUserDtoPagedResultDto implements IIdentityUserDtoPagedResultDto {
    items!: IdentityUserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IIdentityUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityUserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdentityUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IIdentityUserDtoPagedResultDto {
    items: IdentityUserDto[] | undefined;
    totalCount: number;
}

export class IdentityUserUpdateDto implements IIdentityUserUpdateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    userName!: string;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string;
    phoneNumber!: string | undefined;
    isActive!: boolean;
    lockoutEnabled!: boolean;
    roleNames!: string[] | undefined;
    password!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: IIdentityUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.password = _data["password"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityUserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityUserUpdateDto {
    extraProperties: { [key: string]: any; } | undefined;
    userName: string;
    name: string | undefined;
    surname: string | undefined;
    email: string;
    phoneNumber: string | undefined;
    isActive: boolean;
    lockoutEnabled: boolean;
    roleNames: string[] | undefined;
    password: string | undefined;
    concurrencyStamp: string | undefined;
}

export class Int32NameValue implements IInt32NameValue {
    name!: string | undefined;
    value!: number;

    constructor(data?: IInt32NameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Int32NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new Int32NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IInt32NameValue {
    name: string | undefined;
    value: number;
}

export class InterfaceMethodApiDescriptionModel implements IInterfaceMethodApiDescriptionModel {
    name!: string | undefined;
    parametersOnMethod!: MethodParameterApiDescriptionModel[] | undefined;
    returnValue!: ReturnValueApiDescriptionModel;

    constructor(data?: IInterfaceMethodApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InterfaceMethodApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new InterfaceMethodApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInterfaceMethodApiDescriptionModel {
    name: string | undefined;
    parametersOnMethod: MethodParameterApiDescriptionModel[] | undefined;
    returnValue: ReturnValueApiDescriptionModel;
}

export class KeyParamChartDataDto implements IKeyParamChartDataDto {
    legend!: string[] | undefined;
    series!: string[] | undefined;
    xDataList!: string[] | undefined;
    yDataList!: number[][] | undefined;
    summaryList!: LabelValueDto[] | undefined;

    constructor(data?: IKeyParamChartDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["legend"])) {
                this.legend = [] as any;
                for (let item of _data["legend"])
                    this.legend!.push(item);
            }
            if (Array.isArray(_data["series"])) {
                this.series = [] as any;
                for (let item of _data["series"])
                    this.series!.push(item);
            }
            if (Array.isArray(_data["xDataList"])) {
                this.xDataList = [] as any;
                for (let item of _data["xDataList"])
                    this.xDataList!.push(item);
            }
            if (Array.isArray(_data["yDataList"])) {
                this.yDataList = [] as any;
                for (let item of _data["yDataList"])
                    this.yDataList!.push(item);
            }
            if (Array.isArray(_data["summaryList"])) {
                this.summaryList = [] as any;
                for (let item of _data["summaryList"])
                    this.summaryList!.push(LabelValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KeyParamChartDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyParamChartDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.legend)) {
            data["legend"] = [];
            for (let item of this.legend)
                data["legend"].push(item);
        }
        if (Array.isArray(this.series)) {
            data["series"] = [];
            for (let item of this.series)
                data["series"].push(item);
        }
        if (Array.isArray(this.xDataList)) {
            data["xDataList"] = [];
            for (let item of this.xDataList)
                data["xDataList"].push(item);
        }
        if (Array.isArray(this.yDataList)) {
            data["yDataList"] = [];
            for (let item of this.yDataList)
                data["yDataList"].push(item);
        }
        if (Array.isArray(this.summaryList)) {
            data["summaryList"] = [];
            for (let item of this.summaryList)
                data["summaryList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKeyParamChartDataDto {
    legend: string[] | undefined;
    series: string[] | undefined;
    xDataList: string[] | undefined;
    yDataList: number[][] | undefined;
    summaryList: LabelValueDto[] | undefined;
}

export class KeyParamTableDataDto implements IKeyParamTableDataDto {
    keyParameter!: string | undefined;
    value!: number;
    time!: string | undefined;

    constructor(data?: IKeyParamTableDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keyParameter = _data["keyParameter"];
            this.value = _data["value"];
            this.time = _data["time"];
        }
    }

    static fromJS(data: any): KeyParamTableDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyParamTableDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyParameter"] = this.keyParameter;
        data["value"] = this.value;
        data["time"] = this.time;
        return data;
    }
}

export interface IKeyParamTableDataDto {
    keyParameter: string | undefined;
    value: number;
    time: string | undefined;
}

export class KeyParamTableDataDtoPagedResultDto implements IKeyParamTableDataDtoPagedResultDto {
    items!: KeyParamTableDataDto[] | undefined;
    totalCount!: number;

    constructor(data?: IKeyParamTableDataDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KeyParamTableDataDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KeyParamTableDataDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyParamTableDataDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IKeyParamTableDataDtoPagedResultDto {
    items: KeyParamTableDataDto[] | undefined;
    totalCount: number;
}

export class KeyParameterAnalysisInputDto implements IKeyParameterAnalysisInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    vehicleId!: string;
    vehicleName!: string | undefined;
    keyParameterCodes!: string[] | undefined;
    keyParameterDisplayTexts!: string[] | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    interval!: number;

    constructor(data?: IKeyParameterAnalysisInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.vehicleId = _data["vehicleId"];
            this.vehicleName = _data["vehicleName"];
            if (Array.isArray(_data["keyParameterCodes"])) {
                this.keyParameterCodes = [] as any;
                for (let item of _data["keyParameterCodes"])
                    this.keyParameterCodes!.push(item);
            }
            if (Array.isArray(_data["keyParameterDisplayTexts"])) {
                this.keyParameterDisplayTexts = [] as any;
                for (let item of _data["keyParameterDisplayTexts"])
                    this.keyParameterDisplayTexts!.push(item);
            }
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.interval = _data["interval"];
        }
    }

    static fromJS(data: any): KeyParameterAnalysisInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyParameterAnalysisInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["vehicleId"] = this.vehicleId;
        data["vehicleName"] = this.vehicleName;
        if (Array.isArray(this.keyParameterCodes)) {
            data["keyParameterCodes"] = [];
            for (let item of this.keyParameterCodes)
                data["keyParameterCodes"].push(item);
        }
        if (Array.isArray(this.keyParameterDisplayTexts)) {
            data["keyParameterDisplayTexts"] = [];
            for (let item of this.keyParameterDisplayTexts)
                data["keyParameterDisplayTexts"].push(item);
        }
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["interval"] = this.interval;
        return data;
    }
}

export interface IKeyParameterAnalysisInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    vehicleId: string;
    vehicleName: string | undefined;
    keyParameterCodes: string[] | undefined;
    keyParameterDisplayTexts: string[] | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    interval: number;
}

export class LabelValueDto implements ILabelValueDto {
    label!: string | undefined;
    value!: string | undefined;

    constructor(data?: ILabelValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LabelValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabelValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ILabelValueDto {
    label: string | undefined;
    value: string | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    cultureName!: string | undefined;
    uiCultureName!: string | undefined;
    displayName!: string | undefined;
    readonly twoLetterISOLanguageName!: string | undefined;
    flagIcon!: string | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            (<any>this).twoLetterISOLanguageName = _data["twoLetterISOLanguageName"];
            this.flagIcon = _data["flagIcon"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["flagIcon"] = this.flagIcon;
        return data;
    }
}

export interface ILanguageInfo {
    cultureName: string | undefined;
    uiCultureName: string | undefined;
    displayName: string | undefined;
    twoLetterISOLanguageName: string | undefined;
    flagIcon: string | undefined;
}

export class ListDeviceTelemetryInputDto implements IListDeviceTelemetryInputDto {
    deviceId!: string;
    filter!: string | undefined;

    constructor(data?: IListDeviceTelemetryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): ListDeviceTelemetryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListDeviceTelemetryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IListDeviceTelemetryInputDto {
    deviceId: string;
    filter: string | undefined;
}

export class ListTelemetryChartDataInputDto implements IListTelemetryChartDataInputDto {
    deviceId!: string;
    keyName!: string | undefined;
    queryCount!: number;

    constructor(data?: IListTelemetryChartDataInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.keyName = _data["keyName"];
            this.queryCount = _data["queryCount"];
        }
    }

    static fromJS(data: any): ListTelemetryChartDataInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListTelemetryChartDataInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["keyName"] = this.keyName;
        data["queryCount"] = this.queryCount;
        return data;
    }
}

export interface IListTelemetryChartDataInputDto {
    deviceId: string;
    keyName: string | undefined;
    queryCount: number;
}

export class LocalizableStringDto implements ILocalizableStringDto {
    name!: string | undefined;
    resource!: string | undefined;

    constructor(data?: ILocalizableStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.resource = _data["resource"];
        }
    }

    static fromJS(data: any): LocalizableStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["resource"] = this.resource;
        return data;
    }
}

export interface ILocalizableStringDto {
    name: string | undefined;
    resource: string | undefined;
}

export class LockUserInput implements ILockUserInput {
    userId!: string;
    locked!: boolean;

    constructor(data?: ILockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.locked = _data["locked"];
        }
    }

    static fromJS(data: any): LockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["locked"] = this.locked;
        return data;
    }
}

export interface ILockUserInput {
    userId: string;
    locked: boolean;
}

export class LoginInput implements ILoginInput {
    name!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILoginInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginInput {
        data = typeof data === 'object' ? data : {};
        let result = new LoginInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginInput {
    name: string | undefined;
    password: string | undefined;
}

export class LoginOutput implements ILoginOutput {
    id!: string;
    name!: string | undefined;
    userName!: string | undefined;
    token!: string | undefined;
    roles!: string[] | undefined;

    constructor(data?: ILoginOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.token = _data["token"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LoginOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["token"] = this.token;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ILoginOutput {
    id: string;
    name: string | undefined;
    userName: string | undefined;
    token: string | undefined;
    roles: string[] | undefined;
}

export enum LoginResultType {
    Success = 1,
    InvalidUserNameOrPassword = 2,
    NotAllowed = 3,
    LockedOut = 4,
    RequiresTwoFactor = 5,
}

export class MapDataDto implements IMapDataDto {
    product!: string[] | undefined;
    colors!: string[] | undefined;
    categoryData!: { [key: string]: NameValue[]; } | undefined;
    topData!: { [key: string]: DoubleListNameValue[]; } | undefined;

    constructor(data?: IMapDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["product"])) {
                this.product = [] as any;
                for (let item of _data["product"])
                    this.product!.push(item);
            }
            if (Array.isArray(_data["colors"])) {
                this.colors = [] as any;
                for (let item of _data["colors"])
                    this.colors!.push(item);
            }
            if (_data["categoryData"]) {
                this.categoryData = {} as any;
                for (let key in _data["categoryData"]) {
                    if (_data["categoryData"].hasOwnProperty(key))
                        (<any>this.categoryData)![key] = _data["categoryData"][key] ? _data["categoryData"][key].map((i: any) => NameValue.fromJS(i)) : <any>undefined;
                }
            }
            if (_data["topData"]) {
                this.topData = {} as any;
                for (let key in _data["topData"]) {
                    if (_data["topData"].hasOwnProperty(key))
                        (<any>this.topData)![key] = _data["topData"][key] ? _data["topData"][key].map((i: any) => DoubleListNameValue.fromJS(i)) : <any>undefined;
                }
            }
        }
    }

    static fromJS(data: any): MapDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.product)) {
            data["product"] = [];
            for (let item of this.product)
                data["product"].push(item);
        }
        if (Array.isArray(this.colors)) {
            data["colors"] = [];
            for (let item of this.colors)
                data["colors"].push(item);
        }
        if (this.categoryData) {
            data["categoryData"] = {};
            for (let key in this.categoryData) {
                if (this.categoryData.hasOwnProperty(key))
                    (<any>data["categoryData"])[key] = (<any>this.categoryData)[key];
            }
        }
        if (this.topData) {
            data["topData"] = {};
            for (let key in this.topData) {
                if (this.topData.hasOwnProperty(key))
                    (<any>data["topData"])[key] = (<any>this.topData)[key];
            }
        }
        return data;
    }
}

export interface IMapDataDto {
    product: string[] | undefined;
    colors: string[] | undefined;
    categoryData: { [key: string]: NameValue[]; } | undefined;
    topData: { [key: string]: DoubleListNameValue[]; } | undefined;
}

export class MappingTelemetryInputDto implements IMappingTelemetryInputDto {
    telemetryIds!: string[] | undefined;
    dictionaryId!: string;
    detailis!: LabelValueDto[] | undefined;

    constructor(data?: IMappingTelemetryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["telemetryIds"])) {
                this.telemetryIds = [] as any;
                for (let item of _data["telemetryIds"])
                    this.telemetryIds!.push(item);
            }
            this.dictionaryId = _data["dictionaryId"];
            if (Array.isArray(_data["detailis"])) {
                this.detailis = [] as any;
                for (let item of _data["detailis"])
                    this.detailis!.push(LabelValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MappingTelemetryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MappingTelemetryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.telemetryIds)) {
            data["telemetryIds"] = [];
            for (let item of this.telemetryIds)
                data["telemetryIds"].push(item);
        }
        data["dictionaryId"] = this.dictionaryId;
        if (Array.isArray(this.detailis)) {
            data["detailis"] = [];
            for (let item of this.detailis)
                data["detailis"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMappingTelemetryInputDto {
    telemetryIds: string[] | undefined;
    dictionaryId: string;
    detailis: LabelValueDto[] | undefined;
}

export enum MessageLevel {
    Warning = 10,
    Information = 20,
    Error = 30,
}

export enum MessageType {
    BroadCast = 10,
    Common = 20,
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
    name!: string | undefined;
    typeAsString!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;

    constructor(data?: IMethodParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeAsString = _data["typeAsString"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): MethodParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new MethodParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeAsString"] = this.typeAsString;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IMethodParameterApiDescriptionModel {
    name: string | undefined;
    typeAsString: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
    rootPath!: string | undefined;
    remoteServiceName!: string | undefined;
    controllers!: { [key: string]: ControllerApiDescriptionModel; } | undefined;

    constructor(data?: IModuleApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"];
            this.remoteServiceName = _data["remoteServiceName"];
            if (_data["controllers"]) {
                this.controllers = {} as any;
                for (let key in _data["controllers"]) {
                    if (_data["controllers"].hasOwnProperty(key))
                        (<any>this.controllers)![key] = _data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(_data["controllers"][key]) : new ControllerApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ModuleApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath;
        data["remoteServiceName"] = this.remoteServiceName;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    (<any>data["controllers"])[key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IModuleApiDescriptionModel {
    rootPath: string | undefined;
    remoteServiceName: string | undefined;
    controllers: { [key: string]: ControllerApiDescriptionModel; } | undefined;
}

export class ModuleExtensionDto implements IModuleExtensionDto {
    entities!: { [key: string]: EntityExtensionDto; } | undefined;
    configuration!: { [key: string]: any; } | undefined;

    constructor(data?: IModuleExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["entities"]) {
                this.entities = {} as any;
                for (let key in _data["entities"]) {
                    if (_data["entities"].hasOwnProperty(key))
                        (<any>this.entities)![key] = _data["entities"][key] ? EntityExtensionDto.fromJS(_data["entities"][key]) : new EntityExtensionDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ModuleExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entities) {
            data["entities"] = {};
            for (let key in this.entities) {
                if (this.entities.hasOwnProperty(key))
                    (<any>data["entities"])[key] = this.entities[key] ? this.entities[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IModuleExtensionDto {
    entities: { [key: string]: EntityExtensionDto; } | undefined;
    configuration: { [key: string]: any; } | undefined;
}

export class MongoConnectLog implements IMongoConnectLog {
    /** 主键Id */
    id!: string | undefined;
    vehicleId!: string;
    vehicleName!: string | undefined;
    time!: string | undefined;
    timeDisplay!: string | undefined;
    status!: VehicleStatus;
    statusDisplay!: string | undefined;

    constructor(data?: IMongoConnectLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleId = _data["vehicleId"];
            this.vehicleName = _data["vehicleName"];
            this.time = _data["time"];
            this.timeDisplay = _data["timeDisplay"];
            this.status = _data["status"];
            this.statusDisplay = _data["statusDisplay"];
        }
    }

    static fromJS(data: any): MongoConnectLog {
        data = typeof data === 'object' ? data : {};
        let result = new MongoConnectLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleId"] = this.vehicleId;
        data["vehicleName"] = this.vehicleName;
        data["time"] = this.time;
        data["timeDisplay"] = this.timeDisplay;
        data["status"] = this.status;
        data["statusDisplay"] = this.statusDisplay;
        return data;
    }
}

export interface IMongoConnectLog {
    /** 主键Id */
    id: string | undefined;
    vehicleId: string;
    vehicleName: string | undefined;
    time: string | undefined;
    timeDisplay: string | undefined;
    status: VehicleStatus;
    statusDisplay: string | undefined;
}

export class MonthTimeDto implements IMonthTimeDto {
    machineNameList!: string[] | undefined;
    runTimeList!: number[] | undefined;
    powerTimeList!: number[] | undefined;

    constructor(data?: IMonthTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["machineNameList"])) {
                this.machineNameList = [] as any;
                for (let item of _data["machineNameList"])
                    this.machineNameList!.push(item);
            }
            if (Array.isArray(_data["runTimeList"])) {
                this.runTimeList = [] as any;
                for (let item of _data["runTimeList"])
                    this.runTimeList!.push(item);
            }
            if (Array.isArray(_data["powerTimeList"])) {
                this.powerTimeList = [] as any;
                for (let item of _data["powerTimeList"])
                    this.powerTimeList!.push(item);
            }
        }
    }

    static fromJS(data: any): MonthTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MonthTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.machineNameList)) {
            data["machineNameList"] = [];
            for (let item of this.machineNameList)
                data["machineNameList"].push(item);
        }
        if (Array.isArray(this.runTimeList)) {
            data["runTimeList"] = [];
            for (let item of this.runTimeList)
                data["runTimeList"].push(item);
        }
        if (Array.isArray(this.powerTimeList)) {
            data["powerTimeList"] = [];
            for (let item of this.powerTimeList)
                data["powerTimeList"].push(item);
        }
        return data;
    }
}

export interface IMonthTimeDto {
    machineNameList: string[] | undefined;
    runTimeList: number[] | undefined;
    powerTimeList: number[] | undefined;
}

export enum MountTarget {
    Device = "Device",
    Telemetry = "Telemetry",
}

export class MultiTenancyInfoDto implements IMultiTenancyInfoDto {
    isEnabled!: boolean;

    constructor(data?: IMultiTenancyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): MultiTenancyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IMultiTenancyInfoDto {
    isEnabled: boolean;
}

export class NameIdDto implements INameIdDto {
    name!: string | undefined;
    id!: string;

    constructor(data?: INameIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NameIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface INameIdDto {
    name: string | undefined;
    id: string;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class NoCustomerUserDto implements INoCustomerUserDto {
    id!: string;
    userName!: string | undefined;
    name!: string | undefined;

    constructor(data?: INoCustomerUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NoCustomerUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoCustomerUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        return data;
    }
}

export interface INoCustomerUserDto {
    id: string;
    userName: string | undefined;
    name: string | undefined;
}

export class NoCustomerUserDtoPagedResultDto implements INoCustomerUserDtoPagedResultDto {
    items!: NoCustomerUserDto[] | undefined;
    totalCount!: number;

    constructor(data?: INoCustomerUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NoCustomerUserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NoCustomerUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoCustomerUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface INoCustomerUserDtoPagedResultDto {
    items: NoCustomerUserDto[] | undefined;
    totalCount: number;
}

export class NoCustomerVehicleDto implements INoCustomerVehicleDto {
    id!: string;
    vehicleCode!: string | undefined;
    vehicleName!: string | undefined;

    constructor(data?: INoCustomerVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleCode = _data["vehicleCode"];
            this.vehicleName = _data["vehicleName"];
        }
    }

    static fromJS(data: any): NoCustomerVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoCustomerVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleCode"] = this.vehicleCode;
        data["vehicleName"] = this.vehicleName;
        return data;
    }
}

export interface INoCustomerVehicleDto {
    id: string;
    vehicleCode: string | undefined;
    vehicleName: string | undefined;
}

export class NoCustomerVehicleDtoPagedResultDto implements INoCustomerVehicleDtoPagedResultDto {
    items!: NoCustomerVehicleDto[] | undefined;
    totalCount!: number;

    constructor(data?: INoCustomerVehicleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NoCustomerVehicleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NoCustomerVehicleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoCustomerVehicleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface INoCustomerVehicleDtoPagedResultDto {
    items: NoCustomerVehicleDto[] | undefined;
    totalCount: number;
}

export enum NoticeType {
    Site = "Site",
    Email = "Email",
    Sms = "Sms",
}

export class ObjectExtensionsDto implements IObjectExtensionsDto {
    modules!: { [key: string]: ModuleExtensionDto; } | undefined;
    enums!: { [key: string]: ExtensionEnumDto; } | undefined;

    constructor(data?: IObjectExtensionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleExtensionDto.fromJS(_data["modules"][key]) : new ModuleExtensionDto();
                }
            }
            if (_data["enums"]) {
                this.enums = {} as any;
                for (let key in _data["enums"]) {
                    if (_data["enums"].hasOwnProperty(key))
                        (<any>this.enums)![key] = _data["enums"][key] ? ExtensionEnumDto.fromJS(_data["enums"][key]) : new ExtensionEnumDto();
                }
            }
        }
    }

    static fromJS(data: any): ObjectExtensionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectExtensionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.enums) {
            data["enums"] = {};
            for (let key in this.enums) {
                if (this.enums.hasOwnProperty(key))
                    (<any>data["enums"])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IObjectExtensionsDto {
    modules: { [key: string]: ModuleExtensionDto; } | undefined;
    enums: { [key: string]: ExtensionEnumDto; } | undefined;
}

export class PageAlarmInputDto implements IPageAlarmInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    deviceId!: string | undefined;
    alarmText!: string | undefined;
    startTimeBegin!: string | undefined;
    startTimeEnd!: string | undefined;
    endTimeBegin!: string | undefined;
    endTimeEnd!: string | undefined;
    duration!: number;
    alarmStatus!: number;
    severity!: number;
    telemetryId!: string | undefined;

    constructor(data?: IPageAlarmInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.deviceId = _data["deviceId"];
            this.alarmText = _data["alarmText"];
            this.startTimeBegin = _data["startTimeBegin"];
            this.startTimeEnd = _data["startTimeEnd"];
            this.endTimeBegin = _data["endTimeBegin"];
            this.endTimeEnd = _data["endTimeEnd"];
            this.duration = _data["duration"];
            this.alarmStatus = _data["alarmStatus"];
            this.severity = _data["severity"];
            this.telemetryId = _data["telemetryId"];
        }
    }

    static fromJS(data: any): PageAlarmInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageAlarmInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["deviceId"] = this.deviceId;
        data["alarmText"] = this.alarmText;
        data["startTimeBegin"] = this.startTimeBegin;
        data["startTimeEnd"] = this.startTimeEnd;
        data["endTimeBegin"] = this.endTimeBegin;
        data["endTimeEnd"] = this.endTimeEnd;
        data["duration"] = this.duration;
        data["alarmStatus"] = this.alarmStatus;
        data["severity"] = this.severity;
        data["telemetryId"] = this.telemetryId;
        return data;
    }
}

export interface IPageAlarmInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    deviceId: string | undefined;
    alarmText: string | undefined;
    startTimeBegin: string | undefined;
    startTimeEnd: string | undefined;
    endTimeBegin: string | undefined;
    endTimeEnd: string | undefined;
    duration: number;
    alarmStatus: number;
    severity: number;
    telemetryId: string | undefined;
}

export class PageAlarmNotifyInputDto implements IPageAlarmNotifyInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    noticeType!: NoticeType;
    alarmRuleId!: string;

    constructor(data?: IPageAlarmNotifyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.noticeType = _data["noticeType"];
            this.alarmRuleId = _data["alarmRuleId"];
        }
    }

    static fromJS(data: any): PageAlarmNotifyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageAlarmNotifyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["noticeType"] = this.noticeType;
        data["alarmRuleId"] = this.alarmRuleId;
        return data;
    }
}

export interface IPageAlarmNotifyInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    noticeType: NoticeType;
    alarmRuleId: string;
}

export class PageAlarmRuleInputDto implements IPageAlarmRuleInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    deviceId!: string | undefined;
    telemetryId!: string | undefined;
    displayText!: string | undefined;
    filter!: string | undefined;

    constructor(data?: IPageAlarmRuleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.deviceId = _data["deviceId"];
            this.telemetryId = _data["telemetryId"];
            this.displayText = _data["displayText"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageAlarmRuleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageAlarmRuleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["deviceId"] = this.deviceId;
        data["telemetryId"] = this.telemetryId;
        data["displayText"] = this.displayText;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageAlarmRuleInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    deviceId: string | undefined;
    telemetryId: string | undefined;
    displayText: string | undefined;
    filter: string | undefined;
}

export class PageCustomerInputDto implements IPageCustomerInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPageCustomerInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageCustomerInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageCustomerInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageCustomerInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PageCustomerUserInputDto implements IPageCustomerUserInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    customerId!: string;

    constructor(data?: IPageCustomerUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): PageCustomerUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageCustomerUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IPageCustomerUserInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    customerId: string;
}

export class PageCustomerVehicleInputDto implements IPageCustomerVehicleInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    customerId!: string;

    constructor(data?: IPageCustomerVehicleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.customerId = _data["customerId"];
        }
    }

    static fromJS(data: any): PageCustomerVehicleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageCustomerVehicleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["customerId"] = this.customerId;
        return data;
    }
}

export interface IPageCustomerVehicleInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    customerId: string;
}

export class PageDeviceInputDto implements IPageDeviceInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPageDeviceInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageDeviceInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageDeviceInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageDeviceInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PageLanguageInput implements IPageLanguageInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPageLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new PageLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageLanguageInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PageLanguageOutput implements IPageLanguageOutput {
    id!: string;
    cultureName!: string | undefined;
    uiCultureName!: string | undefined;
    displayName!: string | undefined;
    flagIcon!: string | undefined;
    isEnabled!: boolean;
    creationTime!: dayjs.Dayjs;
    isDefault!: boolean;

    constructor(data?: IPageLanguageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
            this.creationTime = _data["creationTime"] ? dayjs(_data["creationTime"].toString()) : <any>undefined;
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): PageLanguageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PageLanguageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        data["creationTime"] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IPageLanguageOutput {
    id: string;
    cultureName: string | undefined;
    uiCultureName: string | undefined;
    displayName: string | undefined;
    flagIcon: string | undefined;
    isEnabled: boolean;
    creationTime: dayjs.Dayjs;
    isDefault: boolean;
}

export class PageLanguageOutputPagedResultDto implements IPageLanguageOutputPagedResultDto {
    items!: PageLanguageOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IPageLanguageOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PageLanguageOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PageLanguageOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageLanguageOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPageLanguageOutputPagedResultDto {
    items: PageLanguageOutput[] | undefined;
    totalCount: number;
}

export class PageLanguageTextInput implements IPageLanguageTextInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    cultureName!: string | undefined;
    resourceName!: string | undefined;
    filter!: string | undefined;

    constructor(data?: IPageLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.cultureName = _data["cultureName"];
            this.resourceName = _data["resourceName"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new PageLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["cultureName"] = this.cultureName;
        data["resourceName"] = this.resourceName;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageLanguageTextInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    cultureName: string | undefined;
    resourceName: string | undefined;
    filter: string | undefined;
}

export class PageLanguageTextOutput implements IPageLanguageTextOutput {
    resourceName!: string | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: IPageLanguageTextOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceName = _data["resourceName"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PageLanguageTextOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PageLanguageTextOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceName"] = this.resourceName;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IPageLanguageTextOutput {
    resourceName: string | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class PageLanguageTextOutputPagedResultDto implements IPageLanguageTextOutputPagedResultDto {
    items!: PageLanguageTextOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IPageLanguageTextOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PageLanguageTextOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PageLanguageTextOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageLanguageTextOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPageLanguageTextOutputPagedResultDto {
    items: PageLanguageTextOutput[] | undefined;
    totalCount: number;
}

export class PageProductInputDto implements IPageProductInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPageProductInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageProductInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageProductInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageProductInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PageProtocolDetailInputDto implements IPageProtocolDetailInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    headId!: string;
    signalName!: string | undefined;
    comment!: string | undefined;

    constructor(data?: IPageProtocolDetailInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.headId = _data["headId"];
            this.signalName = _data["signalName"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): PageProtocolDetailInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageProtocolDetailInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["headId"] = this.headId;
        data["signalName"] = this.signalName;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IPageProtocolDetailInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    headId: string;
    signalName: string | undefined;
    comment: string | undefined;
}

export class PageProtocolHeadInputDto implements IPageProtocolHeadInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    protocolId!: string;
    msgId!: string | undefined;

    constructor(data?: IPageProtocolHeadInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.protocolId = _data["protocolId"];
            this.msgId = _data["msgId"];
        }
    }

    static fromJS(data: any): PageProtocolHeadInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageProtocolHeadInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["protocolId"] = this.protocolId;
        data["msgId"] = this.msgId;
        return data;
    }
}

export interface IPageProtocolHeadInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    protocolId: string;
    msgId: string | undefined;
}

export class PageRuleInputDto implements IPageRuleInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPageRuleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageRuleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageRuleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageRuleInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PageRuleLogInputDto implements IPageRuleLogInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    ruleId!: string;
    deviceId!: string;
    startTime!: dayjs.Dayjs | undefined;
    endTime!: dayjs.Dayjs | undefined;

    constructor(data?: IPageRuleLogInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.ruleId = _data["ruleId"];
            this.deviceId = _data["deviceId"];
            this.startTime = _data["startTime"] ? dayjs(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? dayjs(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PageRuleLogInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageRuleLogInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["ruleId"] = this.ruleId;
        data["deviceId"] = this.deviceId;
        data["startTime"] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toLocaleString() : <any>undefined;
        return data;
    }
}

export interface IPageRuleLogInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    ruleId: string;
    deviceId: string;
    startTime: dayjs.Dayjs | undefined;
    endTime: dayjs.Dayjs | undefined;
}

export class PageTelemetryHistoryInputDto implements IPageTelemetryHistoryInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    deviceId!: string;
    deviceName!: string | undefined;
    telemetry!: string | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    timeInterval!: number;
    interval!: number;

    constructor(data?: IPageTelemetryHistoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.telemetry = _data["telemetry"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.timeInterval = _data["timeInterval"];
            this.interval = _data["interval"];
        }
    }

    static fromJS(data: any): PageTelemetryHistoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageTelemetryHistoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["telemetry"] = this.telemetry;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["timeInterval"] = this.timeInterval;
        data["interval"] = this.interval;
        return data;
    }
}

export interface IPageTelemetryHistoryInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    deviceId: string;
    deviceName: string | undefined;
    telemetry: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    timeInterval: number;
    interval: number;
}

export class PageVehicleInputDto implements IPageVehicleInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPageVehicleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PageVehicleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageVehicleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPageVehicleInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PageVehicleOnlineAndOfflineRecordInputDto implements IPageVehicleOnlineAndOfflineRecordInputDto {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    vehicleId!: string | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    status!: VehicleStatus;

    constructor(data?: IPageVehicleOnlineAndOfflineRecordInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.vehicleId = _data["vehicleId"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PageVehicleOnlineAndOfflineRecordInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageVehicleOnlineAndOfflineRecordInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["vehicleId"] = this.vehicleId;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["status"] = this.status;
        return data;
    }
}

export interface IPageVehicleOnlineAndOfflineRecordInputDto {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    vehicleId: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    status: VehicleStatus;
}

export class PagingAuditLogActionOutput implements IPagingAuditLogActionOutput {
    id!: string;
    tenantId!: string | undefined;
    auditLogId!: string;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: string | undefined;
    executionDuration!: number;
    extraProperties!: { [key: string]: any; } | undefined;

    constructor(data?: IPagingAuditLogActionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.auditLogId = _data["auditLogId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"];
            this.executionDuration = _data["executionDuration"];
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PagingAuditLogActionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingAuditLogActionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["auditLogId"] = this.auditLogId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime;
        data["executionDuration"] = this.executionDuration;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IPagingAuditLogActionOutput {
    id: string;
    tenantId: string | undefined;
    auditLogId: string;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: string | undefined;
    executionDuration: number;
    extraProperties: { [key: string]: any; } | undefined;
}

export class PagingAuditLogInput implements IPagingAuditLogInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    sorting!: string | undefined;
    startTime!: dayjs.Dayjs | undefined;
    endTime!: dayjs.Dayjs | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;
    applicationName!: string | undefined;
    correlationId!: string | undefined;
    maxExecutionDuration!: number | undefined;
    minExecutionDuration!: number | undefined;
    hasException!: boolean | undefined;
    httpStatusCode!: HttpStatusCode;
    clientIpAddress!: string | undefined;

    constructor(data?: IPagingAuditLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            this.startTime = _data["startTime"] ? dayjs(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? dayjs(_data["endTime"].toString()) : <any>undefined;
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.applicationName = _data["applicationName"];
            this.correlationId = _data["correlationId"];
            this.maxExecutionDuration = _data["maxExecutionDuration"];
            this.minExecutionDuration = _data["minExecutionDuration"];
            this.hasException = _data["hasException"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.clientIpAddress = _data["clientIpAddress"];
        }
    }

    static fromJS(data: any): PagingAuditLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingAuditLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        data["startTime"] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toLocaleString() : <any>undefined;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["applicationName"] = this.applicationName;
        data["correlationId"] = this.correlationId;
        data["maxExecutionDuration"] = this.maxExecutionDuration;
        data["minExecutionDuration"] = this.minExecutionDuration;
        data["hasException"] = this.hasException;
        data["httpStatusCode"] = this.httpStatusCode;
        data["clientIpAddress"] = this.clientIpAddress;
        return data;
    }
}

export interface IPagingAuditLogInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    sorting: string | undefined;
    startTime: dayjs.Dayjs | undefined;
    endTime: dayjs.Dayjs | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
    applicationName: string | undefined;
    correlationId: string | undefined;
    maxExecutionDuration: number | undefined;
    minExecutionDuration: number | undefined;
    hasException: boolean | undefined;
    httpStatusCode: HttpStatusCode;
    clientIpAddress: string | undefined;
}

export class PagingAuditLogOutput implements IPagingAuditLogOutput {
    applicationName!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;
    tenantId!: string | undefined;
    tenantName!: string | undefined;
    impersonatorUserId!: string | undefined;
    impersonatorTenantId!: string | undefined;
    executionTime!: string | undefined;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    clientId!: string | undefined;
    correlationId!: string | undefined;
    browserInfo!: string | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    exceptions!: string | undefined;
    comments!: string | undefined;
    httpStatusCode!: number | undefined;
    entityChanges!: PagingEntityChangeOutput[] | undefined;
    actions!: PagingAuditLogActionOutput[] | undefined;

    constructor(data?: IPagingAuditLogOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationName = _data["applicationName"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.executionTime = _data["executionTime"];
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.clientId = _data["clientId"];
            this.correlationId = _data["correlationId"];
            this.browserInfo = _data["browserInfo"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            this.exceptions = _data["exceptions"];
            this.comments = _data["comments"];
            this.httpStatusCode = _data["httpStatusCode"];
            if (Array.isArray(_data["entityChanges"])) {
                this.entityChanges = [] as any;
                for (let item of _data["entityChanges"])
                    this.entityChanges!.push(PagingEntityChangeOutput.fromJS(item));
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(PagingAuditLogActionOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagingAuditLogOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingAuditLogOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationName"] = this.applicationName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["executionTime"] = this.executionTime;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["clientId"] = this.clientId;
        data["correlationId"] = this.correlationId;
        data["browserInfo"] = this.browserInfo;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        data["exceptions"] = this.exceptions;
        data["comments"] = this.comments;
        data["httpStatusCode"] = this.httpStatusCode;
        if (Array.isArray(this.entityChanges)) {
            data["entityChanges"] = [];
            for (let item of this.entityChanges)
                data["entityChanges"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagingAuditLogOutput {
    applicationName: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
    tenantId: string | undefined;
    tenantName: string | undefined;
    impersonatorUserId: string | undefined;
    impersonatorTenantId: string | undefined;
    executionTime: string | undefined;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    clientId: string | undefined;
    correlationId: string | undefined;
    browserInfo: string | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    exceptions: string | undefined;
    comments: string | undefined;
    httpStatusCode: number | undefined;
    entityChanges: PagingEntityChangeOutput[] | undefined;
    actions: PagingAuditLogActionOutput[] | undefined;
}

export class PagingAuditLogOutputPagedResultDto implements IPagingAuditLogOutputPagedResultDto {
    items!: PagingAuditLogOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IPagingAuditLogOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PagingAuditLogOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagingAuditLogOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagingAuditLogOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagingAuditLogOutputPagedResultDto {
    items: PagingAuditLogOutput[] | undefined;
    totalCount: number;
}

export class PagingDataDictionaryDetailInput implements IPagingDataDictionaryDetailInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    dataDictionaryId!: string;
    filter!: string | undefined;

    constructor(data?: IPagingDataDictionaryDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.dataDictionaryId = _data["dataDictionaryId"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingDataDictionaryDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDataDictionaryDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["dataDictionaryId"] = this.dataDictionaryId;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingDataDictionaryDetailInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    dataDictionaryId: string;
    filter: string | undefined;
}

export class PagingDataDictionaryDetailOutput implements IPagingDataDictionaryDetailOutput {
    id!: string;
    dataDictionaryId!: string;
    code!: string | undefined;
    order!: number;
    displayText!: string | undefined;
    description!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IPagingDataDictionaryDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataDictionaryId = _data["dataDictionaryId"];
            this.code = _data["code"];
            this.order = _data["order"];
            this.displayText = _data["displayText"];
            this.description = _data["description"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): PagingDataDictionaryDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDataDictionaryDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataDictionaryId"] = this.dataDictionaryId;
        data["code"] = this.code;
        data["order"] = this.order;
        data["displayText"] = this.displayText;
        data["description"] = this.description;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IPagingDataDictionaryDetailOutput {
    id: string;
    dataDictionaryId: string;
    code: string | undefined;
    order: number;
    displayText: string | undefined;
    description: string | undefined;
    isEnabled: boolean;
}

export class PagingDataDictionaryDetailOutputPagedResultDto implements IPagingDataDictionaryDetailOutputPagedResultDto {
    items!: PagingDataDictionaryDetailOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IPagingDataDictionaryDetailOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PagingDataDictionaryDetailOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagingDataDictionaryDetailOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDataDictionaryDetailOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagingDataDictionaryDetailOutputPagedResultDto {
    items: PagingDataDictionaryDetailOutput[] | undefined;
    totalCount: number;
}

export class PagingDataDictionaryInput implements IPagingDataDictionaryInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPagingDataDictionaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingDataDictionaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDataDictionaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingDataDictionaryInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagingDataDictionaryOutput implements IPagingDataDictionaryOutput {
    id!: string;
    code!: string | undefined;
    displayText!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPagingDataDictionaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.displayText = _data["displayText"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PagingDataDictionaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDataDictionaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayText"] = this.displayText;
        data["description"] = this.description;
        return data;
    }
}

export interface IPagingDataDictionaryOutput {
    id: string;
    code: string | undefined;
    displayText: string | undefined;
    description: string | undefined;
}

export class PagingDataDictionaryOutputPagedResultDto implements IPagingDataDictionaryOutputPagedResultDto {
    items!: PagingDataDictionaryOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IPagingDataDictionaryOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PagingDataDictionaryOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagingDataDictionaryOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDataDictionaryOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagingDataDictionaryOutputPagedResultDto {
    items: PagingDataDictionaryOutput[] | undefined;
    totalCount: number;
}

export class PagingEntityChangeOutput implements IPagingEntityChangeOutput {
    id!: string;
    auditLogId!: string;
    tenantId!: string | undefined;
    changeTime!: string | undefined;
    changeType!: EntityChangeType;
    changeTypeDescription!: string | undefined;
    entityTenantId!: string | undefined;
    entityId!: string | undefined;
    entityTypeFullName!: string | undefined;
    propertyChanges!: PagingEntityPropertyChangeOutput[] | undefined;
    extraProperties!: { [key: string]: any; } | undefined;

    constructor(data?: IPagingEntityChangeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditLogId = _data["auditLogId"];
            this.tenantId = _data["tenantId"];
            this.changeTime = _data["changeTime"];
            this.changeType = _data["changeType"];
            this.changeTypeDescription = _data["changeTypeDescription"];
            this.entityTenantId = _data["entityTenantId"];
            this.entityId = _data["entityId"];
            this.entityTypeFullName = _data["entityTypeFullName"];
            if (Array.isArray(_data["propertyChanges"])) {
                this.propertyChanges = [] as any;
                for (let item of _data["propertyChanges"])
                    this.propertyChanges!.push(PagingEntityPropertyChangeOutput.fromJS(item));
            }
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PagingEntityChangeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingEntityChangeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditLogId"] = this.auditLogId;
        data["tenantId"] = this.tenantId;
        data["changeTime"] = this.changeTime;
        data["changeType"] = this.changeType;
        data["changeTypeDescription"] = this.changeTypeDescription;
        data["entityTenantId"] = this.entityTenantId;
        data["entityId"] = this.entityId;
        data["entityTypeFullName"] = this.entityTypeFullName;
        if (Array.isArray(this.propertyChanges)) {
            data["propertyChanges"] = [];
            for (let item of this.propertyChanges)
                data["propertyChanges"].push(item.toJSON());
        }
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IPagingEntityChangeOutput {
    id: string;
    auditLogId: string;
    tenantId: string | undefined;
    changeTime: string | undefined;
    changeType: EntityChangeType;
    changeTypeDescription: string | undefined;
    entityTenantId: string | undefined;
    entityId: string | undefined;
    entityTypeFullName: string | undefined;
    propertyChanges: PagingEntityPropertyChangeOutput[] | undefined;
    extraProperties: { [key: string]: any; } | undefined;
}

export class PagingEntityPropertyChangeOutput implements IPagingEntityPropertyChangeOutput {
    id!: string;
    tenantId!: string | undefined;
    entityChangeId!: string;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;

    constructor(data?: IPagingEntityPropertyChangeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
        }
    }

    static fromJS(data: any): PagingEntityPropertyChangeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingEntityPropertyChangeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        return data;
    }
}

export interface IPagingEntityPropertyChangeOutput {
    id: string;
    tenantId: string | undefined;
    entityChangeId: string;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
}

export class PagingIdentitySecurityLogInput implements IPagingIdentitySecurityLogInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    sorting!: string | undefined;
    startTime!: dayjs.Dayjs | undefined;
    endTime!: dayjs.Dayjs | undefined;
    identity!: string | undefined;
    action!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;
    applicationName!: string | undefined;
    correlationId!: string | undefined;
    clientId!: string | undefined;

    constructor(data?: IPagingIdentitySecurityLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.sorting = _data["sorting"];
            this.startTime = _data["startTime"] ? dayjs(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? dayjs(_data["endTime"].toString()) : <any>undefined;
            this.identity = _data["identity"];
            this.action = _data["action"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.applicationName = _data["applicationName"];
            this.correlationId = _data["correlationId"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): PagingIdentitySecurityLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingIdentitySecurityLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["sorting"] = this.sorting;
        data["startTime"] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toLocaleString() : <any>undefined;
        data["identity"] = this.identity;
        data["action"] = this.action;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["applicationName"] = this.applicationName;
        data["correlationId"] = this.correlationId;
        data["clientId"] = this.clientId;
        return data;
    }
}

export interface IPagingIdentitySecurityLogInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    sorting: string | undefined;
    startTime: dayjs.Dayjs | undefined;
    endTime: dayjs.Dayjs | undefined;
    identity: string | undefined;
    action: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
    applicationName: string | undefined;
    correlationId: string | undefined;
    clientId: string | undefined;
}

export class PagingIdentitySecurityLogOutput implements IPagingIdentitySecurityLogOutput {
    id!: string;
    tenantId!: string | undefined;
    applicationName!: string | undefined;
    identity!: string | undefined;
    action!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;
    tenantName!: string | undefined;
    clientId!: string | undefined;
    correlationId!: string | undefined;
    clientIpAddress!: string | undefined;
    browserInfo!: string | undefined;
    creationTime!: dayjs.Dayjs;

    constructor(data?: IPagingIdentitySecurityLogOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.applicationName = _data["applicationName"];
            this.identity = _data["identity"];
            this.action = _data["action"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tenantName = _data["tenantName"];
            this.clientId = _data["clientId"];
            this.correlationId = _data["correlationId"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.browserInfo = _data["browserInfo"];
            this.creationTime = _data["creationTime"] ? dayjs(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PagingIdentitySecurityLogOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingIdentitySecurityLogOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["applicationName"] = this.applicationName;
        data["identity"] = this.identity;
        data["action"] = this.action;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tenantName"] = this.tenantName;
        data["clientId"] = this.clientId;
        data["correlationId"] = this.correlationId;
        data["clientIpAddress"] = this.clientIpAddress;
        data["browserInfo"] = this.browserInfo;
        data["creationTime"] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
        return data;
    }
}

export interface IPagingIdentitySecurityLogOutput {
    id: string;
    tenantId: string | undefined;
    applicationName: string | undefined;
    identity: string | undefined;
    action: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
    tenantName: string | undefined;
    clientId: string | undefined;
    correlationId: string | undefined;
    clientIpAddress: string | undefined;
    browserInfo: string | undefined;
    creationTime: dayjs.Dayjs;
}

export class PagingIdentitySecurityLogOutputPagedResultDto implements IPagingIdentitySecurityLogOutputPagedResultDto {
    items!: PagingIdentitySecurityLogOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IPagingIdentitySecurityLogOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PagingIdentitySecurityLogOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagingIdentitySecurityLogOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagingIdentitySecurityLogOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagingIdentitySecurityLogOutputPagedResultDto {
    items: PagingIdentitySecurityLogOutput[] | undefined;
    totalCount: number;
}

export class PagingNotificationListInput implements IPagingNotificationListInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;

    constructor(data?: IPagingNotificationListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): PagingNotificationListInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingNotificationListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IPagingNotificationListInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
}

export class PagingNotificationListOutput implements IPagingNotificationListOutput {
    id!: string;
    title!: string | undefined;
    content!: string | undefined;
    messageType!: MessageType;
    readonly messageTypeDescription!: string | undefined;
    messageLevel!: MessageLevel;
    readonly messageLevelDescription!: string | undefined;
    senderId!: string;
    creationTime!: dayjs.Dayjs;
    read!: boolean;

    constructor(data?: IPagingNotificationListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.messageType = _data["messageType"];
            (<any>this).messageTypeDescription = _data["messageTypeDescription"];
            this.messageLevel = _data["messageLevel"];
            (<any>this).messageLevelDescription = _data["messageLevelDescription"];
            this.senderId = _data["senderId"];
            this.creationTime = _data["creationTime"] ? dayjs(_data["creationTime"].toString()) : <any>undefined;
            this.read = _data["read"];
        }
    }

    static fromJS(data: any): PagingNotificationListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingNotificationListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["messageType"] = this.messageType;
        data["messageTypeDescription"] = this.messageTypeDescription;
        data["messageLevel"] = this.messageLevel;
        data["messageLevelDescription"] = this.messageLevelDescription;
        data["senderId"] = this.senderId;
        data["creationTime"] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
        data["read"] = this.read;
        return data;
    }
}

export interface IPagingNotificationListOutput {
    id: string;
    title: string | undefined;
    content: string | undefined;
    messageType: MessageType;
    messageTypeDescription: string | undefined;
    messageLevel: MessageLevel;
    messageLevelDescription: string | undefined;
    senderId: string;
    creationTime: dayjs.Dayjs;
    read: boolean;
}

export class PagingNotificationListOutputPagedResultDto implements IPagingNotificationListOutputPagedResultDto {
    items!: PagingNotificationListOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IPagingNotificationListOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PagingNotificationListOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagingNotificationListOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagingNotificationListOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagingNotificationListOutputPagedResultDto {
    items: PagingNotificationListOutput[] | undefined;
    totalCount: number;
}

export class PagingRoleListInput implements IPagingRoleListInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPagingRoleListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingRoleListInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingRoleListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingRoleListInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagingTenantInput implements IPagingTenantInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPagingTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingTenantInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagingUserListInput implements IPagingUserListInput {
    pageIndex!: number;
    pageSize!: number;
    readonly skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IPagingUserListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            (<any>this).skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): PagingUserListInput {
        data = typeof data === 'object' ? data : {};
        let result = new PagingUserListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IPagingUserListInput {
    pageIndex: number;
    pageSize: number;
    skipCount: number;
    filter: string | undefined;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
    nameOnMethod!: string | undefined;
    name!: string | undefined;
    jsonName!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;
    constraintTypes!: string[] | undefined;
    bindingSourceId!: string | undefined;
    descriptorName!: string | undefined;

    constructor(data?: IParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameOnMethod = _data["nameOnMethod"];
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
            if (Array.isArray(_data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of _data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            this.bindingSourceId = _data["bindingSourceId"];
            this.descriptorName = _data["descriptorName"];
        }
    }

    static fromJS(data: any): ParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod;
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId;
        data["descriptorName"] = this.descriptorName;
        return data;
    }
}

export interface IParameterApiDescriptionModel {
    nameOnMethod: string | undefined;
    name: string | undefined;
    jsonName: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
    constraintTypes: string[] | undefined;
    bindingSourceId: string | undefined;
    descriptorName: string | undefined;
}

export class PermissionOutput implements IPermissionOutput {
    grants!: string[] | undefined;
    allGrants!: string[] | undefined;
    permissions!: PermissionTreeDto[] | undefined;

    constructor(data?: IPermissionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["grants"])) {
                this.grants = [] as any;
                for (let item of _data["grants"])
                    this.grants!.push(item);
            }
            if (Array.isArray(_data["allGrants"])) {
                this.allGrants = [] as any;
                for (let item of _data["allGrants"])
                    this.allGrants!.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionTreeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.grants)) {
            data["grants"] = [];
            for (let item of this.grants)
                data["grants"].push(item);
        }
        if (Array.isArray(this.allGrants)) {
            data["allGrants"] = [];
            for (let item of this.allGrants)
                data["allGrants"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionOutput {
    grants: string[] | undefined;
    allGrants: string[] | undefined;
    permissions: PermissionTreeDto[] | undefined;
}

export class PermissionTreeDto implements IPermissionTreeDto {
    title!: string | undefined;
    key!: string | undefined;
    children!: PermissionTreeDto[] | undefined;

    constructor(data?: IPermissionTreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.key = _data["key"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PermissionTreeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionTreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionTreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["key"] = this.key;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionTreeDto {
    title: string | undefined;
    key: string | undefined;
    children: PermissionTreeDto[] | undefined;
}

export class ProductInputDto implements IProductInputDto {
    id!: string;
    name!: string | undefined;
    deviceType!: DeviceType;
    identityType!: IdentityType;
    timeout!: number;

    constructor(data?: IProductInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.deviceType = _data["deviceType"];
            this.identityType = _data["identityType"];
            this.timeout = _data["timeout"];
        }
    }

    static fromJS(data: any): ProductInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["deviceType"] = this.deviceType;
        data["identityType"] = this.identityType;
        data["timeout"] = this.timeout;
        return data;
    }
}

export interface IProductInputDto {
    id: string;
    name: string | undefined;
    deviceType: DeviceType;
    identityType: IdentityType;
    timeout: number;
}

export class ProductOutputDto implements IProductOutputDto {
    id!: string;
    name!: string | undefined;
    deviceType!: DeviceType;
    identityType!: IdentityType;
    timeout!: number;
    devices!: DeviceOutputDto[] | undefined;
    readonly avatorUrl!: string | undefined;

    constructor(data?: IProductOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.deviceType = _data["deviceType"];
            this.identityType = _data["identityType"];
            this.timeout = _data["timeout"];
            if (Array.isArray(_data["devices"])) {
                this.devices = [] as any;
                for (let item of _data["devices"])
                    this.devices!.push(DeviceOutputDto.fromJS(item));
            }
            (<any>this).avatorUrl = _data["avatorUrl"];
        }
    }

    static fromJS(data: any): ProductOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["deviceType"] = this.deviceType;
        data["identityType"] = this.identityType;
        data["timeout"] = this.timeout;
        if (Array.isArray(this.devices)) {
            data["devices"] = [];
            for (let item of this.devices)
                data["devices"].push(item.toJSON());
        }
        data["avatorUrl"] = this.avatorUrl;
        return data;
    }
}

export interface IProductOutputDto {
    id: string;
    name: string | undefined;
    deviceType: DeviceType;
    identityType: IdentityType;
    timeout: number;
    devices: DeviceOutputDto[] | undefined;
    avatorUrl: string | undefined;
}

export class ProductOutputDtoPagedResultDto implements IProductOutputDtoPagedResultDto {
    items!: ProductOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IProductOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IProductOutputDtoPagedResultDto {
    items: ProductOutputDto[] | undefined;
    totalCount: number;
}

export class PropertyApiDescriptionModel implements IPropertyApiDescriptionModel {
    name!: string | undefined;
    jsonName!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isRequired!: boolean;
    minLength!: number | undefined;
    maxLength!: number | undefined;
    minimum!: string | undefined;
    maximum!: string | undefined;
    regex!: string | undefined;

    constructor(data?: IPropertyApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isRequired = _data["isRequired"];
            this.minLength = _data["minLength"];
            this.maxLength = _data["maxLength"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
            this.regex = _data["regex"];
        }
    }

    static fromJS(data: any): PropertyApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isRequired"] = this.isRequired;
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["regex"] = this.regex;
        return data;
    }
}

export interface IPropertyApiDescriptionModel {
    name: string | undefined;
    jsonName: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isRequired: boolean;
    minLength: number | undefined;
    maxLength: number | undefined;
    minimum: string | undefined;
    maximum: string | undefined;
    regex: string | undefined;
}

export enum PropertyType {
    Attribute = 0,
    Telemetry = 1,
}

export class ProtocolDetailInputDto implements IProtocolDetailInputDto {
    headId!: string;
    id!: string;
    signalName!: string | undefined;
    startBit!: number;
    length!: number;
    factor!: number;
    offset!: number;
    initialValue!: string | undefined;
    unit!: string | undefined;
    min!: number;
    max!: number;
    comment!: string | undefined;
    enable!: boolean;

    constructor(data?: IProtocolDetailInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headId = _data["headId"];
            this.id = _data["id"];
            this.signalName = _data["signalName"];
            this.startBit = _data["startBit"];
            this.length = _data["length"];
            this.factor = _data["factor"];
            this.offset = _data["offset"];
            this.initialValue = _data["initialValue"];
            this.unit = _data["unit"];
            this.min = _data["min"];
            this.max = _data["max"];
            this.comment = _data["comment"];
            this.enable = _data["enable"];
        }
    }

    static fromJS(data: any): ProtocolDetailInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProtocolDetailInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headId"] = this.headId;
        data["id"] = this.id;
        data["signalName"] = this.signalName;
        data["startBit"] = this.startBit;
        data["length"] = this.length;
        data["factor"] = this.factor;
        data["offset"] = this.offset;
        data["initialValue"] = this.initialValue;
        data["unit"] = this.unit;
        data["min"] = this.min;
        data["max"] = this.max;
        data["comment"] = this.comment;
        data["enable"] = this.enable;
        return data;
    }
}

export interface IProtocolDetailInputDto {
    headId: string;
    id: string;
    signalName: string | undefined;
    startBit: number;
    length: number;
    factor: number;
    offset: number;
    initialValue: string | undefined;
    unit: string | undefined;
    min: number;
    max: number;
    comment: string | undefined;
    enable: boolean;
}

export class ProtocolHeadInputDto implements IProtocolHeadInputDto {
    id!: string;
    msgId!: string | undefined;
    msgName!: string | undefined;
    protocolId!: string;
    enable!: boolean;

    constructor(data?: IProtocolHeadInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.msgId = _data["msgId"];
            this.msgName = _data["msgName"];
            this.protocolId = _data["protocolId"];
            this.enable = _data["enable"];
        }
    }

    static fromJS(data: any): ProtocolHeadInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProtocolHeadInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["msgId"] = this.msgId;
        data["msgName"] = this.msgName;
        data["protocolId"] = this.protocolId;
        data["enable"] = this.enable;
        return data;
    }
}

export interface IProtocolHeadInputDto {
    id: string;
    msgId: string | undefined;
    msgName: string | undefined;
    protocolId: string;
    enable: boolean;
}

export class RealTimeAlarmDto implements IRealTimeAlarmDto {
    alarmId!: string;
    title!: string | undefined;
    content!: string | undefined;
    creationTime!: number;
    severity!: SeverityLevel;
    startTime!: dayjs.Dayjs;
    readonly startTimeStr!: string | undefined;
    duration!: number;
    readonly durationMinute!: number;

    constructor(data?: IRealTimeAlarmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alarmId = _data["alarmId"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.creationTime = _data["creationTime"];
            this.severity = _data["severity"];
            this.startTime = _data["startTime"] ? dayjs(_data["startTime"].toString()) : <any>undefined;
            (<any>this).startTimeStr = _data["startTimeStr"];
            this.duration = _data["duration"];
            (<any>this).durationMinute = _data["durationMinute"];
        }
    }

    static fromJS(data: any): RealTimeAlarmDto {
        data = typeof data === 'object' ? data : {};
        let result = new RealTimeAlarmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alarmId"] = this.alarmId;
        data["title"] = this.title;
        data["content"] = this.content;
        data["creationTime"] = this.creationTime;
        data["severity"] = this.severity;
        data["startTime"] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
        data["startTimeStr"] = this.startTimeStr;
        data["duration"] = this.duration;
        data["durationMinute"] = this.durationMinute;
        return data;
    }
}

export interface IRealTimeAlarmDto {
    alarmId: string;
    title: string | undefined;
    content: string | undefined;
    creationTime: number;
    severity: SeverityLevel;
    startTime: dayjs.Dayjs;
    startTimeStr: string | undefined;
    duration: number;
    durationMinute: number;
}

export class RelateDeviceRuleInputDto implements IRelateDeviceRuleInputDto {
    deviceId!: string;
    ruleIdList!: string[] | undefined;

    constructor(data?: IRelateDeviceRuleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["ruleIdList"])) {
                this.ruleIdList = [] as any;
                for (let item of _data["ruleIdList"])
                    this.ruleIdList!.push(item);
            }
        }
    }

    static fromJS(data: any): RelateDeviceRuleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RelateDeviceRuleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.ruleIdList)) {
            data["ruleIdList"] = [];
            for (let item of this.ruleIdList)
                data["ruleIdList"].push(item);
        }
        return data;
    }
}

export interface IRelateDeviceRuleInputDto {
    deviceId: string;
    ruleIdList: string[] | undefined;
}

export class RemoteServiceErrorInfo implements IRemoteServiceErrorInfo {
    code!: string | undefined;
    message!: string | undefined;
    details!: string | undefined;
    data!: { [key: string]: any; } | undefined;
    validationErrors!: RemoteServiceValidationErrorInfo[] | undefined;

    constructor(data?: IRemoteServiceErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RemoteServiceErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRemoteServiceErrorInfo {
    code: string | undefined;
    message: string | undefined;
    details: string | undefined;
    data: { [key: string]: any; } | undefined;
    validationErrors: RemoteServiceValidationErrorInfo[] | undefined;
}

export class RemoteServiceErrorResponse implements IRemoteServiceErrorResponse {
    error!: RemoteServiceErrorInfo;

    constructor(data?: IRemoteServiceErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? RemoteServiceErrorInfo.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RemoteServiceErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemoteServiceErrorResponse {
    error: RemoteServiceErrorInfo;
}

export class RemoteServiceValidationErrorInfo implements IRemoteServiceValidationErrorInfo {
    message!: string | undefined;
    members!: string[] | undefined;

    constructor(data?: IRemoteServiceValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoteServiceValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data;
    }
}

export interface IRemoteServiceValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class RemoveRoleToOrganizationUnitInput implements IRemoveRoleToOrganizationUnitInput {
    roleId!: string;
    organizationUnitId!: string;

    constructor(data?: IRemoveRoleToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RemoveRoleToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveRoleToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRemoveRoleToOrganizationUnitInput {
    roleId: string;
    organizationUnitId: string;
}

export class RemoveUserToOrganizationUnitInput implements IRemoveUserToOrganizationUnitInput {
    userId!: string;
    organizationUnitId!: string;

    constructor(data?: IRemoveUserToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RemoveUserToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveUserToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRemoveUserToOrganizationUnitInput {
    userId: string;
    organizationUnitId: string;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
    type!: string | undefined;
    typeSimple!: string | undefined;

    constructor(data?: IReturnValueApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
        }
    }

    static fromJS(data: any): ReturnValueApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnValueApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        return data;
    }
}

export interface IReturnValueApiDescriptionModel {
    type: string | undefined;
    typeSimple: string | undefined;
}

export class RuleInputDto implements IRuleInputDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    ruleType!: RuleType;
    mountTarget!: MountTarget;
    scriptContent!: string | undefined;
    jsonContent!: string | undefined;

    constructor(data?: IRuleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.ruleType = _data["ruleType"];
            this.mountTarget = _data["mountTarget"];
            this.scriptContent = _data["scriptContent"];
            this.jsonContent = _data["jsonContent"];
        }
    }

    static fromJS(data: any): RuleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["ruleType"] = this.ruleType;
        data["mountTarget"] = this.mountTarget;
        data["scriptContent"] = this.scriptContent;
        data["jsonContent"] = this.jsonContent;
        return data;
    }
}

export interface IRuleInputDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    ruleType: RuleType;
    mountTarget: MountTarget;
    scriptContent: string | undefined;
    jsonContent: string | undefined;
}

export class RuleLogOutputDto implements IRuleLogOutputDto {
    deviceName!: string | undefined;
    startTimeStamp!: number;
    endTimeStamp!: number;
    stepLogs!: string[] | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    result!: boolean;

    constructor(data?: IRuleLogOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceName = _data["deviceName"];
            this.startTimeStamp = _data["startTimeStamp"];
            this.endTimeStamp = _data["endTimeStamp"];
            if (Array.isArray(_data["stepLogs"])) {
                this.stepLogs = [] as any;
                for (let item of _data["stepLogs"])
                    this.stepLogs!.push(item);
            }
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): RuleLogOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleLogOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName;
        data["startTimeStamp"] = this.startTimeStamp;
        data["endTimeStamp"] = this.endTimeStamp;
        if (Array.isArray(this.stepLogs)) {
            data["stepLogs"] = [];
            for (let item of this.stepLogs)
                data["stepLogs"].push(item);
        }
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["result"] = this.result;
        return data;
    }
}

export interface IRuleLogOutputDto {
    deviceName: string | undefined;
    startTimeStamp: number;
    endTimeStamp: number;
    stepLogs: string[] | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    result: boolean;
}

export class RuleLogOutputDtoPagedResultDto implements IRuleLogOutputDtoPagedResultDto {
    items!: RuleLogOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRuleLogOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RuleLogOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RuleLogOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleLogOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IRuleLogOutputDtoPagedResultDto {
    items: RuleLogOutputDto[] | undefined;
    totalCount: number;
}

export class RuleOutputDto implements IRuleOutputDto {
    id!: string;
    name!: string | undefined;
    description!: string | undefined;
    ruleType!: RuleType;
    mountTarget!: MountTarget;
    scriptContent!: string | undefined;
    jsonContent!: string | undefined;

    constructor(data?: IRuleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.ruleType = _data["ruleType"];
            this.mountTarget = _data["mountTarget"];
            this.scriptContent = _data["scriptContent"];
            this.jsonContent = _data["jsonContent"];
        }
    }

    static fromJS(data: any): RuleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["ruleType"] = this.ruleType;
        data["mountTarget"] = this.mountTarget;
        data["scriptContent"] = this.scriptContent;
        data["jsonContent"] = this.jsonContent;
        return data;
    }
}

export interface IRuleOutputDto {
    id: string;
    name: string | undefined;
    description: string | undefined;
    ruleType: RuleType;
    mountTarget: MountTarget;
    scriptContent: string | undefined;
    jsonContent: string | undefined;
}

export class RuleOutputDtoPagedResultDto implements IRuleOutputDtoPagedResultDto {
    items!: RuleOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRuleOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RuleOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RuleOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RuleOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IRuleOutputDtoPagedResultDto {
    items: RuleOutputDto[] | undefined;
    totalCount: number;
}

export enum RuleType {
    DataClean = "DataClean",
    AlarmPublish = "AlarmPublish",
    DataMap = "DataMap",
}

export class RunTotalRecord implements IRunTotalRecord {
    runTime!: number;
    chargeTime!: number;

    constructor(data?: IRunTotalRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runTime = _data["runTime"];
            this.chargeTime = _data["chargeTime"];
        }
    }

    static fromJS(data: any): RunTotalRecord {
        data = typeof data === 'object' ? data : {};
        let result = new RunTotalRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runTime"] = this.runTime;
        data["chargeTime"] = this.chargeTime;
        return data;
    }
}

export interface IRunTotalRecord {
    runTime: number;
    chargeTime: number;
}

export class ScanVehicleCodeDto implements IScanVehicleCodeDto {
    vehicleCode!: string | undefined;

    constructor(data?: IScanVehicleCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleCode = _data["vehicleCode"];
        }
    }

    static fromJS(data: any): ScanVehicleCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScanVehicleCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleCode"] = this.vehicleCode;
        return data;
    }
}

export interface IScanVehicleCodeDto {
    vehicleCode: string | undefined;
}

export class SendBroadCastMessageInput implements ISendBroadCastMessageInput {
    title!: string | undefined;
    content!: string | undefined;

    constructor(data?: ISendBroadCastMessageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): SendBroadCastMessageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendBroadCastMessageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        return data;
    }
}

export interface ISendBroadCastMessageInput {
    title: string | undefined;
    content: string | undefined;
}

export class SendCommonMessageInput implements ISendCommonMessageInput {
    title!: string | undefined;
    content!: string | undefined;
    receiveIds!: string[] | undefined;

    constructor(data?: ISendCommonMessageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
            if (Array.isArray(_data["receiveIds"])) {
                this.receiveIds = [] as any;
                for (let item of _data["receiveIds"])
                    this.receiveIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendCommonMessageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendCommonMessageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        if (Array.isArray(this.receiveIds)) {
            data["receiveIds"] = [];
            for (let item of this.receiveIds)
                data["receiveIds"].push(item);
        }
        return data;
    }
}

export interface ISendCommonMessageInput {
    title: string | undefined;
    content: string | undefined;
    receiveIds: string[] | undefined;
}

export class SetDataDictinaryDetailInput implements ISetDataDictinaryDetailInput {
    dataDictionaryId!: string;
    dataDictionayDetailId!: string;
    isEnabled!: boolean;

    constructor(data?: ISetDataDictinaryDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataDictionaryId = _data["dataDictionaryId"];
            this.dataDictionayDetailId = _data["dataDictionayDetailId"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): SetDataDictinaryDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDataDictinaryDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataDictionaryId"] = this.dataDictionaryId;
        data["dataDictionayDetailId"] = this.dataDictionayDetailId;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface ISetDataDictinaryDetailInput {
    dataDictionaryId: string;
    dataDictionayDetailId: string;
    isEnabled: boolean;
}

export class SetReadInput implements ISetReadInput {
    id!: string;

    constructor(data?: ISetReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SetReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ISetReadInput {
    id: string;
}

export class SettingItemOutput implements ISettingItemOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    value!: string | undefined;
    type!: string | undefined;

    constructor(data?: ISettingItemOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SettingItemOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SettingItemOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["value"] = this.value;
        data["type"] = this.type;
        return data;
    }
}

export interface ISettingItemOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    value: string | undefined;
    type: string | undefined;
}

export class SettingOutput implements ISettingOutput {
    group!: string | undefined;
    groupDisplayName!: string | undefined;
    settingItemOutput!: SettingItemOutput[] | undefined;

    constructor(data?: ISettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            this.groupDisplayName = _data["groupDisplayName"];
            if (Array.isArray(_data["settingItemOutput"])) {
                this.settingItemOutput = [] as any;
                for (let item of _data["settingItemOutput"])
                    this.settingItemOutput!.push(SettingItemOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        data["groupDisplayName"] = this.groupDisplayName;
        if (Array.isArray(this.settingItemOutput)) {
            data["settingItemOutput"] = [];
            for (let item of this.settingItemOutput)
                data["settingItemOutput"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISettingOutput {
    group: string | undefined;
    groupDisplayName: string | undefined;
    settingItemOutput: SettingItemOutput[] | undefined;
}

export enum SeverityLevel {
    Normal = "Normal",
    LightFault = "LightFault",
    MoreSevereFault = "MoreSevereFault",
    MostSevereFault = "MostSevereFault",
    Fault = "Fault",
}

export class StateDto implements IStateDto {
    id!: number;
    name!: string | undefined;
    value!: number;

    constructor(data?: IStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IStateDto {
    id: number;
    name: string | undefined;
    value: number;
}

export class StringNameValue implements IStringNameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: IStringNameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringNameValue {
        data = typeof data === 'object' ? data : {};
        let result = new StringNameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IStringNameValue {
    name: string | undefined;
    value: string | undefined;
}

export class StringStringFromSelector implements IStringStringFromSelector {
    readonly value!: string | undefined;
    readonly label!: string | undefined;

    constructor(data?: IStringStringFromSelector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
            (<any>this).label = _data["label"];
        }
    }

    static fromJS(data: any): StringStringFromSelector {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringFromSelector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        return data;
    }
}

export interface IStringStringFromSelector {
    value: string | undefined;
    label: string | undefined;
}

export class TelemetryChartDataDto implements ITelemetryChartDataDto {
    legend!: string[] | undefined;
    series!: string[] | undefined;
    xDataList!: string[] | undefined;
    yDataList!: number[][] | undefined;

    constructor(data?: ITelemetryChartDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["legend"])) {
                this.legend = [] as any;
                for (let item of _data["legend"])
                    this.legend!.push(item);
            }
            if (Array.isArray(_data["series"])) {
                this.series = [] as any;
                for (let item of _data["series"])
                    this.series!.push(item);
            }
            if (Array.isArray(_data["xDataList"])) {
                this.xDataList = [] as any;
                for (let item of _data["xDataList"])
                    this.xDataList!.push(item);
            }
            if (Array.isArray(_data["yDataList"])) {
                this.yDataList = [] as any;
                for (let item of _data["yDataList"])
                    this.yDataList!.push(item);
            }
        }
    }

    static fromJS(data: any): TelemetryChartDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TelemetryChartDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.legend)) {
            data["legend"] = [];
            for (let item of this.legend)
                data["legend"].push(item);
        }
        if (Array.isArray(this.series)) {
            data["series"] = [];
            for (let item of this.series)
                data["series"].push(item);
        }
        if (Array.isArray(this.xDataList)) {
            data["xDataList"] = [];
            for (let item of this.xDataList)
                data["xDataList"].push(item);
        }
        if (Array.isArray(this.yDataList)) {
            data["yDataList"] = [];
            for (let item of this.yDataList)
                data["yDataList"].push(item);
        }
        return data;
    }
}

export interface ITelemetryChartDataDto {
    legend: string[] | undefined;
    series: string[] | undefined;
    xDataList: string[] | undefined;
    yDataList: number[][] | undefined;
}

export class TelemetryOutputDto implements ITelemetryOutputDto {
    id!: string;
    keyName!: string | undefined;
    description!: string | undefined;
    dataType!: DataType;
    isShow!: boolean;
    isCurve!: boolean;
    /** 分发Id */
    distributedId!: string | undefined;
    distributedDevice!: string | undefined;
    /** 原始Id */
    originalId!: string | undefined;
    originalDevice!: string | undefined;
    mappingObject!: string | undefined;
    expressions!: string | undefined;
    unit!: string | undefined;

    constructor(data?: ITelemetryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyName = _data["keyName"];
            this.description = _data["description"];
            this.dataType = _data["dataType"];
            this.isShow = _data["isShow"];
            this.isCurve = _data["isCurve"];
            this.distributedId = _data["distributedId"];
            this.distributedDevice = _data["distributedDevice"];
            this.originalId = _data["originalId"];
            this.originalDevice = _data["originalDevice"];
            this.mappingObject = _data["mappingObject"];
            this.expressions = _data["expressions"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): TelemetryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TelemetryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyName"] = this.keyName;
        data["description"] = this.description;
        data["dataType"] = this.dataType;
        data["isShow"] = this.isShow;
        data["isCurve"] = this.isCurve;
        data["distributedId"] = this.distributedId;
        data["distributedDevice"] = this.distributedDevice;
        data["originalId"] = this.originalId;
        data["originalDevice"] = this.originalDevice;
        data["mappingObject"] = this.mappingObject;
        data["expressions"] = this.expressions;
        data["unit"] = this.unit;
        return data;
    }
}

export interface ITelemetryOutputDto {
    id: string;
    keyName: string | undefined;
    description: string | undefined;
    dataType: DataType;
    isShow: boolean;
    isCurve: boolean;
    /** 分发Id */
    distributedId: string | undefined;
    distributedDevice: string | undefined;
    /** 原始Id */
    originalId: string | undefined;
    originalDevice: string | undefined;
    mappingObject: string | undefined;
    expressions: string | undefined;
    unit: string | undefined;
}

export class TelmetryHistoryChartDto implements ITelmetryHistoryChartDto {
    xAxisData!: any[] | undefined;
    seriesData!: any[] | undefined;

    constructor(data?: ITelmetryHistoryChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["xAxisData"])) {
                this.xAxisData = [] as any;
                for (let item of _data["xAxisData"])
                    this.xAxisData!.push(item);
            }
            if (Array.isArray(_data["seriesData"])) {
                this.seriesData = [] as any;
                for (let item of _data["seriesData"])
                    this.seriesData!.push(item);
            }
        }
    }

    static fromJS(data: any): TelmetryHistoryChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new TelmetryHistoryChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.xAxisData)) {
            data["xAxisData"] = [];
            for (let item of this.xAxisData)
                data["xAxisData"].push(item);
        }
        if (Array.isArray(this.seriesData)) {
            data["seriesData"] = [];
            for (let item of this.seriesData)
                data["seriesData"].push(item);
        }
        return data;
    }
}

export interface ITelmetryHistoryChartDto {
    xAxisData: any[] | undefined;
    seriesData: any[] | undefined;
}

export class TenantCreateDto implements ITenantCreateDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string;

    constructor(data?: ITenantCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
        }
    }

    static fromJS(data: any): TenantCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        return data;
    }
}

export interface ITenantCreateDto {
    extraProperties: { [key: string]: any; } | undefined;
    name: string;
    adminEmailAddress: string;
    adminPassword: string;
}

export class TenantDto implements ITenantDto {
    readonly extraProperties!: { [key: string]: any; } | undefined;
    id!: string;
    name!: string | undefined;
    concurrencyStamp!: string | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ITenantDto {
    extraProperties: { [key: string]: any; } | undefined;
    id: string;
    name: string | undefined;
    concurrencyStamp: string | undefined;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items!: TenantDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TimeZone implements ITimeZone {
    iana!: IanaTimeZone;
    windows!: WindowsTimeZone;

    constructor(data?: ITimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iana = _data["iana"] ? IanaTimeZone.fromJS(_data["iana"]) : <any>undefined;
            this.windows = _data["windows"] ? WindowsTimeZone.fromJS(_data["windows"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimeZone {
    iana: IanaTimeZone;
    windows: WindowsTimeZone;
}

export class TimingDto implements ITimingDto {
    timeZone!: TimeZone;

    constructor(data?: ITimingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZone = _data["timeZone"] ? TimeZone.fromJS(_data["timeZone"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimingDto {
    timeZone: TimeZone;
}

export class TotalBatteryInfoDto implements ITotalBatteryInfoDto {
    batteryInfos!: BatteryInfoDto[] | undefined;

    constructor(data?: ITotalBatteryInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["batteryInfos"])) {
                this.batteryInfos = [] as any;
                for (let item of _data["batteryInfos"])
                    this.batteryInfos!.push(BatteryInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TotalBatteryInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalBatteryInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.batteryInfos)) {
            data["batteryInfos"] = [];
            for (let item of this.batteryInfos)
                data["batteryInfos"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITotalBatteryInfoDto {
    batteryInfos: BatteryInfoDto[] | undefined;
}

export class TotalStateDto implements ITotalStateDto {
    machineStates!: StateDto[] | undefined;

    constructor(data?: ITotalStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["machineStates"])) {
                this.machineStates = [] as any;
                for (let item of _data["machineStates"])
                    this.machineStates!.push(StateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TotalStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.machineStates)) {
            data["machineStates"] = [];
            for (let item of this.machineStates)
                data["machineStates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITotalStateDto {
    machineStates: StateDto[] | undefined;
}

export class TotalVoltageDto implements ITotalVoltageDto {
    name!: string | undefined;
    /** 总电压 */
    totalVoltage!: number;
    /** 总电流 */
    totalAmmeter!: number;
    voltageList!: VoltageDto[] | undefined;
    max!: VoltageDto;
    min!: VoltageDto;

    constructor(data?: ITotalVoltageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.totalVoltage = _data["totalVoltage"];
            this.totalAmmeter = _data["totalAmmeter"];
            if (Array.isArray(_data["voltageList"])) {
                this.voltageList = [] as any;
                for (let item of _data["voltageList"])
                    this.voltageList!.push(VoltageDto.fromJS(item));
            }
            this.max = _data["max"] ? VoltageDto.fromJS(_data["max"]) : <any>undefined;
            this.min = _data["min"] ? VoltageDto.fromJS(_data["min"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TotalVoltageDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalVoltageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["totalVoltage"] = this.totalVoltage;
        data["totalAmmeter"] = this.totalAmmeter;
        if (Array.isArray(this.voltageList)) {
            data["voltageList"] = [];
            for (let item of this.voltageList)
                data["voltageList"].push(item.toJSON());
        }
        data["max"] = this.max ? this.max.toJSON() : <any>undefined;
        data["min"] = this.min ? this.min.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITotalVoltageDto {
    name: string | undefined;
    /** 总电压 */
    totalVoltage: number;
    /** 总电流 */
    totalAmmeter: number;
    voltageList: VoltageDto[] | undefined;
    max: VoltageDto;
    min: VoltageDto;
}

export class TreeDataDto implements ITreeDataDto {
    title!: string | undefined;
    key!: string | undefined;
    icon!: string | undefined;
    disabled!: boolean;
    isActive!: boolean;
    isAlarm!: boolean;
    children!: TreeDataDto[] | undefined;

    constructor(data?: ITreeDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.key = _data["key"];
            this.icon = _data["icon"];
            this.disabled = _data["disabled"];
            this.isActive = _data["isActive"];
            this.isAlarm = _data["isAlarm"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeDataDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["key"] = this.key;
        data["icon"] = this.icon;
        data["disabled"] = this.disabled;
        data["isActive"] = this.isActive;
        data["isAlarm"] = this.isAlarm;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITreeDataDto {
    title: string | undefined;
    key: string | undefined;
    icon: string | undefined;
    disabled: boolean;
    isActive: boolean;
    isAlarm: boolean;
    children: TreeDataDto[] | undefined;
}

export class TreeOutput implements ITreeOutput {
    title!: string | undefined;
    key!: string;
    children!: TreeOutput[] | undefined;

    constructor(data?: ITreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.key = _data["key"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["key"] = this.key;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITreeOutput {
    title: string | undefined;
    key: string;
    children: TreeOutput[] | undefined;
}

export class TypeApiDescriptionModel implements ITypeApiDescriptionModel {
    baseType!: string | undefined;
    isEnum!: boolean;
    enumNames!: string[] | undefined;
    enumValues!: any[] | undefined;
    genericArguments!: string[] | undefined;
    properties!: PropertyApiDescriptionModel[] | undefined;

    constructor(data?: ITypeApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseType = _data["baseType"];
            this.isEnum = _data["isEnum"];
            if (Array.isArray(_data["enumNames"])) {
                this.enumNames = [] as any;
                for (let item of _data["enumNames"])
                    this.enumNames!.push(item);
            }
            if (Array.isArray(_data["enumValues"])) {
                this.enumValues = [] as any;
                for (let item of _data["enumValues"])
                    this.enumValues!.push(item);
            }
            if (Array.isArray(_data["genericArguments"])) {
                this.genericArguments = [] as any;
                for (let item of _data["genericArguments"])
                    this.genericArguments!.push(item);
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TypeApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseType"] = this.baseType;
        data["isEnum"] = this.isEnum;
        if (Array.isArray(this.enumNames)) {
            data["enumNames"] = [];
            for (let item of this.enumNames)
                data["enumNames"].push(item);
        }
        if (Array.isArray(this.enumValues)) {
            data["enumValues"] = [];
            for (let item of this.enumValues)
                data["enumValues"].push(item);
        }
        if (Array.isArray(this.genericArguments)) {
            data["genericArguments"] = [];
            for (let item of this.genericArguments)
                data["genericArguments"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeApiDescriptionModel {
    baseType: string | undefined;
    isEnum: boolean;
    enumNames: string[] | undefined;
    enumValues: any[] | undefined;
    genericArguments: string[] | undefined;
    properties: PropertyApiDescriptionModel[] | undefined;
}

export class UpdateConnectionStringInput implements IUpdateConnectionStringInput {
    id!: string;
    connectionString!: string | undefined;

    constructor(data?: IUpdateConnectionStringInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): UpdateConnectionStringInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateConnectionStringInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["connectionString"] = this.connectionString;
        return data;
    }
}

export interface IUpdateConnectionStringInput {
    id: string;
    connectionString: string | undefined;
}

export class UpdateContentInputDto implements IUpdateContentInputDto {
    id!: string;
    scriptContent!: string | undefined;
    jsonContent!: string | undefined;

    constructor(data?: IUpdateContentInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.scriptContent = _data["scriptContent"];
            this.jsonContent = _data["jsonContent"];
        }
    }

    static fromJS(data: any): UpdateContentInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContentInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scriptContent"] = this.scriptContent;
        data["jsonContent"] = this.jsonContent;
        return data;
    }
}

export interface IUpdateContentInputDto {
    id: string;
    scriptContent: string | undefined;
    jsonContent: string | undefined;
}

export class UpdateDataDictinaryInput implements IUpdateDataDictinaryInput {
    id!: string;
    code!: string | undefined;
    displayText!: string | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateDataDictinaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.displayText = _data["displayText"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateDataDictinaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDataDictinaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayText"] = this.displayText;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateDataDictinaryInput {
    id: string;
    code: string | undefined;
    displayText: string | undefined;
    description: string | undefined;
}

export class UpdateDetailInput implements IUpdateDetailInput {
    dataDictionaryId!: string;
    id!: string;
    displayText!: string | undefined;
    description!: string | undefined;
    order!: number;

    constructor(data?: IUpdateDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataDictionaryId = _data["dataDictionaryId"];
            this.id = _data["id"];
            this.displayText = _data["displayText"];
            this.description = _data["description"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): UpdateDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataDictionaryId"] = this.dataDictionaryId;
        data["id"] = this.id;
        data["displayText"] = this.displayText;
        data["description"] = this.description;
        data["order"] = this.order;
        return data;
    }
}

export interface IUpdateDetailInput {
    dataDictionaryId: string;
    id: string;
    displayText: string | undefined;
    description: string | undefined;
    order: number;
}

export class UpdateLanguageInput implements IUpdateLanguageInput {
    id!: string;
    cultureName!: string | undefined;
    uiCultureName!: string | undefined;
    displayName!: string | undefined;
    flagIcon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IUpdateLanguageInput {
    id: string;
    cultureName: string | undefined;
    uiCultureName: string | undefined;
    displayName: string | undefined;
    flagIcon: string | undefined;
    isEnabled: boolean;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    resourceName!: string;
    cultureName!: string;
    name!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceName = _data["resourceName"];
            this.cultureName = _data["cultureName"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceName"] = this.resourceName;
        data["cultureName"] = this.cultureName;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateLanguageTextInput {
    resourceName: string;
    cultureName: string;
    name: string;
    value: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    displayName!: string | undefined;
    id!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateOrganizationUnitInput {
    displayName: string | undefined;
    id: string;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    name!: string | undefined;
    isGranted!: boolean;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        return data;
    }
}

export interface IUpdatePermissionDto {
    name: string | undefined;
    isGranted: boolean;
}

export class UpdatePermissionsDto implements IUpdatePermissionsDto {
    permissions!: UpdatePermissionDto[] | undefined;

    constructor(data?: IUpdatePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UpdatePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePermissionsDto {
    permissions: UpdatePermissionDto[] | undefined;
}

export class UpdateRoleInput implements IUpdateRoleInput {
    roleId!: string;
    roleInfo!: IdentityRoleUpdateDto;

    constructor(data?: IUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleInfo = _data["roleInfo"] ? IdentityRoleUpdateDto.fromJS(_data["roleInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleInfo"] = this.roleInfo ? this.roleInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateRoleInput {
    roleId: string;
    roleInfo: IdentityRoleUpdateDto;
}

export class UpdateRolePermissionsInput implements IUpdateRolePermissionsInput {
    providerName!: string | undefined;
    providerKey!: string | undefined;
    updatePermissionsDto!: UpdatePermissionsDto;

    constructor(data?: IUpdateRolePermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
            this.updatePermissionsDto = _data["updatePermissionsDto"] ? UpdatePermissionsDto.fromJS(_data["updatePermissionsDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateRolePermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolePermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        data["updatePermissionsDto"] = this.updatePermissionsDto ? this.updatePermissionsDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateRolePermissionsInput {
    providerName: string | undefined;
    providerKey: string | undefined;
    updatePermissionsDto: UpdatePermissionsDto;
}

export class UpdateSettingInput implements IUpdateSettingInput {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IUpdateSettingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): UpdateSettingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSettingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IUpdateSettingInput {
    values: { [key: string]: string; } | undefined;
}

export class UpdateTelemetryDesInputDto implements IUpdateTelemetryDesInputDto {
    id!: string;
    description!: string | undefined;

    constructor(data?: IUpdateTelemetryDesInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTelemetryDesInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTelemetryDesInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateTelemetryDesInputDto {
    id: string;
    description: string | undefined;
}

export class UpdateTelemetryInputDto implements IUpdateTelemetryInputDto {
    id!: string;
    description!: string | undefined;
    unit!: string | undefined;
    expressions!: string | undefined;
    isShow!: boolean;
    isCurve!: boolean;

    constructor(data?: IUpdateTelemetryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.unit = _data["unit"];
            this.expressions = _data["expressions"];
            this.isShow = _data["isShow"];
            this.isCurve = _data["isCurve"];
        }
    }

    static fromJS(data: any): UpdateTelemetryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTelemetryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["unit"] = this.unit;
        data["expressions"] = this.expressions;
        data["isShow"] = this.isShow;
        data["isCurve"] = this.isCurve;
        return data;
    }
}

export interface IUpdateTelemetryInputDto {
    id: string;
    description: string | undefined;
    unit: string | undefined;
    expressions: string | undefined;
    isShow: boolean;
    isCurve: boolean;
}

export class UpdateTenantInput implements IUpdateTenantInput {
    id!: string;
    name!: string | undefined;

    constructor(data?: IUpdateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateTenantInput {
    id: string;
    name: string | undefined;
}

export class UpdateUserInput implements IUpdateUserInput {
    userId!: string;
    userInfo!: IdentityUserUpdateDto;

    constructor(data?: IUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userInfo = _data["userInfo"] ? IdentityUserUpdateDto.fromJS(_data["userInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userInfo"] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateUserInput {
    userId: string;
    userInfo: IdentityUserUpdateDto;
}

export class UserLoginInfo implements IUserLoginInfo {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberMe!: boolean;

    constructor(data?: IUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): UserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface IUserLoginInfo {
    userNameOrEmailAddress: string;
    password: string;
    rememberMe: boolean;
}

export class VehicleAddDeviceDto implements IVehicleAddDeviceDto {
    id!: string;
    deviceIds!: string[] | undefined;

    constructor(data?: IVehicleAddDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): VehicleAddDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleAddDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        return data;
    }
}

export interface IVehicleAddDeviceDto {
    id: string;
    deviceIds: string[] | undefined;
}

export class VehicleBatteryDto implements IVehicleBatteryDto {
    label!: string | undefined;
    value!: string | undefined;
    online!: boolean;

    constructor(data?: IVehicleBatteryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
            this.online = _data["online"];
        }
    }

    static fromJS(data: any): VehicleBatteryDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleBatteryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        data["online"] = this.online;
        return data;
    }
}

export interface IVehicleBatteryDto {
    label: string | undefined;
    value: string | undefined;
    online: boolean;
}

export class VehicleInfoDto implements IVehicleInfoDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    online!: boolean;
    temperature!: string | undefined;
    red!: boolean;
    green!: boolean;
    yellow!: boolean;

    constructor(data?: IVehicleInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.online = _data["online"];
            this.temperature = _data["temperature"];
            this.red = _data["red"];
            this.green = _data["green"];
            this.yellow = _data["yellow"];
        }
    }

    static fromJS(data: any): VehicleInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["online"] = this.online;
        data["temperature"] = this.temperature;
        data["red"] = this.red;
        data["green"] = this.green;
        data["yellow"] = this.yellow;
        return data;
    }
}

export interface IVehicleInfoDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    online: boolean;
    temperature: string | undefined;
    red: boolean;
    green: boolean;
    yellow: boolean;
}

export class VehicleInputDto implements IVehicleInputDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    manufactureDate!: string | undefined;
    type!: VehicleType;
    ton!: number;
    batteryId!: string | undefined;
    customerId!: string | undefined;
    imgUrl!: string | undefined;

    constructor(data?: IVehicleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.manufactureDate = _data["manufactureDate"];
            this.type = _data["type"];
            this.ton = _data["ton"];
            this.batteryId = _data["batteryId"];
            this.customerId = _data["customerId"];
            this.imgUrl = _data["imgUrl"];
        }
    }

    static fromJS(data: any): VehicleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["manufactureDate"] = this.manufactureDate;
        data["type"] = this.type;
        data["ton"] = this.ton;
        data["batteryId"] = this.batteryId;
        data["customerId"] = this.customerId;
        data["imgUrl"] = this.imgUrl;
        return data;
    }
}

export interface IVehicleInputDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    manufactureDate: string | undefined;
    type: VehicleType;
    ton: number;
    batteryId: string | undefined;
    customerId: string | undefined;
    imgUrl: string | undefined;
}

export class VehicleKeyParameterInputDto implements IVehicleKeyParameterInputDto {
    id!: string | undefined;
    vehicleId!: string;
    keyCode!: string | undefined;
    keyDisplayText!: string | undefined;
    deviceId!: string;
    keyName!: string | undefined;
    deviceName!: string | undefined;
    keyNameDes!: string | undefined;

    constructor(data?: IVehicleKeyParameterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleId = _data["vehicleId"];
            this.keyCode = _data["keyCode"];
            this.keyDisplayText = _data["keyDisplayText"];
            this.deviceId = _data["deviceId"];
            this.keyName = _data["keyName"];
            this.deviceName = _data["deviceName"];
            this.keyNameDes = _data["keyNameDes"];
        }
    }

    static fromJS(data: any): VehicleKeyParameterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleKeyParameterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleId"] = this.vehicleId;
        data["keyCode"] = this.keyCode;
        data["keyDisplayText"] = this.keyDisplayText;
        data["deviceId"] = this.deviceId;
        data["keyName"] = this.keyName;
        data["deviceName"] = this.deviceName;
        data["keyNameDes"] = this.keyNameDes;
        return data;
    }
}

export interface IVehicleKeyParameterInputDto {
    id: string | undefined;
    vehicleId: string;
    keyCode: string | undefined;
    keyDisplayText: string | undefined;
    deviceId: string;
    keyName: string | undefined;
    deviceName: string | undefined;
    keyNameDes: string | undefined;
}

export class VehicleKeyParameterOutputDto implements IVehicleKeyParameterOutputDto {
    id!: string | undefined;
    vehicleId!: string | undefined;
    keyCode!: string | undefined;
    keyDisplayText!: string | undefined;
    deviceId!: string | undefined;
    deviceName!: string | undefined;
    keyName!: string | undefined;
    keyNameDes!: string | undefined;

    constructor(data?: IVehicleKeyParameterOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehicleId = _data["vehicleId"];
            this.keyCode = _data["keyCode"];
            this.keyDisplayText = _data["keyDisplayText"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.keyName = _data["keyName"];
            this.keyNameDes = _data["keyNameDes"];
        }
    }

    static fromJS(data: any): VehicleKeyParameterOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleKeyParameterOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehicleId"] = this.vehicleId;
        data["keyCode"] = this.keyCode;
        data["keyDisplayText"] = this.keyDisplayText;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["keyName"] = this.keyName;
        data["keyNameDes"] = this.keyNameDes;
        return data;
    }
}

export interface IVehicleKeyParameterOutputDto {
    id: string | undefined;
    vehicleId: string | undefined;
    keyCode: string | undefined;
    keyDisplayText: string | undefined;
    deviceId: string | undefined;
    deviceName: string | undefined;
    keyName: string | undefined;
    keyNameDes: string | undefined;
}

export class VehicleOnlineAndOfflineRecordOutputDto implements IVehicleOnlineAndOfflineRecordOutputDto {
    vehicleId!: string;
    vehicleName!: string | undefined;
    time!: dayjs.Dayjs;
    status!: VehicleStatus;
    duration!: number;
    durationDisplay!: string | undefined;

    constructor(data?: IVehicleOnlineAndOfflineRecordOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"];
            this.vehicleName = _data["vehicleName"];
            this.time = _data["time"] ? dayjs(_data["time"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.duration = _data["duration"];
            this.durationDisplay = _data["durationDisplay"];
        }
    }

    static fromJS(data: any): VehicleOnlineAndOfflineRecordOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleOnlineAndOfflineRecordOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId;
        data["vehicleName"] = this.vehicleName;
        data["time"] = this.time ? this.time.toLocaleString() : <any>undefined;
        data["status"] = this.status;
        data["duration"] = this.duration;
        data["durationDisplay"] = this.durationDisplay;
        return data;
    }
}

export interface IVehicleOnlineAndOfflineRecordOutputDto {
    vehicleId: string;
    vehicleName: string | undefined;
    time: dayjs.Dayjs;
    status: VehicleStatus;
    duration: number;
    durationDisplay: string | undefined;
}

export class VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto implements IVehicleOnlineAndOfflineRecordOutputDtoPagedResultDto {
    items!: VehicleOnlineAndOfflineRecordOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IVehicleOnlineAndOfflineRecordOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VehicleOnlineAndOfflineRecordOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleOnlineAndOfflineRecordOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IVehicleOnlineAndOfflineRecordOutputDtoPagedResultDto {
    items: VehicleOnlineAndOfflineRecordOutputDto[] | undefined;
    totalCount: number;
}

export class VehicleOutputDto implements IVehicleOutputDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    manufactureDate!: dayjs.Dayjs;
    type!: VehicleType;
    typeStr!: string | undefined;
    ton!: number;
    batteryId!: string | undefined;
    battery!: string | undefined;
    customerId!: string | undefined;
    customer!: string | undefined;
    imgUrl!: string | undefined;

    constructor(data?: IVehicleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.manufactureDate = _data["manufactureDate"] ? dayjs(_data["manufactureDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.typeStr = _data["typeStr"];
            this.ton = _data["ton"];
            this.batteryId = _data["batteryId"];
            this.battery = _data["battery"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"];
            this.imgUrl = _data["imgUrl"];
        }
    }

    static fromJS(data: any): VehicleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["manufactureDate"] = this.manufactureDate ? this.manufactureDate.toLocaleString() : <any>undefined;
        data["type"] = this.type;
        data["typeStr"] = this.typeStr;
        data["ton"] = this.ton;
        data["batteryId"] = this.batteryId;
        data["battery"] = this.battery;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer;
        data["imgUrl"] = this.imgUrl;
        return data;
    }
}

export interface IVehicleOutputDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    manufactureDate: dayjs.Dayjs;
    type: VehicleType;
    typeStr: string | undefined;
    ton: number;
    batteryId: string | undefined;
    battery: string | undefined;
    customerId: string | undefined;
    customer: string | undefined;
    imgUrl: string | undefined;
}

export class VehicleOutputDtoPagedResultDto implements IVehicleOutputDtoPagedResultDto {
    items!: VehicleOutputDto[] | undefined;
    totalCount!: number;

    constructor(data?: IVehicleOutputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VehicleOutputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VehicleOutputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleOutputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IVehicleOutputDtoPagedResultDto {
    items: VehicleOutputDto[] | undefined;
    totalCount: number;
}

export class VehicleScatterChartDto implements IVehicleScatterChartDto {
    scatterChartData!: DoubleListNameValue[] | undefined;

    constructor(data?: IVehicleScatterChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["scatterChartData"])) {
                this.scatterChartData = [] as any;
                for (let item of _data["scatterChartData"])
                    this.scatterChartData!.push(DoubleListNameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleScatterChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleScatterChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.scatterChartData)) {
            data["scatterChartData"] = [];
            for (let item of this.scatterChartData)
                data["scatterChartData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehicleScatterChartDto {
    scatterChartData: DoubleListNameValue[] | undefined;
}

export enum VehicleStatus {
    Online = "Online",
    Offline = "Offline",
}

export enum VehicleType {
    SlagLadle = "SlagLadle",
    Flat = "Flat",
    OverPass = "OverPass",
    CokeLadle = "CokeLadle",
    VacuumGroove = "VacuumGroove",
    ElectricStove = "ElectricStove",
    MidLadle = "MidLadle",
    SteelLadleTipup = "SteelLadleTipup",
    SteelLadleHot = "SteelLadleHot",
    Cast = "Cast",
    SteelLadle = "SteelLadle",
    IronLadle = "IronLadle",
    Sidesway = "Sidesway",
    IronLadleTipup = "IronLadleTipup",
    OneBottomIronLadle = "OneBottomIronLadle",
}

export class VoltageDto implements IVoltageDto {
    location!: string | undefined;
    voltage!: number;

    constructor(data?: IVoltageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.voltage = _data["voltage"];
        }
    }

    static fromJS(data: any): VoltageDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoltageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["voltage"] = this.voltage;
        return data;
    }
}

export interface IVoltageDto {
    location: string | undefined;
    voltage: number;
}

export class WeatherDto implements IWeatherDto {
    province!: string | undefined;
    city!: string | undefined;
    adcode!: string | undefined;
    weather!: string | undefined;
    temperature!: string | undefined;
    winddirection!: string | undefined;
    windpower!: string | undefined;
    humidity!: string | undefined;
    reporttime!: string | undefined;
    temperature_float!: string | undefined;
    humidity_float!: string | undefined;

    constructor(data?: IWeatherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.province = _data["province"];
            this.city = _data["city"];
            this.adcode = _data["adcode"];
            this.weather = _data["weather"];
            this.temperature = _data["temperature"];
            this.winddirection = _data["winddirection"];
            this.windpower = _data["windpower"];
            this.humidity = _data["humidity"];
            this.reporttime = _data["reporttime"];
            this.temperature_float = _data["temperature_float"];
            this.humidity_float = _data["humidity_float"];
        }
    }

    static fromJS(data: any): WeatherDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["province"] = this.province;
        data["city"] = this.city;
        data["adcode"] = this.adcode;
        data["weather"] = this.weather;
        data["temperature"] = this.temperature;
        data["winddirection"] = this.winddirection;
        data["windpower"] = this.windpower;
        data["humidity"] = this.humidity;
        data["reporttime"] = this.reporttime;
        data["temperature_float"] = this.temperature_float;
        data["humidity_float"] = this.humidity_float;
        return data;
    }
}

export interface IWeatherDto {
    province: string | undefined;
    city: string | undefined;
    adcode: string | undefined;
    weather: string | undefined;
    temperature: string | undefined;
    winddirection: string | undefined;
    windpower: string | undefined;
    humidity: string | undefined;
    reporttime: string | undefined;
    temperature_float: string | undefined;
    humidity_float: string | undefined;
}

export class WeatherResponseDto implements IWeatherResponseDto {
    status!: string | undefined;
    count!: string | undefined;
    info!: string | undefined;
    infocode!: string | undefined;
    lives!: WeatherDto[] | undefined;

    constructor(data?: IWeatherResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.count = _data["count"];
            this.info = _data["info"];
            this.infocode = _data["infocode"];
            if (Array.isArray(_data["lives"])) {
                this.lives = [] as any;
                for (let item of _data["lives"])
                    this.lives!.push(WeatherDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeatherResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["count"] = this.count;
        data["info"] = this.info;
        data["infocode"] = this.infocode;
        if (Array.isArray(this.lives)) {
            data["lives"] = [];
            for (let item of this.lives)
                data["lives"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWeatherResponseDto {
    status: string | undefined;
    count: string | undefined;
    info: string | undefined;
    infocode: string | undefined;
    lives: WeatherDto[] | undefined;
}

export class WindowsTimeZone implements IWindowsTimeZone {
    timeZoneId!: string | undefined;

    constructor(data?: IWindowsTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): WindowsTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new WindowsTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface IWindowsTimeZone {
    timeZoneId: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
