/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { ServiceProxyBase } from './ServiceProxyBase';
import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from 'axios';

import dayjs from 'dayjs';

export class AbpApiDefinitionServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param includeTypes (optional)
   * @return Success
   */
  apiDefinition(
    includeTypes: boolean | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<ApplicationApiDescriptionModel> {
    let url_ = this.baseUrl + '/api/abp/api-definition?';
    if (includeTypes === null) throw new Error("The parameter 'includeTypes' cannot be null.");
    else if (includeTypes !== undefined)
      url_ += 'IncludeTypes=' + encodeURIComponent('' + includeTypes) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processApiDefinition(_response),
        );
      });
  }

  protected processApiDefinition(response: AxiosResponse): Promise<ApplicationApiDescriptionModel> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ApplicationApiDescriptionModel.fromJS(resultData200);
      return Promise.resolve<ApplicationApiDescriptionModel>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ApplicationApiDescriptionModel>(null as any);
  }
}

export class AbpApplicationConfigurationServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param includeLocalizationResources (optional)
   * @return Success
   */
  applicationConfiguration(
    includeLocalizationResources: boolean | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<ApplicationConfigurationDto> {
    let url_ = this.baseUrl + '/api/abp/application-configuration?';
    if (includeLocalizationResources === null)
      throw new Error("The parameter 'includeLocalizationResources' cannot be null.");
    else if (includeLocalizationResources !== undefined)
      url_ +=
        'IncludeLocalizationResources=' +
        encodeURIComponent('' + includeLocalizationResources) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processApplicationConfiguration(_response),
        );
      });
  }

  protected processApplicationConfiguration(
    response: AxiosResponse,
  ): Promise<ApplicationConfigurationDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ApplicationConfigurationDto.fromJS(resultData200);
      return Promise.resolve<ApplicationConfigurationDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ApplicationConfigurationDto>(null as any);
  }
}

export class AbpApplicationLocalizationServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param onlyDynamics (optional)
   * @return Success
   */
  applicationLocalization(
    cultureName: string,
    onlyDynamics: boolean | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<ApplicationLocalizationDto> {
    let url_ = this.baseUrl + '/api/abp/application-localization?';
    if (cultureName === undefined || cultureName === null)
      throw new Error("The parameter 'cultureName' must be defined and cannot be null.");
    else url_ += 'CultureName=' + encodeURIComponent('' + cultureName) + '&';
    if (onlyDynamics === null) throw new Error("The parameter 'onlyDynamics' cannot be null.");
    else if (onlyDynamics !== undefined)
      url_ += 'OnlyDynamics=' + encodeURIComponent('' + onlyDynamics) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processApplicationLocalization(_response),
        );
      });
  }

  protected processApplicationLocalization(
    response: AxiosResponse,
  ): Promise<ApplicationLocalizationDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ApplicationLocalizationDto.fromJS(resultData200);
      return Promise.resolve<ApplicationLocalizationDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ApplicationLocalizationDto>(null as any);
  }
}

export class AccountServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 登录
   * @param body (optional)
   * @return Success
   */
  login(body: LoginInput | undefined, cancelToken?: CancelToken | undefined): Promise<LoginOutput> {
    let url_ = this.baseUrl + '/api/app/account/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processLogin(_response),
        );
      });
  }

  protected processLogin(response: AxiosResponse): Promise<LoginOutput> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = LoginOutput.fromJS(resultData200);
      return Promise.resolve<LoginOutput>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<LoginOutput>(null as any);
  }
}

export class AlarmServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  alarm(
    body: CreateAlarmInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/alarm/alarm';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAlarm(_response),
        );
      });
  }

  protected processAlarm(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 分页查询报警记录
   * @param body (optional)
   * @return Success
   */
  page(
    body: PageAlarmInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<AlarmOutputDtoPagedResultDto> {
    let url_ = this.baseUrl + '/alarm/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<AlarmOutputDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AlarmOutputDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<AlarmOutputDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<AlarmOutputDtoPagedResultDto>(null as any);
  }

  /**
   * 下拉设备
   * @return Success
   */
  device(cancelToken?: CancelToken | undefined): Promise<NameIdDto[]> {
    let url_ = this.baseUrl + '/alarm/device';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDevice(_response),
        );
      });
  }

  protected processDevice(response: AxiosResponse): Promise<NameIdDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(NameIdDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<NameIdDto[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<NameIdDto[]>(null as any);
  }

  /**
   * 下拉遥测属性
   * @return Success
   */
  telemetry(cancelToken?: CancelToken | undefined): Promise<NameIdDto[]> {
    let url_ = this.baseUrl + '/alarm/telemetry';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processTelemetry(_response),
        );
      });
  }

  protected processTelemetry(response: AxiosResponse): Promise<NameIdDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(NameIdDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<NameIdDto[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<NameIdDto[]>(null as any);
  }
}

export class AuditLogsServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 分页获取审计日志信息
   * @param body (optional)
   * @return Success
   */
  page(
    body: PagingAuditLogInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PagingAuditLogOutputPagedResultDto> {
    let url_ = this.baseUrl + '/AuditLogs/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<PagingAuditLogOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagingAuditLogOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PagingAuditLogOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagingAuditLogOutputPagedResultDto>(null as any);
  }
}

export class CommonServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * mongo的Luuid转成Guid
   * @param mongoLuuid (optional)
   * @return Success
   */
  getGuid(mongoLuuid: string | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/common/get-guid?';
    if (mongoLuuid === null) throw new Error("The parameter 'mongoLuuid' cannot be null.");
    else if (mongoLuuid !== undefined)
      url_ += 'mongoLuuid=' + encodeURIComponent('' + mongoLuuid) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processGetGuid(_response),
        );
      });
  }

  protected processGetGuid(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(null as any);
  }
}

export class CustomersServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 创建客户
   * @param body (optional)
   * @return Success
   */
  create(body: CustomerInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/customer/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除客户
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/customer/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 编辑客户
   * @param body (optional)
   * @return Success
   */
  edit(body: CustomerInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/customer/edit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processEdit(_response),
        );
      });
  }

  protected processEdit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 分页查询客户
   * @param body (optional)
   * @return Success
   */
  page(
    body: PageCustomerInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<CustomerOutputDtoPagedResultDto> {
    let url_ = this.baseUrl + '/customer/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<CustomerOutputDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = CustomerOutputDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<CustomerOutputDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<CustomerOutputDtoPagedResultDto>(null as any);
  }

  /**
   * 中国省市数据
   * @return Success
   */
  china(cancelToken?: CancelToken | undefined): Promise<ChinaDataDto> {
    let url_ = this.baseUrl + '/customer/china';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processChina(_response),
        );
      });
  }

  protected processChina(response: AxiosResponse): Promise<ChinaDataDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ChinaDataDto.fromJS(resultData200);
      return Promise.resolve<ChinaDataDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ChinaDataDto>(null as any);
  }

  /**
   * 创建租户管理员
   * @param body (optional)
   * @return Success
   */
  tenant(
    body: BuildTenantAdminInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/customer/tenant';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processTenant(_response),
        );
      });
  }

  protected processTenant(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 关闭租户管理员
   * @param body (optional)
   * @return Success
   */
  close(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/customer/close';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processClose(_response),
        );
      });
  }

  protected processClose(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class DataDictionaryServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 分页字典类型
   * @param body (optional)
   * @return Success
   */
  page(
    body: PagingDataDictionaryInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PagingDataDictionaryOutputPagedResultDto> {
    let url_ = this.baseUrl + '/DataDictionary/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(
    response: AxiosResponse,
  ): Promise<PagingDataDictionaryOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagingDataDictionaryOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PagingDataDictionaryOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagingDataDictionaryOutputPagedResultDto>(null as any);
  }

  /**
   * 分页字典明细
   * @param body (optional)
   * @return Success
   */
  pageDetail(
    body: PagingDataDictionaryDetailInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PagingDataDictionaryDetailOutputPagedResultDto> {
    let url_ = this.baseUrl + '/DataDictionary/pageDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPageDetail(_response),
        );
      });
  }

  protected processPageDetail(
    response: AxiosResponse,
  ): Promise<PagingDataDictionaryDetailOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagingDataDictionaryDetailOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PagingDataDictionaryDetailOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagingDataDictionaryDetailOutputPagedResultDto>(null as any);
  }

  /**
   * 创建字典类型
   * @param body (optional)
   * @return Success
   */
  create(
    body: CreateDataDictinaryInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/DataDictionary/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 创建字典明细
   * @param body (optional)
   * @return Success
   */
  createDetail(
    body: CreateDataDictinaryDetailInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/DataDictionary/createDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreateDetail(_response),
        );
      });
  }

  protected processCreateDetail(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 设置字典明细状态
   * @param body (optional)
   * @return Success
   */
  status(
    body: SetDataDictinaryDetailInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/DataDictionary/status';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processStatus(_response),
        );
      });
  }

  protected processStatus(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 更新字典明细
   * @param body (optional)
   * @return Success
   */
  updateDetail(
    body: UpdateDetailInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/DataDictionary/updateDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdateDetail(_response),
        );
      });
  }

  protected processUpdateDetail(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除字典明细
   * @param body (optional)
   * @return Success
   */
  delete(
    body: DeleteDataDictionaryDetailInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/DataDictionary/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除字典类型
   * @param body (optional)
   * @return Success
   */
  deleteDataDictionaryType(
    body: IdInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/DataDictionary/deleteDataDictionaryType';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDeleteDataDictionaryType(_response),
        );
      });
  }

  protected processDeleteDataDictionaryType(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 修改字典类型
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateDataDictinaryInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/DataDictionary/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class DeviceServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 创建设备
   * @param body (optional)
   * @return Success
   */
  create(body: DeviceInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/device/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除设备
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/device/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 编辑设备
   * @param body (optional)
   * @return Success
   */
  edit(body: DeviceInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/device/edit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processEdit(_response),
        );
      });
  }

  protected processEdit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 分页查询设备
   * @param body (optional)
   * @return Success
   */
  page(
    body: PageDeviceInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<DeviceOutputDtoPagedResultDto> {
    let url_ = this.baseUrl + '/device/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<DeviceOutputDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DeviceOutputDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<DeviceOutputDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<DeviceOutputDtoPagedResultDto>(null as any);
  }

  /**
   * 分页查询设备属性
   * @param body (optional)
   * @return Success
   */
  property(
    body: ListPropertyInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PropertyOutputDtoPagedResultDto> {
    let url_ = this.baseUrl + '/device/property';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processProperty(_response),
        );
      });
  }

  protected processProperty(response: AxiosResponse): Promise<PropertyOutputDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PropertyOutputDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PropertyOutputDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PropertyOutputDtoPagedResultDto>(null as any);
  }

  /**
   * 同步设备遥测属性
   * @param body (optional)
   * @return Success
   */
  syncTelemetry(
    body: ListPropertyInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/device/sync-telemetry';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSyncTelemetry(_response),
        );
      });
  }

  protected processSyncTelemetry(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 开关显示
   * @param body (optional)
   * @return Success
   */
  show(body: PropertyOutputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/device/show';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processShow(_response),
        );
      });
  }

  protected processShow(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 描述更新
   * @param body (optional)
   * @return Success
   */
  updateDes(
    body: UpdatePropertyDesInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/device/update-des';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdateDes(_response),
        );
      });
  }

  protected processUpdateDes(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 设备树
   * @return Success
   */
  tree(cancelToken?: CancelToken | undefined): Promise<TreeDataDto[]> {
    let url_ = this.baseUrl + '/device/tree';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processTree(_response),
        );
      });
  }

  protected processTree(response: AxiosResponse): Promise<TreeDataDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(TreeDataDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<TreeDataDto[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TreeDataDto[]>(null as any);
  }

  /**
   * 实时遥测数据
   * @param body (optional)
   * @return Success
   */
  realTel(
    body: ListPropertyInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<StringNameValue[]> {
    let url_ = this.baseUrl + '/device/real-tel';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processRealTel(_response),
        );
      });
  }

  protected processRealTel(response: AxiosResponse): Promise<StringNameValue[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(StringNameValue.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<StringNameValue[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<StringNameValue[]>(null as any);
  }

  /**
   * 遥测数据曲线图
   * @param body (optional)
   * @return Success
   */
  chartTel(
    body: ListTelemetryChartDataInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<TelemetryChartDataDto> {
    let url_ = this.baseUrl + '/device/chart-tel';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processChartTel(_response),
        );
      });
  }

  protected processChartTel(response: AxiosResponse): Promise<TelemetryChartDataDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TelemetryChartDataDto.fromJS(resultData200);
      return Promise.resolve<TelemetryChartDataDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TelemetryChartDataDto>(null as any);
  }

  /**
   * 上传设备图片
   * @return Success
   */
  uploadImg(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/device/upload-img';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUploadImg(_response),
        );
      });
  }

  protected processUploadImg(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * 上传设备图片
   * @param body (optional)
   * @return Success
   */
  getImg(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/device/get-img';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processGetImg(_response),
        );
      });
  }

  protected processGetImg(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * 获取设备报警列表
   * @param body (optional)
   * @return Success
   */
  alarm(
    body: IdInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<RealTimeAlarmDto[]> {
    let url_ = this.baseUrl + '/device/alarm';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAlarm(_response),
        );
      });
  }

  protected processAlarm(response: AxiosResponse): Promise<RealTimeAlarmDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(RealTimeAlarmDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<RealTimeAlarmDto[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<RealTimeAlarmDto[]>(null as any);
  }

  /**
   * 清除某笔报警
   * @param body (optional)
   * @return Success
   */
  clear(
    body: ClearAlarmInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/device/clear';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processClear(_response),
        );
      });
  }

  protected processClear(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 分页查询设备规则
   * @param body (optional)
   * @return Success
   */
  rule(
    body: IdInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<DeviceRuleOutputDtoPagedResultDto> {
    let url_ = this.baseUrl + '/device/rule';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processRule(_response),
        );
      });
  }

  protected processRule(response: AxiosResponse): Promise<DeviceRuleOutputDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DeviceRuleOutputDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<DeviceRuleOutputDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<DeviceRuleOutputDtoPagedResultDto>(null as any);
  }

  /**
   * 关联设备和规则
   * @param body (optional)
   * @return Success
   */
  relate(
    body: RelateDeviceRuleInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/device/relate';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processRelate(_response),
        );
      });
  }

  protected processRelate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 开关启用
   * @param body (optional)
   * @return Success
   */
  enable(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/device/enable';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processEnable(_response),
        );
      });
  }

  protected processEnable(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class IdentitySecurityLogsServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 分页获取登录日志信息
   * @param body (optional)
   * @return Success
   */
  page(
    body: PagingIdentitySecurityLogInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PagingIdentitySecurityLogOutputPagedResultDto> {
    let url_ = this.baseUrl + '/IdentitySecurityLogs/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(
    response: AxiosResponse,
  ): Promise<PagingIdentitySecurityLogOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagingIdentitySecurityLogOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PagingIdentitySecurityLogOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagingIdentitySecurityLogOutputPagedResultDto>(null as any);
  }
}

export class LanguagesServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 获取所有语言
   * @return Success
   */
  all(cancelToken?: CancelToken | undefined): Promise<PageLanguageOutput[]> {
    let url_ = this.baseUrl + '/Languages/All';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAll(_response),
        );
      });
  }

  protected processAll(response: AxiosResponse): Promise<PageLanguageOutput[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(PageLanguageOutput.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<PageLanguageOutput[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PageLanguageOutput[]>(null as any);
  }

  /**
   * 分页查询语言
   * @param body (optional)
   * @return Success
   */
  page(
    body: PageLanguageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PageLanguageOutputPagedResultDto> {
    let url_ = this.baseUrl + '/Languages/Page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<PageLanguageOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PageLanguageOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PageLanguageOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PageLanguageOutputPagedResultDto>(null as any);
  }

  /**
   * 创建语言
   * @param body (optional)
   * @return Success
   */
  create(
    body: CreateLanguageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Languages/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 编辑语言
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLanguageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Languages/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除语言
   * @param body (optional)
   * @return Success
   */
  delete(
    body: DeleteLanguageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Languages/Delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 设置默认语言
   * @param body (optional)
   * @return Success
   */
  setDefault(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Languages/SetDefault';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSetDefault(_response),
        );
      });
  }

  protected processSetDefault(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class LanguageTextsServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 获取所有资源
   * @return Success
   */
  allResource(cancelToken?: CancelToken | undefined): Promise<StringStringFromSelector[]> {
    let url_ = this.baseUrl + '/LanguageTexts/AllResource';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAllResource(_response),
        );
      });
  }

  protected processAllResource(response: AxiosResponse): Promise<StringStringFromSelector[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(StringStringFromSelector.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<StringStringFromSelector[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<StringStringFromSelector[]>(null as any);
  }

  /**
   * 分页查询语言文本
   * @param body (optional)
   * @return Success
   */
  page(
    body: PageLanguageTextInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PageLanguageTextOutputPagedResultDto> {
    let url_ = this.baseUrl + '/LanguageTexts/Page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<PageLanguageTextOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PageLanguageTextOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PageLanguageTextOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PageLanguageTextOutputPagedResultDto>(null as any);
  }

  /**
   * 创建语言文本
   * @param body (optional)
   * @return Success
   */
  create(
    body: CreateLanguageTextInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/LanguageTexts/Create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 编辑语言文本
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLanguageTextInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/LanguageTexts/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class MongoDemoServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  userInfoPost(
    body: UserInfoReq | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<boolean> {
    let url_ = this.baseUrl + '/api/app/mongo-demo/user-info';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUserInfoPost(_response),
        );
      });
  }

  protected processUserInfoPost(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * @return Success
   */
  mongoDemo(id: string, cancelToken?: CancelToken | undefined): Promise<boolean> {
    let url_ = this.baseUrl + '/api/app/mongo-demo/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'DELETE',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processMongoDemo(_response),
        );
      });
  }

  protected processMongoDemo(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * @return Success
   */
  userInfos(cancelToken?: CancelToken | undefined): Promise<UserInfo[]> {
    let url_ = this.baseUrl + '/api/app/mongo-demo/user-infos';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUserInfos(_response),
        );
      });
  }

  protected processUserInfos(response: AxiosResponse): Promise<UserInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(UserInfo.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<UserInfo[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<UserInfo[]>(null as any);
  }

  /**
   * @return Success
   */
  userInfoById(id: string, cancelToken?: CancelToken | undefined): Promise<UserInfo> {
    let url_ = this.baseUrl + '/api/app/mongo-demo/{id}/user-info-by-id';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUserInfoById(_response),
        );
      });
  }

  protected processUserInfoById(response: AxiosResponse): Promise<UserInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = UserInfo.fromJS(resultData200);
      return Promise.resolve<UserInfo>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<UserInfo>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  userInfoPut(
    id: string,
    body: UserInfoReq | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<UserInfo> {
    let url_ = this.baseUrl + '/api/app/mongo-demo/{id}/user-info';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUserInfoPut(_response),
        );
      });
  }

  protected processUserInfoPut(response: AxiosResponse): Promise<UserInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = UserInfo.fromJS(resultData200);
      return Promise.resolve<UserInfo>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<UserInfo>(null as any);
  }
}

export class NotificationServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 分页查询普通消息
   * @param body (optional)
   * @return Success
   */
  common(
    body: PagingNotificationListInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PagingNotificationListOutputPagedResultDto> {
    let url_ = this.baseUrl + '/Notification/Common';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCommon(_response),
        );
      });
  }

  protected processCommon(
    response: AxiosResponse,
  ): Promise<PagingNotificationListOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagingNotificationListOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PagingNotificationListOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagingNotificationListOutputPagedResultDto>(null as any);
  }

  /**
   * 分页查询广播消息
   * @param body (optional)
   * @return Success
   */
  broadCast(
    body: PagingNotificationListInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PagingNotificationListOutputPagedResultDto> {
    let url_ = this.baseUrl + '/Notification/BroadCast';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processBroadCast(_response),
        );
      });
  }

  protected processBroadCast(
    response: AxiosResponse,
  ): Promise<PagingNotificationListOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagingNotificationListOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<PagingNotificationListOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagingNotificationListOutputPagedResultDto>(null as any);
  }

  /**
   * 发送警告文本消息
   * @param body (optional)
   * @return Success
   */
  sendCommonWarningMessage(
    body: SendCommonMessageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Notification/SendCommonWarningMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSendCommonWarningMessage(_response),
        );
      });
  }

  protected processSendCommonWarningMessage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 发送普通文本消息
   * @param body (optional)
   * @return Success
   */
  sendCommonInformationMessage(
    body: SendCommonMessageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Notification/SendCommonInformationMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSendCommonInformationMessage(_response),
        );
      });
  }

  protected processSendCommonInformationMessage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 发送错误文本消息
   * @param body (optional)
   * @return Success
   */
  sendCommonErrorMessage(
    body: SendCommonMessageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Notification/SendCommonErrorMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSendCommonErrorMessage(_response),
        );
      });
  }

  protected processSendCommonErrorMessage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 发送警告广播消息
   * @param body (optional)
   * @return Success
   */
  sendBroadCastWarningMessage(
    body: SendBroadCastMessageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Notification/SendBroadCastWarningMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSendBroadCastWarningMessage(_response),
        );
      });
  }

  protected processSendBroadCastWarningMessage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 发送正常广播消息
   * @param body (optional)
   * @return Success
   */
  sendBroadCastInformationMessage(
    body: SendBroadCastMessageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Notification/SendBroadCastInformationMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSendBroadCastInformationMessage(_response),
        );
      });
  }

  protected processSendBroadCastInformationMessage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 发送错误广播消息
   * @param body (optional)
   * @return Success
   */
  sendBroadCastErrorMessage(
    body: SendBroadCastMessageInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Notification/SendBroadCastErrorMessage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSendBroadCastErrorMessage(_response),
        );
      });
  }

  protected processSendBroadCastErrorMessage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 消息设置为已读
   * @param body (optional)
   * @return Success
   */
  read(body: SetReadInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Notification/Read';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processRead(_response),
        );
      });
  }

  protected processRead(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class OrganizationUnitsServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 获取组织机构树
   * @return Success
   */
  tree(cancelToken?: CancelToken | undefined): Promise<TreeOutput[]> {
    let url_ = this.baseUrl + '/OrganizationUnits/tree';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processTree(_response),
        );
      });
  }

  protected processTree(response: AxiosResponse): Promise<TreeOutput[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(TreeOutput.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<TreeOutput[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TreeOutput[]>(null as any);
  }

  /**
   * 创建组织机构
   * @param body (optional)
   * @return Success
   */
  create(
    body: CreateOrganizationUnitInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/OrganizationUnits/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除组织机构
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/OrganizationUnits/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 编辑组织机构
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateOrganizationUnitInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/OrganizationUnits/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 向组织机构添加角色
   * @param body (optional)
   * @return Success
   */
  addRoleToOrganizationUnit(
    body: AddRoleToOrganizationUnitInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/OrganizationUnits/addRoleToOrganizationUnitAsync';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAddRoleToOrganizationUnit(_response),
        );
      });
  }

  protected processAddRoleToOrganizationUnit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 向组织机构删除角色
   * @param body (optional)
   * @return Success
   */
  removeRoleFromOrganizationUnit(
    body: RemoveRoleToOrganizationUnitInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/OrganizationUnits/removeRoleFromOrganizationUnitAsync';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processRemoveRoleFromOrganizationUnit(_response),
        );
      });
  }

  protected processRemoveRoleFromOrganizationUnit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 向组织机构添加用户
   * @param body (optional)
   * @return Success
   */
  addUserToOrganizationUnit(
    body: AddUserToOrganizationUnitInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/OrganizationUnits/addUserToOrganizationUnit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAddUserToOrganizationUnit(_response),
        );
      });
  }

  protected processAddUserToOrganizationUnit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 向组织机构删除用户
   * @param body (optional)
   * @return Success
   */
  removeUserFromOrganizationUnit(
    body: RemoveUserToOrganizationUnitInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/OrganizationUnits/removeUserFromOrganizationUnit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processRemoveUserFromOrganizationUnit(_response),
        );
      });
  }

  protected processRemoveUserFromOrganizationUnit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 分页获取组织机构下用户
   * @param body (optional)
   * @return Success
   */
  getUsers(
    body: GetOrganizationUnitUserInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<GetOrganizationUnitUserOutputPagedResultDto> {
    let url_ = this.baseUrl + '/OrganizationUnits/getUsers';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processGetUsers(_response),
        );
      });
  }

  protected processGetUsers(
    response: AxiosResponse,
  ): Promise<GetOrganizationUnitUserOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOrganizationUnitUserOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<GetOrganizationUnitUserOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<GetOrganizationUnitUserOutputPagedResultDto>(null as any);
  }

  /**
   * 分页获取组织机构下角色
   * @param body (optional)
   * @return Success
   */
  getRoles(
    body: GetOrganizationUnitRoleInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<GetOrganizationUnitRoleOutputPagedResultDto> {
    let url_ = this.baseUrl + '/OrganizationUnits/getRoles';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processGetRoles(_response),
        );
      });
  }

  protected processGetRoles(
    response: AxiosResponse,
  ): Promise<GetOrganizationUnitRoleOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetOrganizationUnitRoleOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<GetOrganizationUnitRoleOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<GetOrganizationUnitRoleOutputPagedResultDto>(null as any);
  }

  /**
   * 获取不在组织机构的用户
   * @param body (optional)
   * @return Success
   */
  getUnAddUsers(
    body: GetUnAddUserInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<GetUnAddUserOutputPagedResultDto> {
    let url_ = this.baseUrl + '/OrganizationUnits/getUnAddUsers';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processGetUnAddUsers(_response),
        );
      });
  }

  protected processGetUnAddUsers(
    response: AxiosResponse,
  ): Promise<GetUnAddUserOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetUnAddUserOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<GetUnAddUserOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<GetUnAddUserOutputPagedResultDto>(null as any);
  }

  /**
   * 获取不在组织机构的角色
   * @param body (optional)
   * @return Success
   */
  getUnAddRoles(
    body: GetUnAddRoleInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<GetUnAddRoleOutputPagedResultDto> {
    let url_ = this.baseUrl + '/OrganizationUnits/getUnAddRoles';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processGetUnAddRoles(_response),
        );
      });
  }

  protected processGetUnAddRoles(
    response: AxiosResponse,
  ): Promise<GetUnAddRoleOutputPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetUnAddRoleOutputPagedResultDto.fromJS(resultData200);
      return Promise.resolve<GetUnAddRoleOutputPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<GetUnAddRoleOutputPagedResultDto>(null as any);
  }
}

export class PermissionsServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 获取角色权限
   * @param body (optional)
   * @return Success
   */
  tree(
    body: GetPermissionInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<PermissionOutput> {
    let url_ = this.baseUrl + '/Permissions/tree';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processTree(_response),
        );
      });
  }

  protected processTree(response: AxiosResponse): Promise<PermissionOutput> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PermissionOutput.fromJS(resultData200);
      return Promise.resolve<PermissionOutput>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PermissionOutput>(null as any);
  }

  /**
   * 更新角色
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateRolePermissionsInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Permissions/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class ProductServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 生成设备
   * @param body (optional)
   * @return Success
   */
  build(body: BuildDeviceDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/product/build';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processBuild(_response),
        );
      });
  }

  protected processBuild(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 创建产品
   * @param body (optional)
   * @return Success
   */
  create(body: ProductInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/product/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除产品
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/product/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 编辑产品
   * @param body (optional)
   * @return Success
   */
  edit(body: ProductInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/product/edit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processEdit(_response),
        );
      });
  }

  protected processEdit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 获取产品关联的设备
   * @param body (optional)
   * @return Success
   */
  list(
    body: IdInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<DeviceOutputDto[]> {
    let url_ = this.baseUrl + '/product/list';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processList(_response),
        );
      });
  }

  protected processList(response: AxiosResponse): Promise<DeviceOutputDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(DeviceOutputDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<DeviceOutputDto[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<DeviceOutputDto[]>(null as any);
  }

  /**
   * 分页查询产品
   * @param body (optional)
   * @return Success
   */
  page(
    body: PageProductInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<ProductOutputDtoPagedResultDto> {
    let url_ = this.baseUrl + '/product/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<ProductOutputDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ProductOutputDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<ProductOutputDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ProductOutputDtoPagedResultDto>(null as any);
  }
}

export class RolesServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 获取所有角色
   * @return Success
   */
  all(cancelToken?: CancelToken | undefined): Promise<IdentityRoleDtoListResultDto> {
    let url_ = this.baseUrl + '/Roles/all';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAll(_response),
        );
      });
  }

  protected processAll(response: AxiosResponse): Promise<IdentityRoleDtoListResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityRoleDtoListResultDto.fromJS(resultData200);
      return Promise.resolve<IdentityRoleDtoListResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityRoleDtoListResultDto>(null as any);
  }

  /**
   * 分页获取角色
   * @param body (optional)
   * @return Success
   */
  page(
    body: PagingRoleListInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<IdentityRoleDtoPagedResultDto> {
    let url_ = this.baseUrl + '/Roles/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<IdentityRoleDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityRoleDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<IdentityRoleDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityRoleDtoPagedResultDto>(null as any);
  }

  /**
   * 创建角色
   * @param body (optional)
   * @return Success
   */
  create(
    body: IdentityRoleCreateDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<IdentityRoleDto> {
    let url_ = this.baseUrl + '/Roles/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<IdentityRoleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityRoleDto.fromJS(resultData200);
      return Promise.resolve<IdentityRoleDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityRoleDto>(null as any);
  }

  /**
   * 更新角色
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateRoleInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<IdentityRoleDto> {
    let url_ = this.baseUrl + '/Roles/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<IdentityRoleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityRoleDto.fromJS(resultData200);
      return Promise.resolve<IdentityRoleDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityRoleDto>(null as any);
  }

  /**
   * 删除角色
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Roles/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class RuleServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 创建规则
   * @param body (optional)
   * @return Success
   */
  create(body: RuleInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/rule/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除规则
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/rule/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 编辑规则
   * @param body (optional)
   * @return Success
   */
  edit(body: RuleInputDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/rule/edit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processEdit(_response),
        );
      });
  }

  protected processEdit(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 分页查询规则
   * @param body (optional)
   * @return Success
   */
  page(
    body: PageRuleInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<RuleOutputDtoPagedResultDto> {
    let url_ = this.baseUrl + '/rule/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<RuleOutputDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = RuleOutputDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<RuleOutputDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<RuleOutputDtoPagedResultDto>(null as any);
  }

  /**
   * Json或者script上传
   * @param body (optional)
   * @return Success
   */
  content(
    body: UpdateContentInputDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/rule/content';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processContent(_response),
        );
      });
  }

  protected processContent(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class SettingsServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 获取所有Setting
   * @return Success
   */
  all(cancelToken?: CancelToken | undefined): Promise<SettingOutput[]> {
    let url_ = this.baseUrl + '/Settings/all';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processAll(_response),
        );
      });
  }

  protected processAll(response: AxiosResponse): Promise<SettingOutput[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(SettingOutput.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<SettingOutput[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SettingOutput[]>(null as any);
  }

  /**
   * 更新Setting
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateSettingInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Settings/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class TenantsServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 通过名称获取租户信息
   * @param body (optional)
   * @return Success
   */
  find(
    body: FindTenantByNameInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<FindTenantResultDto> {
    let url_ = this.baseUrl + '/Tenants/find';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processFind(_response),
        );
      });
  }

  protected processFind(response: AxiosResponse): Promise<FindTenantResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = FindTenantResultDto.fromJS(resultData200);
      return Promise.resolve<FindTenantResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<FindTenantResultDto>(null as any);
  }

  /**
   * 分页获取租户信息
   * @param body (optional)
   * @return Success
   */
  page(
    body: PagingTenantInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<TenantDtoPagedResultDto> {
    let url_ = this.baseUrl + '/Tenants/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<TenantDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TenantDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<TenantDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TenantDtoPagedResultDto>(null as any);
  }

  /**
   * 创建租户
   * @param body (optional)
   * @return Success
   */
  create(
    body: TenantCreateDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<TenantDto> {
    let url_ = this.baseUrl + '/Tenants/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<TenantDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TenantDto.fromJS(resultData200);
      return Promise.resolve<TenantDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TenantDto>(null as any);
  }

  /**
   * 更新租户
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateTenantInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<TenantDto> {
    let url_ = this.baseUrl + '/Tenants/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<TenantDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TenantDto.fromJS(resultData200);
      return Promise.resolve<TenantDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TenantDto>(null as any);
  }

  /**
   * 删除租户
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Tenants/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 获取租户连接字符串
   * @param body (optional)
   * @return Success
   */
  getConnectionString(
    body: IdInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<string> {
    let url_ = this.baseUrl + '/Tenants/getConnectionString';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processGetConnectionString(_response),
        );
      });
  }

  protected processGetConnectionString(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * 更新租户连接字符串
   * @param body (optional)
   * @return Success
   */
  updateConnectionString(
    body: UpdateConnectionStringInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Tenants/updateConnectionString';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdateConnectionString(_response),
        );
      });
  }

  protected processUpdateConnectionString(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 删除租户连接字符串
   * @param body (optional)
   * @return Success
   */
  deleteConnectionString(
    body: IdInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/Tenants/deleteConnectionString';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDeleteConnectionString(_response),
        );
      });
  }

  protected processDeleteConnectionString(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class UsersServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 分页获取用户信息
   * @param body (optional)
   * @return Success
   */
  page(
    body: PagingUserListInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<IdentityUserDtoPagedResultDto> {
    let url_ = this.baseUrl + '/Users/page';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processPage(_response),
        );
      });
  }

  protected processPage(response: AxiosResponse): Promise<IdentityUserDtoPagedResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityUserDtoPagedResultDto.fromJS(resultData200);
      return Promise.resolve<IdentityUserDtoPagedResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityUserDtoPagedResultDto>(null as any);
  }

  /**
   * 导出用户列表
   * @param body (optional)
   * @return Success
   */
  export(
    body: PagingUserListInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + '/Users/export';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      responseType: 'blob',
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processExport(_response),
        );
      });
  }

  protected processExport(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers['content-disposition']
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: new Blob([response.data], { type: response.headers['content-type'] }),
        headers: _headers,
      });
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * 创建用户
   * @param body (optional)
   * @return Success
   */
  create(
    body: IdentityUserCreateDto | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<IdentityUserDto> {
    let url_ = this.baseUrl + '/Users/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCreate(_response),
        );
      });
  }

  protected processCreate(response: AxiosResponse): Promise<IdentityUserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityUserDto.fromJS(resultData200);
      return Promise.resolve<IdentityUserDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityUserDto>(null as any);
  }

  /**
   * 编辑用户
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateUserInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<IdentityUserDto> {
    let url_ = this.baseUrl + '/Users/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processUpdate(_response),
        );
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<IdentityUserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityUserDto.fromJS(resultData200);
      return Promise.resolve<IdentityUserDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityUserDto>(null as any);
  }

  /**
   * 删除用户
   * @param body (optional)
   * @return Success
   */
  delete(body: IdInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Users/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processDelete(_response),
        );
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * 获取用户角色信息
   * @param body (optional)
   * @return Success
   */
  role(
    body: IdInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<IdentityRoleDtoListResultDto> {
    let url_ = this.baseUrl + '/Users/role';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processRole(_response),
        );
      });
  }

  protected processRole(response: AxiosResponse): Promise<IdentityRoleDtoListResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IdentityRoleDtoListResultDto.fromJS(resultData200);
      return Promise.resolve<IdentityRoleDtoListResultDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<IdentityRoleDtoListResultDto>(null as any);
  }

  /**
   * 修改当前用户密码
   * @param body (optional)
   * @return Success
   */
  changePassword(
    body: ChangePasswordInput | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<boolean> {
    let url_ = this.baseUrl + '/Users/changePassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processChangePassword(_response),
        );
      });
  }

  protected processChangePassword(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * 锁定用户
   * @param body (optional)
   * @return Success
   */
  lock(body: LockUserInput | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Users/lock';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processLock(_response),
        );
      });
  }

  protected processLock(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class VisionDemoServiceProxy extends ServiceProxyBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    super();
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * 设备状态统计 demo
   * @return Success
   */
  totalState(cancelToken?: CancelToken | undefined): Promise<TotalStateDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/total-state';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processTotalState(_response),
        );
      });
  }

  protected processTotalState(response: AxiosResponse): Promise<TotalStateDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TotalStateDto.fromJS(resultData200);
      return Promise.resolve<TotalStateDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TotalStateDto>(null as any);
  }

  /**
   * 设备报警demo
   * @return Success
   */
  totalAlarm(cancelToken?: CancelToken | undefined): Promise<TotalAlarmDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/total-alarm';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processTotalAlarm(_response),
        );
      });
  }

  protected processTotalAlarm(response: AxiosResponse): Promise<TotalAlarmDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TotalAlarmDto.fromJS(resultData200);
      return Promise.resolve<TotalAlarmDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TotalAlarmDto>(null as any);
  }

  /**
   * 地图数据demo
   * @return Success
   */
  mapData(cancelToken?: CancelToken | undefined): Promise<MapDataDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/map-data';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processMapData(_response),
        );
      });
  }

  protected processMapData(response: AxiosResponse): Promise<MapDataDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = MapDataDto.fromJS(resultData200);
      return Promise.resolve<MapDataDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<MapDataDto>(null as any);
  }

  /**
   * 根据客户返回设备状态汇总
   * @param customName (optional)
   * @return Success
   */
  customState(
    customName: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<Int32NameValue[]> {
    let url_ = this.baseUrl + '/api/app/vision-demo/custom-state?';
    if (customName === null) throw new Error("The parameter 'customName' cannot be null.");
    else if (customName !== undefined)
      url_ += 'customName=' + encodeURIComponent('' + customName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCustomState(_response),
        );
      });
  }

  protected processCustomState(response: AxiosResponse): Promise<Int32NameValue[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Int32NameValue.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Int32NameValue[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<Int32NameValue[]>(null as any);
  }

  /**
   * 新能源电池组运行记录
   * @return Success
   */
  batterySummary(cancelToken?: CancelToken | undefined): Promise<TotalBatteryInfoDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/battery-summary';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processBatterySummary(_response),
        );
      });
  }

  protected processBatterySummary(response: AxiosResponse): Promise<TotalBatteryInfoDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TotalBatteryInfoDto.fromJS(resultData200);
      return Promise.resolve<TotalBatteryInfoDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TotalBatteryInfoDto>(null as any);
  }

  /**
   * 获取一笔报警
   * @return Success
   */
  oneAlarm(cancelToken?: CancelToken | undefined): Promise<AlarmDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/one-alarm';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processOneAlarm(_response),
        );
      });
  }

  protected processOneAlarm(response: AxiosResponse): Promise<AlarmDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AlarmDto.fromJS(resultData200);
      return Promise.resolve<AlarmDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<AlarmDto>(null as any);
  }

  /**
   * 产品市场占比 demo
   * @return Success
   */
  marketShare(cancelToken?: CancelToken | undefined): Promise<TotalStateDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/market-share';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processMarketShare(_response),
        );
      });
  }

  protected processMarketShare(response: AxiosResponse): Promise<TotalStateDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TotalStateDto.fromJS(resultData200);
      return Promise.resolve<TotalStateDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TotalStateDto>(null as any);
  }

  /**
   * @return Success
   */
  sendAlarmMessage(cancelToken?: CancelToken | undefined): Promise<boolean> {
    let url_ = this.baseUrl + '/api/app/vision-demo/send-alarm-message';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processSendAlarmMessage(_response),
        );
      });
  }

  protected processSendAlarmMessage(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * 电压折线图
   * @return Success
   */
  voltageData(cancelToken?: CancelToken | undefined): Promise<TotalVoltageDto[]> {
    let url_ = this.baseUrl + '/api/app/vision-demo/voltage-data';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processVoltageData(_response),
        );
      });
  }

  protected processVoltageData(response: AxiosResponse): Promise<TotalVoltageDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(TotalVoltageDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<TotalVoltageDto[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TotalVoltageDto[]>(null as any);
  }

  /**
   * @return Success
   */
  localizableStringTest(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/api/app/vision-demo/localizable-string-test';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processLocalizableStringTest(_response),
        );
      });
  }

  protected processLocalizableStringTest(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param customName (optional)
   * @return Success
   */
  monthTime(
    customName: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<MonthTimeDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/month-time?';
    if (customName === null) throw new Error("The parameter 'customName' cannot be null.");
    else if (customName !== undefined)
      url_ += 'customName=' + encodeURIComponent('' + customName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processMonthTime(_response),
        );
      });
  }

  protected processMonthTime(response: AxiosResponse): Promise<MonthTimeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = MonthTimeDto.fromJS(resultData200);
      return Promise.resolve<MonthTimeDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<MonthTimeDto>(null as any);
  }

  /**
   * @param machineCode (optional)
   * @return Success
   */
  batteryEnergy(
    machineCode: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<BatteryEnergyDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/battery-energy?';
    if (machineCode === null) throw new Error("The parameter 'machineCode' cannot be null.");
    else if (machineCode !== undefined)
      url_ += 'machineCode=' + encodeURIComponent('' + machineCode) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processBatteryEnergy(_response),
        );
      });
  }

  protected processBatteryEnergy(response: AxiosResponse): Promise<BatteryEnergyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = BatteryEnergyDto.fromJS(resultData200);
      return Promise.resolve<BatteryEnergyDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<BatteryEnergyDto>(null as any);
  }

  /**
   * @param machineCode (optional)
   * @return Success
   */
  cellVoltage(
    machineCode: string | undefined,
    cancelToken?: CancelToken | undefined,
  ): Promise<TotalVoltageDto> {
    let url_ = this.baseUrl + '/api/app/vision-demo/cell-voltage?';
    if (machineCode === null) throw new Error("The parameter 'machineCode' cannot be null.");
    else if (machineCode !== undefined)
      url_ += 'machineCode=' + encodeURIComponent('' + machineCode) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(url_, _response, (_response: AxiosResponse) =>
          this.processCellVoltage(_response),
        );
      });
  }

  protected processCellVoltage(response: AxiosResponse): Promise<TotalVoltageDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TotalVoltageDto.fromJS(resultData200);
      return Promise.resolve<TotalVoltageDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = RemoteServiceErrorResponse.fromJS(resultData403);
      return throwException('Forbidden', status, _responseText, _headers, result403);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = RemoteServiceErrorResponse.fromJS(resultData401);
      return throwException('Unauthorized', status, _responseText, _headers, result401);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = RemoteServiceErrorResponse.fromJS(resultData400);
      return throwException('Bad Request', status, _responseText, _headers, result400);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = RemoteServiceErrorResponse.fromJS(resultData404);
      return throwException('Not Found', status, _responseText, _headers, result404);
    } else if (status === 501) {
      const _responseText = response.data;
      let result501: any = null;
      let resultData501 = _responseText;
      result501 = RemoteServiceErrorResponse.fromJS(resultData501);
      return throwException('Server Error', status, _responseText, _headers, result501);
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = RemoteServiceErrorResponse.fromJS(resultData500);
      return throwException('Server Error', status, _responseText, _headers, result500);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<TotalVoltageDto>(null as any);
  }
}

export class AbpLoginResult implements IAbpLoginResult {
  result!: LoginResultType;
  readonly description!: string | undefined;

  constructor(data?: IAbpLoginResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
      (<any>this).description = _data['description'];
    }
  }

  static fromJS(data: any): AbpLoginResult {
    data = typeof data === 'object' ? data : {};
    let result = new AbpLoginResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    data['description'] = this.description;
    return data;
  }
}

export interface IAbpLoginResult {
  result: LoginResultType;
  description: string | undefined;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
  uniqueName!: string | undefined;
  name!: string | undefined;
  httpMethod!: string | undefined;
  url!: string | undefined;
  supportedVersions!: string[] | undefined;
  parametersOnMethod!: MethodParameterApiDescriptionModel[] | undefined;
  parameters!: ParameterApiDescriptionModel[] | undefined;
  returnValue!: ReturnValueApiDescriptionModel;
  allowAnonymous!: boolean | undefined;
  implementFrom!: string | undefined;

  constructor(data?: IActionApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.uniqueName = _data['uniqueName'];
      this.name = _data['name'];
      this.httpMethod = _data['httpMethod'];
      this.url = _data['url'];
      if (Array.isArray(_data['supportedVersions'])) {
        this.supportedVersions = [] as any;
        for (let item of _data['supportedVersions']) this.supportedVersions!.push(item);
      }
      if (Array.isArray(_data['parametersOnMethod'])) {
        this.parametersOnMethod = [] as any;
        for (let item of _data['parametersOnMethod'])
          this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
      }
      if (Array.isArray(_data['parameters'])) {
        this.parameters = [] as any;
        for (let item of _data['parameters'])
          this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
      }
      this.returnValue = _data['returnValue']
        ? ReturnValueApiDescriptionModel.fromJS(_data['returnValue'])
        : <any>undefined;
      this.allowAnonymous = _data['allowAnonymous'];
      this.implementFrom = _data['implementFrom'];
    }
  }

  static fromJS(data: any): ActionApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new ActionApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['uniqueName'] = this.uniqueName;
    data['name'] = this.name;
    data['httpMethod'] = this.httpMethod;
    data['url'] = this.url;
    if (Array.isArray(this.supportedVersions)) {
      data['supportedVersions'] = [];
      for (let item of this.supportedVersions) data['supportedVersions'].push(item);
    }
    if (Array.isArray(this.parametersOnMethod)) {
      data['parametersOnMethod'] = [];
      for (let item of this.parametersOnMethod) data['parametersOnMethod'].push(item.toJSON());
    }
    if (Array.isArray(this.parameters)) {
      data['parameters'] = [];
      for (let item of this.parameters) data['parameters'].push(item.toJSON());
    }
    data['returnValue'] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
    data['allowAnonymous'] = this.allowAnonymous;
    data['implementFrom'] = this.implementFrom;
    return data;
  }
}

export interface IActionApiDescriptionModel {
  uniqueName: string | undefined;
  name: string | undefined;
  httpMethod: string | undefined;
  url: string | undefined;
  supportedVersions: string[] | undefined;
  parametersOnMethod: MethodParameterApiDescriptionModel[] | undefined;
  parameters: ParameterApiDescriptionModel[] | undefined;
  returnValue: ReturnValueApiDescriptionModel;
  allowAnonymous: boolean | undefined;
  implementFrom: string | undefined;
}

export class AddRoleToOrganizationUnitInput implements IAddRoleToOrganizationUnitInput {
  roleId!: string[] | undefined;
  organizationUnitId!: string;

  constructor(data?: IAddRoleToOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['roleId'])) {
        this.roleId = [] as any;
        for (let item of _data['roleId']) this.roleId!.push(item);
      }
      this.organizationUnitId = _data['organizationUnitId'];
    }
  }

  static fromJS(data: any): AddRoleToOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new AddRoleToOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.roleId)) {
      data['roleId'] = [];
      for (let item of this.roleId) data['roleId'].push(item);
    }
    data['organizationUnitId'] = this.organizationUnitId;
    return data;
  }
}

export interface IAddRoleToOrganizationUnitInput {
  roleId: string[] | undefined;
  organizationUnitId: string;
}

export class AddUserToOrganizationUnitInput implements IAddUserToOrganizationUnitInput {
  userId!: string[] | undefined;
  organizationUnitId!: string;

  constructor(data?: IAddUserToOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['userId'])) {
        this.userId = [] as any;
        for (let item of _data['userId']) this.userId!.push(item);
      }
      this.organizationUnitId = _data['organizationUnitId'];
    }
  }

  static fromJS(data: any): AddUserToOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new AddUserToOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.userId)) {
      data['userId'] = [];
      for (let item of this.userId) data['userId'].push(item);
    }
    data['organizationUnitId'] = this.organizationUnitId;
    return data;
  }
}

export interface IAddUserToOrganizationUnitInput {
  userId: string[] | undefined;
  organizationUnitId: string;
}

export class AggregateRouteConfig implements IAggregateRouteConfig {
  routeKey!: string | undefined;
  parameter!: string | undefined;
  jsonPath!: string | undefined;

  constructor(data?: IAggregateRouteConfig) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.routeKey = _data['routeKey'];
      this.parameter = _data['parameter'];
      this.jsonPath = _data['jsonPath'];
    }
  }

  static fromJS(data: any): AggregateRouteConfig {
    data = typeof data === 'object' ? data : {};
    let result = new AggregateRouteConfig();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['routeKey'] = this.routeKey;
    data['parameter'] = this.parameter;
    data['jsonPath'] = this.jsonPath;
    return data;
  }
}

export interface IAggregateRouteConfig {
  routeKey: string | undefined;
  parameter: string | undefined;
  jsonPath: string | undefined;
}

export class AlarmDto implements IAlarmDto {
  id!: number;
  custom!: string | undefined;
  alarmText!: string | undefined;
  alarmStatus!: string | undefined;
  creationTime!: string | undefined;

  constructor(data?: IAlarmDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.custom = _data['custom'];
      this.alarmText = _data['alarmText'];
      this.alarmStatus = _data['alarmStatus'];
      this.creationTime = _data['creationTime'];
    }
  }

  static fromJS(data: any): AlarmDto {
    data = typeof data === 'object' ? data : {};
    let result = new AlarmDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['custom'] = this.custom;
    data['alarmText'] = this.alarmText;
    data['alarmStatus'] = this.alarmStatus;
    data['creationTime'] = this.creationTime;
    return data;
  }
}

export interface IAlarmDto {
  id: number;
  custom: string | undefined;
  alarmText: string | undefined;
  alarmStatus: string | undefined;
  creationTime: string | undefined;
}

export class AlarmOutputDto implements IAlarmOutputDto {
  id!: string;
  alarmTitle!: string | undefined;
  alarmContent!: string | undefined;
  startTime!: dayjs.Dayjs;
  endTime!: dayjs.Dayjs | undefined;
  duration!: number | undefined;
  alarmStatus!: AlarmStatus;
  serverity!: ServerityLevel;
  originator!: string | undefined;
  deviceName!: string | undefined;
  originatorId!: string;
  deviceId!: string;

  constructor(data?: IAlarmOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.alarmTitle = _data['alarmTitle'];
      this.alarmContent = _data['alarmContent'];
      this.startTime = _data['startTime'] ? dayjs(_data['startTime'].toString()) : <any>undefined;
      this.endTime = _data['endTime'] ? dayjs(_data['endTime'].toString()) : <any>undefined;
      this.duration = _data['duration'];
      this.alarmStatus = _data['alarmStatus'];
      this.serverity = _data['serverity'];
      this.originator = _data['originator'];
      this.deviceName = _data['deviceName'];
      this.originatorId = _data['originatorId'];
      this.deviceId = _data['deviceId'];
    }
  }

  static fromJS(data: any): AlarmOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new AlarmOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['alarmTitle'] = this.alarmTitle;
    data['alarmContent'] = this.alarmContent;
    data['startTime'] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toLocaleString() : <any>undefined;
    data['duration'] = this.duration;
    data['alarmStatus'] = this.alarmStatus;
    data['serverity'] = this.serverity;
    data['originator'] = this.originator;
    data['deviceName'] = this.deviceName;
    data['originatorId'] = this.originatorId;
    data['deviceId'] = this.deviceId;
    return data;
  }
}

export interface IAlarmOutputDto {
  id: string;
  alarmTitle: string | undefined;
  alarmContent: string | undefined;
  startTime: dayjs.Dayjs;
  endTime: dayjs.Dayjs | undefined;
  duration: number | undefined;
  alarmStatus: AlarmStatus;
  serverity: ServerityLevel;
  originator: string | undefined;
  deviceName: string | undefined;
  originatorId: string;
  deviceId: string;
}

export class AlarmOutputDtoPagedResultDto implements IAlarmOutputDtoPagedResultDto {
  items!: AlarmOutputDto[] | undefined;
  totalCount!: number;

  constructor(data?: IAlarmOutputDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AlarmOutputDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): AlarmOutputDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new AlarmOutputDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IAlarmOutputDtoPagedResultDto {
  items: AlarmOutputDto[] | undefined;
  totalCount: number;
}

export enum AlarmStatus {
  Active = 'Active',
  Clear = 'Clear',
  End = 'End',
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
  modules!: { [key: string]: ModuleApiDescriptionModel } | undefined;
  types!: { [key: string]: TypeApiDescriptionModel } | undefined;

  constructor(data?: IApplicationApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['modules']) {
        this.modules = {} as any;
        for (let key in _data['modules']) {
          if (_data['modules'].hasOwnProperty(key))
            (<any>this.modules)![key] = _data['modules'][key]
              ? ModuleApiDescriptionModel.fromJS(_data['modules'][key])
              : new ModuleApiDescriptionModel();
        }
      }
      if (_data['types']) {
        this.types = {} as any;
        for (let key in _data['types']) {
          if (_data['types'].hasOwnProperty(key))
            (<any>this.types)![key] = _data['types'][key]
              ? TypeApiDescriptionModel.fromJS(_data['types'][key])
              : new TypeApiDescriptionModel();
        }
      }
    }
  }

  static fromJS(data: any): ApplicationApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.modules) {
      data['modules'] = {};
      for (let key in this.modules) {
        if (this.modules.hasOwnProperty(key))
          (<any>data['modules'])[key] = this.modules[key]
            ? this.modules[key].toJSON()
            : <any>undefined;
      }
    }
    if (this.types) {
      data['types'] = {};
      for (let key in this.types) {
        if (this.types.hasOwnProperty(key))
          (<any>data['types'])[key] = this.types[key] ? this.types[key].toJSON() : <any>undefined;
      }
    }
    return data;
  }
}

export interface IApplicationApiDescriptionModel {
  modules: { [key: string]: ModuleApiDescriptionModel } | undefined;
  types: { [key: string]: TypeApiDescriptionModel } | undefined;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
  grantedPolicies!: { [key: string]: boolean } | undefined;

  constructor(data?: IApplicationAuthConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['grantedPolicies']) {
        this.grantedPolicies = {} as any;
        for (let key in _data['grantedPolicies']) {
          if (_data['grantedPolicies'].hasOwnProperty(key))
            (<any>this.grantedPolicies)![key] = _data['grantedPolicies'][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationAuthConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationAuthConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.grantedPolicies) {
      data['grantedPolicies'] = {};
      for (let key in this.grantedPolicies) {
        if (this.grantedPolicies.hasOwnProperty(key))
          (<any>data['grantedPolicies'])[key] = (<any>this.grantedPolicies)[key];
      }
    }
    return data;
  }
}

export interface IApplicationAuthConfigurationDto {
  grantedPolicies: { [key: string]: boolean } | undefined;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
  localization!: ApplicationLocalizationConfigurationDto;
  auth!: ApplicationAuthConfigurationDto;
  setting!: ApplicationSettingConfigurationDto;
  currentUser!: CurrentUserDto;
  features!: ApplicationFeatureConfigurationDto;
  globalFeatures!: ApplicationGlobalFeatureConfigurationDto;
  multiTenancy!: MultiTenancyInfoDto;
  currentTenant!: CurrentTenantDto;
  timing!: TimingDto;
  clock!: ClockDto;
  objectExtensions!: ObjectExtensionsDto;
  extraProperties!: { [key: string]: any } | undefined;

  constructor(data?: IApplicationConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.localization = _data['localization']
        ? ApplicationLocalizationConfigurationDto.fromJS(_data['localization'])
        : <any>undefined;
      this.auth = _data['auth']
        ? ApplicationAuthConfigurationDto.fromJS(_data['auth'])
        : <any>undefined;
      this.setting = _data['setting']
        ? ApplicationSettingConfigurationDto.fromJS(_data['setting'])
        : <any>undefined;
      this.currentUser = _data['currentUser']
        ? CurrentUserDto.fromJS(_data['currentUser'])
        : <any>undefined;
      this.features = _data['features']
        ? ApplicationFeatureConfigurationDto.fromJS(_data['features'])
        : <any>undefined;
      this.globalFeatures = _data['globalFeatures']
        ? ApplicationGlobalFeatureConfigurationDto.fromJS(_data['globalFeatures'])
        : <any>undefined;
      this.multiTenancy = _data['multiTenancy']
        ? MultiTenancyInfoDto.fromJS(_data['multiTenancy'])
        : <any>undefined;
      this.currentTenant = _data['currentTenant']
        ? CurrentTenantDto.fromJS(_data['currentTenant'])
        : <any>undefined;
      this.timing = _data['timing'] ? TimingDto.fromJS(_data['timing']) : <any>undefined;
      this.clock = _data['clock'] ? ClockDto.fromJS(_data['clock']) : <any>undefined;
      this.objectExtensions = _data['objectExtensions']
        ? ObjectExtensionsDto.fromJS(_data['objectExtensions'])
        : <any>undefined;
      if (_data['extraProperties']) {
        this.extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>this.extraProperties)![key] = _data['extraProperties'][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['localization'] = this.localization ? this.localization.toJSON() : <any>undefined;
    data['auth'] = this.auth ? this.auth.toJSON() : <any>undefined;
    data['setting'] = this.setting ? this.setting.toJSON() : <any>undefined;
    data['currentUser'] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
    data['features'] = this.features ? this.features.toJSON() : <any>undefined;
    data['globalFeatures'] = this.globalFeatures ? this.globalFeatures.toJSON() : <any>undefined;
    data['multiTenancy'] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
    data['currentTenant'] = this.currentTenant ? this.currentTenant.toJSON() : <any>undefined;
    data['timing'] = this.timing ? this.timing.toJSON() : <any>undefined;
    data['clock'] = this.clock ? this.clock.toJSON() : <any>undefined;
    data['objectExtensions'] = this.objectExtensions
      ? this.objectExtensions.toJSON()
      : <any>undefined;
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    return data;
  }
}

export interface IApplicationConfigurationDto {
  localization: ApplicationLocalizationConfigurationDto;
  auth: ApplicationAuthConfigurationDto;
  setting: ApplicationSettingConfigurationDto;
  currentUser: CurrentUserDto;
  features: ApplicationFeatureConfigurationDto;
  globalFeatures: ApplicationGlobalFeatureConfigurationDto;
  multiTenancy: MultiTenancyInfoDto;
  currentTenant: CurrentTenantDto;
  timing: TimingDto;
  clock: ClockDto;
  objectExtensions: ObjectExtensionsDto;
  extraProperties: { [key: string]: any } | undefined;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
  values!: { [key: string]: string } | undefined;

  constructor(data?: IApplicationFeatureConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['values']) {
        this.values = {} as any;
        for (let key in _data['values']) {
          if (_data['values'].hasOwnProperty(key)) (<any>this.values)![key] = _data['values'][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationFeatureConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationFeatureConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.values) {
      data['values'] = {};
      for (let key in this.values) {
        if (this.values.hasOwnProperty(key)) (<any>data['values'])[key] = (<any>this.values)[key];
      }
    }
    return data;
  }
}

export interface IApplicationFeatureConfigurationDto {
  values: { [key: string]: string } | undefined;
}

export class ApplicationGlobalFeatureConfigurationDto
  implements IApplicationGlobalFeatureConfigurationDto
{
  enabledFeatures!: string[] | undefined;

  constructor(data?: IApplicationGlobalFeatureConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['enabledFeatures'])) {
        this.enabledFeatures = [] as any;
        for (let item of _data['enabledFeatures']) this.enabledFeatures!.push(item);
      }
    }
  }

  static fromJS(data: any): ApplicationGlobalFeatureConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationGlobalFeatureConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.enabledFeatures)) {
      data['enabledFeatures'] = [];
      for (let item of this.enabledFeatures) data['enabledFeatures'].push(item);
    }
    return data;
  }
}

export interface IApplicationGlobalFeatureConfigurationDto {
  enabledFeatures: string[] | undefined;
}

export class ApplicationLocalizationConfigurationDto
  implements IApplicationLocalizationConfigurationDto
{
  values!: { [key: string]: { [key: string]: string } } | undefined;
  resources!: { [key: string]: ApplicationLocalizationResourceDto } | undefined;
  languages!: LanguageInfo[] | undefined;
  currentCulture!: CurrentCultureDto;
  defaultResourceName!: string | undefined;
  languagesMap!: { [key: string]: NameValue[] } | undefined;
  languageFilesMap!: { [key: string]: NameValue[] } | undefined;

  constructor(data?: IApplicationLocalizationConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['values']) {
        this.values = {} as any;
        for (let key in _data['values']) {
          if (_data['values'].hasOwnProperty(key))
            (<any>this.values)![key] =
              _data['values'][key] !== undefined ? _data['values'][key] : {};
        }
      }
      if (_data['resources']) {
        this.resources = {} as any;
        for (let key in _data['resources']) {
          if (_data['resources'].hasOwnProperty(key))
            (<any>this.resources)![key] = _data['resources'][key]
              ? ApplicationLocalizationResourceDto.fromJS(_data['resources'][key])
              : new ApplicationLocalizationResourceDto();
        }
      }
      if (Array.isArray(_data['languages'])) {
        this.languages = [] as any;
        for (let item of _data['languages']) this.languages!.push(LanguageInfo.fromJS(item));
      }
      this.currentCulture = _data['currentCulture']
        ? CurrentCultureDto.fromJS(_data['currentCulture'])
        : <any>undefined;
      this.defaultResourceName = _data['defaultResourceName'];
      if (_data['languagesMap']) {
        this.languagesMap = {} as any;
        for (let key in _data['languagesMap']) {
          if (_data['languagesMap'].hasOwnProperty(key))
            (<any>this.languagesMap)![key] = _data['languagesMap'][key]
              ? _data['languagesMap'][key].map((i: any) => NameValue.fromJS(i))
              : [];
        }
      }
      if (_data['languageFilesMap']) {
        this.languageFilesMap = {} as any;
        for (let key in _data['languageFilesMap']) {
          if (_data['languageFilesMap'].hasOwnProperty(key))
            (<any>this.languageFilesMap)![key] = _data['languageFilesMap'][key]
              ? _data['languageFilesMap'][key].map((i: any) => NameValue.fromJS(i))
              : [];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationLocalizationConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationLocalizationConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.values) {
      data['values'] = {};
      for (let key in this.values) {
        if (this.values.hasOwnProperty(key)) (<any>data['values'])[key] = (<any>this.values)[key];
      }
    }
    if (this.resources) {
      data['resources'] = {};
      for (let key in this.resources) {
        if (this.resources.hasOwnProperty(key))
          (<any>data['resources'])[key] = this.resources[key]
            ? this.resources[key].toJSON()
            : <any>undefined;
      }
    }
    if (Array.isArray(this.languages)) {
      data['languages'] = [];
      for (let item of this.languages) data['languages'].push(item.toJSON());
    }
    data['currentCulture'] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
    data['defaultResourceName'] = this.defaultResourceName;
    if (this.languagesMap) {
      data['languagesMap'] = {};
      for (let key in this.languagesMap) {
        if (this.languagesMap.hasOwnProperty(key))
          (<any>data['languagesMap'])[key] = (<any>this.languagesMap)[key];
      }
    }
    if (this.languageFilesMap) {
      data['languageFilesMap'] = {};
      for (let key in this.languageFilesMap) {
        if (this.languageFilesMap.hasOwnProperty(key))
          (<any>data['languageFilesMap'])[key] = (<any>this.languageFilesMap)[key];
      }
    }
    return data;
  }
}

export interface IApplicationLocalizationConfigurationDto {
  values: { [key: string]: { [key: string]: string } } | undefined;
  resources: { [key: string]: ApplicationLocalizationResourceDto } | undefined;
  languages: LanguageInfo[] | undefined;
  currentCulture: CurrentCultureDto;
  defaultResourceName: string | undefined;
  languagesMap: { [key: string]: NameValue[] } | undefined;
  languageFilesMap: { [key: string]: NameValue[] } | undefined;
}

export class ApplicationLocalizationDto implements IApplicationLocalizationDto {
  resources!: { [key: string]: ApplicationLocalizationResourceDto } | undefined;

  constructor(data?: IApplicationLocalizationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['resources']) {
        this.resources = {} as any;
        for (let key in _data['resources']) {
          if (_data['resources'].hasOwnProperty(key))
            (<any>this.resources)![key] = _data['resources'][key]
              ? ApplicationLocalizationResourceDto.fromJS(_data['resources'][key])
              : new ApplicationLocalizationResourceDto();
        }
      }
    }
  }

  static fromJS(data: any): ApplicationLocalizationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationLocalizationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.resources) {
      data['resources'] = {};
      for (let key in this.resources) {
        if (this.resources.hasOwnProperty(key))
          (<any>data['resources'])[key] = this.resources[key]
            ? this.resources[key].toJSON()
            : <any>undefined;
      }
    }
    return data;
  }
}

export interface IApplicationLocalizationDto {
  resources: { [key: string]: ApplicationLocalizationResourceDto } | undefined;
}

export class ApplicationLocalizationResourceDto implements IApplicationLocalizationResourceDto {
  texts!: { [key: string]: string } | undefined;
  baseResources!: string[] | undefined;

  constructor(data?: IApplicationLocalizationResourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['texts']) {
        this.texts = {} as any;
        for (let key in _data['texts']) {
          if (_data['texts'].hasOwnProperty(key)) (<any>this.texts)![key] = _data['texts'][key];
        }
      }
      if (Array.isArray(_data['baseResources'])) {
        this.baseResources = [] as any;
        for (let item of _data['baseResources']) this.baseResources!.push(item);
      }
    }
  }

  static fromJS(data: any): ApplicationLocalizationResourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationLocalizationResourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.texts) {
      data['texts'] = {};
      for (let key in this.texts) {
        if (this.texts.hasOwnProperty(key)) (<any>data['texts'])[key] = (<any>this.texts)[key];
      }
    }
    if (Array.isArray(this.baseResources)) {
      data['baseResources'] = [];
      for (let item of this.baseResources) data['baseResources'].push(item);
    }
    return data;
  }
}

export interface IApplicationLocalizationResourceDto {
  texts: { [key: string]: string } | undefined;
  baseResources: string[] | undefined;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
  values!: { [key: string]: string } | undefined;

  constructor(data?: IApplicationSettingConfigurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['values']) {
        this.values = {} as any;
        for (let key in _data['values']) {
          if (_data['values'].hasOwnProperty(key)) (<any>this.values)![key] = _data['values'][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationSettingConfigurationDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationSettingConfigurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.values) {
      data['values'] = {};
      for (let key in this.values) {
        if (this.values.hasOwnProperty(key)) (<any>data['values'])[key] = (<any>this.values)[key];
      }
    }
    return data;
  }
}

export interface IApplicationSettingConfigurationDto {
  values: { [key: string]: string } | undefined;
}

export class BatteryEnergyDto implements IBatteryEnergyDto {
  city!: string | undefined;
  state!: string | undefined;
  value!: number;

  constructor(data?: IBatteryEnergyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.city = _data['city'];
      this.state = _data['state'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): BatteryEnergyDto {
    data = typeof data === 'object' ? data : {};
    let result = new BatteryEnergyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['city'] = this.city;
    data['state'] = this.state;
    data['value'] = this.value;
    return data;
  }
}

export interface IBatteryEnergyDto {
  city: string | undefined;
  state: string | undefined;
  value: number;
}

export class BatteryInfoDto implements IBatteryInfoDto {
  id!: number;
  name!: string | undefined;
  value!: number;
  unit!: string | undefined;

  constructor(data?: IBatteryInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.unit = _data['unit'];
    }
  }

  static fromJS(data: any): BatteryInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new BatteryInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    data['unit'] = this.unit;
    return data;
  }
}

export interface IBatteryInfoDto {
  id: number;
  name: string | undefined;
  value: number;
  unit: string | undefined;
}

export class BuildDeviceDto implements IBuildDeviceDto {
  id!: string;
  deviceName!: string | undefined;
  deviceType!: DeviceType;
  identityType!: IdentityType;
  timeout!: number;

  constructor(data?: IBuildDeviceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.deviceName = _data['deviceName'];
      this.deviceType = _data['deviceType'];
      this.identityType = _data['identityType'];
      this.timeout = _data['timeout'];
    }
  }

  static fromJS(data: any): BuildDeviceDto {
    data = typeof data === 'object' ? data : {};
    let result = new BuildDeviceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['deviceName'] = this.deviceName;
    data['deviceType'] = this.deviceType;
    data['identityType'] = this.identityType;
    data['timeout'] = this.timeout;
    return data;
  }
}

export interface IBuildDeviceDto {
  id: string;
  deviceName: string | undefined;
  deviceType: DeviceType;
  identityType: IdentityType;
  timeout: number;
}

export class BuildTenantAdminInputDto implements IBuildTenantAdminInputDto {
  tenantName!: string | undefined;
  adminEmailAddress!: string | undefined;
  adminPassword!: string | undefined;
  phoneNumber!: string | undefined;

  constructor(data?: IBuildTenantAdminInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantName = _data['tenantName'];
      this.adminEmailAddress = _data['adminEmailAddress'];
      this.adminPassword = _data['adminPassword'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): BuildTenantAdminInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new BuildTenantAdminInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantName'] = this.tenantName;
    data['adminEmailAddress'] = this.adminEmailAddress;
    data['adminPassword'] = this.adminPassword;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IBuildTenantAdminInputDto {
  tenantName: string | undefined;
  adminEmailAddress: string | undefined;
  adminPassword: string | undefined;
  phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
  currentPassword!: string | undefined;
  newPassword!: string;

  constructor(data?: IChangePasswordInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data['currentPassword'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ChangePasswordInput {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['currentPassword'] = this.currentPassword;
    data['newPassword'] = this.newPassword;
    return data;
  }
}

export interface IChangePasswordInput {
  currentPassword: string | undefined;
  newPassword: string;
}

export class ChinaDataDto implements IChinaDataDto {
  provinceData!: any[] | undefined;
  cityData!: { [key: string]: any[] } | undefined;

  constructor(data?: IChinaDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['provinceData'])) {
        this.provinceData = [] as any;
        for (let item of _data['provinceData']) this.provinceData!.push(item);
      }
      if (_data['cityData']) {
        this.cityData = {} as any;
        for (let key in _data['cityData']) {
          if (_data['cityData'].hasOwnProperty(key))
            (<any>this.cityData)![key] = _data['cityData'][key];
        }
      }
    }
  }

  static fromJS(data: any): ChinaDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChinaDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.provinceData)) {
      data['provinceData'] = [];
      for (let item of this.provinceData) data['provinceData'].push(item);
    }
    if (this.cityData) {
      data['cityData'] = {};
      for (let key in this.cityData) {
        if (this.cityData.hasOwnProperty(key))
          (<any>data['cityData'])[key] = (<any>this.cityData)[key];
      }
    }
    return data;
  }
}

export interface IChinaDataDto {
  provinceData: any[] | undefined;
  cityData: { [key: string]: any[] } | undefined;
}

export class ClearAlarmInputDto implements IClearAlarmInputDto {
  deviceId!: string;
  alarmId!: string;

  constructor(data?: IClearAlarmInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deviceId = _data['deviceId'];
      this.alarmId = _data['alarmId'];
    }
  }

  static fromJS(data: any): ClearAlarmInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new ClearAlarmInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['deviceId'] = this.deviceId;
    data['alarmId'] = this.alarmId;
    return data;
  }
}

export interface IClearAlarmInputDto {
  deviceId: string;
  alarmId: string;
}

export class ClockDto implements IClockDto {
  kind!: string | undefined;

  constructor(data?: IClockDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.kind = _data['kind'];
    }
  }

  static fromJS(data: any): ClockDto {
    data = typeof data === 'object' ? data : {};
    let result = new ClockDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['kind'] = this.kind;
    return data;
  }
}

export interface IClockDto {
  kind: string | undefined;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
  controllerName!: string | undefined;
  controllerGroupName!: string | undefined;
  isRemoteService!: boolean;
  isIntegrationService!: boolean;
  apiVersion!: string | undefined;
  type!: string | undefined;
  interfaces!: ControllerInterfaceApiDescriptionModel[] | undefined;
  actions!: { [key: string]: ActionApiDescriptionModel } | undefined;

  constructor(data?: IControllerApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.controllerName = _data['controllerName'];
      this.controllerGroupName = _data['controllerGroupName'];
      this.isRemoteService = _data['isRemoteService'];
      this.isIntegrationService = _data['isIntegrationService'];
      this.apiVersion = _data['apiVersion'];
      this.type = _data['type'];
      if (Array.isArray(_data['interfaces'])) {
        this.interfaces = [] as any;
        for (let item of _data['interfaces'])
          this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
      }
      if (_data['actions']) {
        this.actions = {} as any;
        for (let key in _data['actions']) {
          if (_data['actions'].hasOwnProperty(key))
            (<any>this.actions)![key] = _data['actions'][key]
              ? ActionApiDescriptionModel.fromJS(_data['actions'][key])
              : new ActionApiDescriptionModel();
        }
      }
    }
  }

  static fromJS(data: any): ControllerApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new ControllerApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['controllerName'] = this.controllerName;
    data['controllerGroupName'] = this.controllerGroupName;
    data['isRemoteService'] = this.isRemoteService;
    data['isIntegrationService'] = this.isIntegrationService;
    data['apiVersion'] = this.apiVersion;
    data['type'] = this.type;
    if (Array.isArray(this.interfaces)) {
      data['interfaces'] = [];
      for (let item of this.interfaces) data['interfaces'].push(item.toJSON());
    }
    if (this.actions) {
      data['actions'] = {};
      for (let key in this.actions) {
        if (this.actions.hasOwnProperty(key))
          (<any>data['actions'])[key] = this.actions[key]
            ? this.actions[key].toJSON()
            : <any>undefined;
      }
    }
    return data;
  }
}

export interface IControllerApiDescriptionModel {
  controllerName: string | undefined;
  controllerGroupName: string | undefined;
  isRemoteService: boolean;
  isIntegrationService: boolean;
  apiVersion: string | undefined;
  type: string | undefined;
  interfaces: ControllerInterfaceApiDescriptionModel[] | undefined;
  actions: { [key: string]: ActionApiDescriptionModel } | undefined;
}

export class ControllerInterfaceApiDescriptionModel
  implements IControllerInterfaceApiDescriptionModel
{
  type!: string | undefined;
  name!: string | undefined;
  methods!: InterfaceMethodApiDescriptionModel[] | undefined;

  constructor(data?: IControllerInterfaceApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.name = _data['name'];
      if (Array.isArray(_data['methods'])) {
        this.methods = [] as any;
        for (let item of _data['methods'])
          this.methods!.push(InterfaceMethodApiDescriptionModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new ControllerInterfaceApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['name'] = this.name;
    if (Array.isArray(this.methods)) {
      data['methods'] = [];
      for (let item of this.methods) data['methods'].push(item.toJSON());
    }
    return data;
  }
}

export interface IControllerInterfaceApiDescriptionModel {
  type: string | undefined;
  name: string | undefined;
  methods: InterfaceMethodApiDescriptionModel[] | undefined;
}

export class CreateAlarmInputDto implements ICreateAlarmInputDto {
  title!: string | undefined;
  content!: string | undefined;
  deviceId!: string;
  telemetryId!: string | undefined;

  constructor(data?: ICreateAlarmInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.content = _data['content'];
      this.deviceId = _data['deviceId'];
      this.telemetryId = _data['telemetryId'];
    }
  }

  static fromJS(data: any): CreateAlarmInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateAlarmInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['content'] = this.content;
    data['deviceId'] = this.deviceId;
    data['telemetryId'] = this.telemetryId;
    return data;
  }
}

export interface ICreateAlarmInputDto {
  title: string | undefined;
  content: string | undefined;
  deviceId: string;
  telemetryId: string | undefined;
}

export class CreateDataDictinaryDetailInput implements ICreateDataDictinaryDetailInput {
  id!: string;
  code!: string | undefined;
  displayText!: string | undefined;
  description!: string | undefined;
  order!: number;

  constructor(data?: ICreateDataDictinaryDetailInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.displayText = _data['displayText'];
      this.description = _data['description'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): CreateDataDictinaryDetailInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDataDictinaryDetailInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['displayText'] = this.displayText;
    data['description'] = this.description;
    data['order'] = this.order;
    return data;
  }
}

export interface ICreateDataDictinaryDetailInput {
  id: string;
  code: string | undefined;
  displayText: string | undefined;
  description: string | undefined;
  order: number;
}

export class CreateDataDictinaryInput implements ICreateDataDictinaryInput {
  code!: string | undefined;
  displayText!: string | undefined;
  description!: string | undefined;

  constructor(data?: ICreateDataDictinaryInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data['code'];
      this.displayText = _data['displayText'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): CreateDataDictinaryInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDataDictinaryInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['code'] = this.code;
    data['displayText'] = this.displayText;
    data['description'] = this.description;
    return data;
  }
}

export interface ICreateDataDictinaryInput {
  code: string | undefined;
  displayText: string | undefined;
  description: string | undefined;
}

export class CreateLanguageInput implements ICreateLanguageInput {
  cultureName!: string | undefined;
  uiCultureName!: string | undefined;
  displayName!: string | undefined;
  flagIcon!: string | undefined;
  isEnabled!: boolean;

  constructor(data?: ICreateLanguageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cultureName = _data['cultureName'];
      this.uiCultureName = _data['uiCultureName'];
      this.displayName = _data['displayName'];
      this.flagIcon = _data['flagIcon'];
      this.isEnabled = _data['isEnabled'];
    }
  }

  static fromJS(data: any): CreateLanguageInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateLanguageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cultureName'] = this.cultureName;
    data['uiCultureName'] = this.uiCultureName;
    data['displayName'] = this.displayName;
    data['flagIcon'] = this.flagIcon;
    data['isEnabled'] = this.isEnabled;
    return data;
  }
}

export interface ICreateLanguageInput {
  cultureName: string | undefined;
  uiCultureName: string | undefined;
  displayName: string | undefined;
  flagIcon: string | undefined;
  isEnabled: boolean;
}

export class CreateLanguageTextInput implements ICreateLanguageTextInput {
  resourceName!: string | undefined;
  cultureName!: string | undefined;
  name!: string | undefined;
  value!: string | undefined;

  constructor(data?: ICreateLanguageTextInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.resourceName = _data['resourceName'];
      this.cultureName = _data['cultureName'];
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): CreateLanguageTextInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateLanguageTextInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['resourceName'] = this.resourceName;
    data['cultureName'] = this.cultureName;
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface ICreateLanguageTextInput {
  resourceName: string | undefined;
  cultureName: string | undefined;
  name: string | undefined;
  value: string | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
  displayName!: string | undefined;
  parentId!: string | undefined;

  constructor(data?: ICreateOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.parentId = _data['parentId'];
    }
  }

  static fromJS(data: any): CreateOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['parentId'] = this.parentId;
    return data;
  }
}

export interface ICreateOrganizationUnitInput {
  displayName: string | undefined;
  parentId: string | undefined;
}

export class CurrentCultureDto implements ICurrentCultureDto {
  displayName!: string | undefined;
  englishName!: string | undefined;
  threeLetterIsoLanguageName!: string | undefined;
  twoLetterIsoLanguageName!: string | undefined;
  isRightToLeft!: boolean;
  cultureName!: string | undefined;
  name!: string | undefined;
  nativeName!: string | undefined;
  dateTimeFormat!: DateTimeFormatDto;

  constructor(data?: ICurrentCultureDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.englishName = _data['englishName'];
      this.threeLetterIsoLanguageName = _data['threeLetterIsoLanguageName'];
      this.twoLetterIsoLanguageName = _data['twoLetterIsoLanguageName'];
      this.isRightToLeft = _data['isRightToLeft'];
      this.cultureName = _data['cultureName'];
      this.name = _data['name'];
      this.nativeName = _data['nativeName'];
      this.dateTimeFormat = _data['dateTimeFormat']
        ? DateTimeFormatDto.fromJS(_data['dateTimeFormat'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CurrentCultureDto {
    data = typeof data === 'object' ? data : {};
    let result = new CurrentCultureDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['englishName'] = this.englishName;
    data['threeLetterIsoLanguageName'] = this.threeLetterIsoLanguageName;
    data['twoLetterIsoLanguageName'] = this.twoLetterIsoLanguageName;
    data['isRightToLeft'] = this.isRightToLeft;
    data['cultureName'] = this.cultureName;
    data['name'] = this.name;
    data['nativeName'] = this.nativeName;
    data['dateTimeFormat'] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICurrentCultureDto {
  displayName: string | undefined;
  englishName: string | undefined;
  threeLetterIsoLanguageName: string | undefined;
  twoLetterIsoLanguageName: string | undefined;
  isRightToLeft: boolean;
  cultureName: string | undefined;
  name: string | undefined;
  nativeName: string | undefined;
  dateTimeFormat: DateTimeFormatDto;
}

export class CurrentTenantDto implements ICurrentTenantDto {
  id!: string | undefined;
  name!: string | undefined;
  isAvailable!: boolean;

  constructor(data?: ICurrentTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.isAvailable = _data['isAvailable'];
    }
  }

  static fromJS(data: any): CurrentTenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new CurrentTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['isAvailable'] = this.isAvailable;
    return data;
  }
}

export interface ICurrentTenantDto {
  id: string | undefined;
  name: string | undefined;
  isAvailable: boolean;
}

export class CurrentUserDto implements ICurrentUserDto {
  isAuthenticated!: boolean;
  id!: string | undefined;
  tenantId!: string | undefined;
  impersonatorUserId!: string | undefined;
  impersonatorTenantId!: string | undefined;
  impersonatorUserName!: string | undefined;
  impersonatorTenantName!: string | undefined;
  userName!: string | undefined;
  name!: string | undefined;
  surName!: string | undefined;
  email!: string | undefined;
  emailVerified!: boolean;
  phoneNumber!: string | undefined;
  phoneNumberVerified!: boolean;
  roles!: string[] | undefined;

  constructor(data?: ICurrentUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isAuthenticated = _data['isAuthenticated'];
      this.id = _data['id'];
      this.tenantId = _data['tenantId'];
      this.impersonatorUserId = _data['impersonatorUserId'];
      this.impersonatorTenantId = _data['impersonatorTenantId'];
      this.impersonatorUserName = _data['impersonatorUserName'];
      this.impersonatorTenantName = _data['impersonatorTenantName'];
      this.userName = _data['userName'];
      this.name = _data['name'];
      this.surName = _data['surName'];
      this.email = _data['email'];
      this.emailVerified = _data['emailVerified'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberVerified = _data['phoneNumberVerified'];
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): CurrentUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new CurrentUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isAuthenticated'] = this.isAuthenticated;
    data['id'] = this.id;
    data['tenantId'] = this.tenantId;
    data['impersonatorUserId'] = this.impersonatorUserId;
    data['impersonatorTenantId'] = this.impersonatorTenantId;
    data['impersonatorUserName'] = this.impersonatorUserName;
    data['impersonatorTenantName'] = this.impersonatorTenantName;
    data['userName'] = this.userName;
    data['name'] = this.name;
    data['surName'] = this.surName;
    data['email'] = this.email;
    data['emailVerified'] = this.emailVerified;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberVerified'] = this.phoneNumberVerified;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    return data;
  }
}

export interface ICurrentUserDto {
  isAuthenticated: boolean;
  id: string | undefined;
  tenantId: string | undefined;
  impersonatorUserId: string | undefined;
  impersonatorTenantId: string | undefined;
  impersonatorUserName: string | undefined;
  impersonatorTenantName: string | undefined;
  userName: string | undefined;
  name: string | undefined;
  surName: string | undefined;
  email: string | undefined;
  emailVerified: boolean;
  phoneNumber: string | undefined;
  phoneNumberVerified: boolean;
  roles: string[] | undefined;
}

export class CustomerInputDto implements ICustomerInputDto {
  id!: string;
  customerName!: string | undefined;
  detailAddress!: string | undefined;
  province!: string | undefined;
  city!: string | undefined;

  constructor(data?: ICustomerInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.customerName = _data['customerName'];
      this.detailAddress = _data['detailAddress'];
      this.province = _data['province'];
      this.city = _data['city'];
    }
  }

  static fromJS(data: any): CustomerInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new CustomerInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['customerName'] = this.customerName;
    data['detailAddress'] = this.detailAddress;
    data['province'] = this.province;
    data['city'] = this.city;
    return data;
  }
}

export interface ICustomerInputDto {
  id: string;
  customerName: string | undefined;
  detailAddress: string | undefined;
  province: string | undefined;
  city: string | undefined;
}

export class CustomerOutputDto implements ICustomerOutputDto {
  id!: string;
  customerName!: string | undefined;
  detailAddress!: string | undefined;
  province!: string | undefined;
  city!: string | undefined;
  tenantId!: string | undefined;
  readonly tenant!: boolean;

  constructor(data?: ICustomerOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.customerName = _data['customerName'];
      this.detailAddress = _data['detailAddress'];
      this.province = _data['province'];
      this.city = _data['city'];
      this.tenantId = _data['tenantId'];
      (<any>this).tenant = _data['tenant'];
    }
  }

  static fromJS(data: any): CustomerOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new CustomerOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['customerName'] = this.customerName;
    data['detailAddress'] = this.detailAddress;
    data['province'] = this.province;
    data['city'] = this.city;
    data['tenantId'] = this.tenantId;
    data['tenant'] = this.tenant;
    return data;
  }
}

export interface ICustomerOutputDto {
  id: string;
  customerName: string | undefined;
  detailAddress: string | undefined;
  province: string | undefined;
  city: string | undefined;
  tenantId: string | undefined;
  tenant: boolean;
}

export class CustomerOutputDtoPagedResultDto implements ICustomerOutputDtoPagedResultDto {
  items!: CustomerOutputDto[] | undefined;
  totalCount!: number;

  constructor(data?: ICustomerOutputDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CustomerOutputDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): CustomerOutputDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new CustomerOutputDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface ICustomerOutputDtoPagedResultDto {
  items: CustomerOutputDto[] | undefined;
  totalCount: number;
}

export enum DataSide {
  AnySide = 'AnySide',
  EdgeSide = 'EdgeSide',
  ServerSide = 'ServerSide',
}

export enum DataType {
  Boolean = 'Boolean',
  String = 'String',
  Long = 'Long',
  Double = 'Double',
  Json = 'Json',
  XML = 'XML',
  Binary = 'Binary',
  DateTime = 'DateTime',
}

export class DateTimeFormatDto implements IDateTimeFormatDto {
  calendarAlgorithmType!: string | undefined;
  dateTimeFormatLong!: string | undefined;
  shortDatePattern!: string | undefined;
  fullDateTimePattern!: string | undefined;
  dateSeparator!: string | undefined;
  shortTimePattern!: string | undefined;
  longTimePattern!: string | undefined;

  constructor(data?: IDateTimeFormatDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.calendarAlgorithmType = _data['calendarAlgorithmType'];
      this.dateTimeFormatLong = _data['dateTimeFormatLong'];
      this.shortDatePattern = _data['shortDatePattern'];
      this.fullDateTimePattern = _data['fullDateTimePattern'];
      this.dateSeparator = _data['dateSeparator'];
      this.shortTimePattern = _data['shortTimePattern'];
      this.longTimePattern = _data['longTimePattern'];
    }
  }

  static fromJS(data: any): DateTimeFormatDto {
    data = typeof data === 'object' ? data : {};
    let result = new DateTimeFormatDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['calendarAlgorithmType'] = this.calendarAlgorithmType;
    data['dateTimeFormatLong'] = this.dateTimeFormatLong;
    data['shortDatePattern'] = this.shortDatePattern;
    data['fullDateTimePattern'] = this.fullDateTimePattern;
    data['dateSeparator'] = this.dateSeparator;
    data['shortTimePattern'] = this.shortTimePattern;
    data['longTimePattern'] = this.longTimePattern;
    return data;
  }
}

export interface IDateTimeFormatDto {
  calendarAlgorithmType: string | undefined;
  dateTimeFormatLong: string | undefined;
  shortDatePattern: string | undefined;
  fullDateTimePattern: string | undefined;
  dateSeparator: string | undefined;
  shortTimePattern: string | undefined;
  longTimePattern: string | undefined;
}

export class DeleteDataDictionaryDetailInput implements IDeleteDataDictionaryDetailInput {
  dataDictionaryId!: string;
  dataDictionayDetailId!: string;

  constructor(data?: IDeleteDataDictionaryDetailInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dataDictionaryId = _data['dataDictionaryId'];
      this.dataDictionayDetailId = _data['dataDictionayDetailId'];
    }
  }

  static fromJS(data: any): DeleteDataDictionaryDetailInput {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteDataDictionaryDetailInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dataDictionaryId'] = this.dataDictionaryId;
    data['dataDictionayDetailId'] = this.dataDictionayDetailId;
    return data;
  }
}

export interface IDeleteDataDictionaryDetailInput {
  dataDictionaryId: string;
  dataDictionayDetailId: string;
}

export class DeleteLanguageInput implements IDeleteLanguageInput {
  id!: string;

  constructor(data?: IDeleteLanguageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): DeleteLanguageInput {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteLanguageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IDeleteLanguageInput {
  id: string;
}

export class DeviceInputDto implements IDeviceInputDto {
  id!: string;
  name!: string | undefined;
  deviceType!: DeviceType;
  identityType!: IdentityType;
  timeout!: number;

  constructor(data?: IDeviceInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.deviceType = _data['deviceType'];
      this.identityType = _data['identityType'];
      this.timeout = _data['timeout'];
    }
  }

  static fromJS(data: any): DeviceInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['deviceType'] = this.deviceType;
    data['identityType'] = this.identityType;
    data['timeout'] = this.timeout;
    return data;
  }
}

export interface IDeviceInputDto {
  id: string;
  name: string | undefined;
  deviceType: DeviceType;
  identityType: IdentityType;
  timeout: number;
}

export class DeviceOutputDto implements IDeviceOutputDto {
  id!: string;
  name!: string | undefined;
  deviceType!: DeviceType;
  identityType!: IdentityType;
  timeout!: number;
  creationTime!: dayjs.Dayjs;
  token!: string | undefined;
  account!: string | undefined;
  password!: string | undefined;
  isActive!: boolean;
  imgUrl!: string | undefined;

  constructor(data?: IDeviceOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.deviceType = _data['deviceType'];
      this.identityType = _data['identityType'];
      this.timeout = _data['timeout'];
      this.creationTime = _data['creationTime']
        ? dayjs(_data['creationTime'].toString())
        : <any>undefined;
      this.token = _data['token'];
      this.account = _data['account'];
      this.password = _data['password'];
      this.isActive = _data['isActive'];
      this.imgUrl = _data['imgUrl'];
    }
  }

  static fromJS(data: any): DeviceOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['deviceType'] = this.deviceType;
    data['identityType'] = this.identityType;
    data['timeout'] = this.timeout;
    data['creationTime'] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
    data['token'] = this.token;
    data['account'] = this.account;
    data['password'] = this.password;
    data['isActive'] = this.isActive;
    data['imgUrl'] = this.imgUrl;
    return data;
  }
}

export interface IDeviceOutputDto {
  id: string;
  name: string | undefined;
  deviceType: DeviceType;
  identityType: IdentityType;
  timeout: number;
  creationTime: dayjs.Dayjs;
  token: string | undefined;
  account: string | undefined;
  password: string | undefined;
  isActive: boolean;
  imgUrl: string | undefined;
}

export class DeviceOutputDtoPagedResultDto implements IDeviceOutputDtoPagedResultDto {
  items!: DeviceOutputDto[] | undefined;
  totalCount!: number;

  constructor(data?: IDeviceOutputDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(DeviceOutputDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): DeviceOutputDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceOutputDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IDeviceOutputDtoPagedResultDto {
  items: DeviceOutputDto[] | undefined;
  totalCount: number;
}

export class DeviceRuleOutputDto implements IDeviceRuleOutputDto {
  id!: string;
  ruleName!: string | undefined;
  ruleId!: string;
  ruleType!: RuleType;
  enable!: boolean;

  constructor(data?: IDeviceRuleOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.ruleName = _data['ruleName'];
      this.ruleId = _data['ruleId'];
      this.ruleType = _data['ruleType'];
      this.enable = _data['enable'];
    }
  }

  static fromJS(data: any): DeviceRuleOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceRuleOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['ruleName'] = this.ruleName;
    data['ruleId'] = this.ruleId;
    data['ruleType'] = this.ruleType;
    data['enable'] = this.enable;
    return data;
  }
}

export interface IDeviceRuleOutputDto {
  id: string;
  ruleName: string | undefined;
  ruleId: string;
  ruleType: RuleType;
  enable: boolean;
}

export class DeviceRuleOutputDtoPagedResultDto implements IDeviceRuleOutputDtoPagedResultDto {
  items!: DeviceRuleOutputDto[] | undefined;
  totalCount!: number;

  constructor(data?: IDeviceRuleOutputDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(DeviceRuleOutputDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): DeviceRuleOutputDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceRuleOutputDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IDeviceRuleOutputDtoPagedResultDto {
  items: DeviceRuleOutputDto[] | undefined;
  totalCount: number;
}

export enum DeviceType {
  Device = 'Device',
  Gateway = 'Gateway',
}

export class DoubleListNameValue implements IDoubleListNameValue {
  name!: string | undefined;
  value!: number[] | undefined;

  constructor(data?: IDoubleListNameValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      if (Array.isArray(_data['value'])) {
        this.value = [] as any;
        for (let item of _data['value']) this.value!.push(item);
      }
    }
  }

  static fromJS(data: any): DoubleListNameValue {
    data = typeof data === 'object' ? data : {};
    let result = new DoubleListNameValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (Array.isArray(this.value)) {
      data['value'] = [];
      for (let item of this.value) data['value'].push(item);
    }
    return data;
  }
}

export interface IDoubleListNameValue {
  name: string | undefined;
  value: number[] | undefined;
}

export enum EntityChangeType {
  Created = 0,
  Updated = 1,
  Deleted = 2,
}

export class EntityExtensionDto implements IEntityExtensionDto {
  properties!: { [key: string]: ExtensionPropertyDto } | undefined;
  configuration!: { [key: string]: any } | undefined;

  constructor(data?: IEntityExtensionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['properties']) {
        this.properties = {} as any;
        for (let key in _data['properties']) {
          if (_data['properties'].hasOwnProperty(key))
            (<any>this.properties)![key] = _data['properties'][key]
              ? ExtensionPropertyDto.fromJS(_data['properties'][key])
              : new ExtensionPropertyDto();
        }
      }
      if (_data['configuration']) {
        this.configuration = {} as any;
        for (let key in _data['configuration']) {
          if (_data['configuration'].hasOwnProperty(key))
            (<any>this.configuration)![key] = _data['configuration'][key];
        }
      }
    }
  }

  static fromJS(data: any): EntityExtensionDto {
    data = typeof data === 'object' ? data : {};
    let result = new EntityExtensionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.properties) {
      data['properties'] = {};
      for (let key in this.properties) {
        if (this.properties.hasOwnProperty(key))
          (<any>data['properties'])[key] = this.properties[key]
            ? this.properties[key].toJSON()
            : <any>undefined;
      }
    }
    if (this.configuration) {
      data['configuration'] = {};
      for (let key in this.configuration) {
        if (this.configuration.hasOwnProperty(key))
          (<any>data['configuration'])[key] = (<any>this.configuration)[key];
      }
    }
    return data;
  }
}

export interface IEntityExtensionDto {
  properties: { [key: string]: ExtensionPropertyDto } | undefined;
  configuration: { [key: string]: any } | undefined;
}

export class ExtensionEnumDto implements IExtensionEnumDto {
  fields!: ExtensionEnumFieldDto[] | undefined;
  localizationResource!: string | undefined;

  constructor(data?: IExtensionEnumDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['fields'])) {
        this.fields = [] as any;
        for (let item of _data['fields']) this.fields!.push(ExtensionEnumFieldDto.fromJS(item));
      }
      this.localizationResource = _data['localizationResource'];
    }
  }

  static fromJS(data: any): ExtensionEnumDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionEnumDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.fields)) {
      data['fields'] = [];
      for (let item of this.fields) data['fields'].push(item.toJSON());
    }
    data['localizationResource'] = this.localizationResource;
    return data;
  }
}

export interface IExtensionEnumDto {
  fields: ExtensionEnumFieldDto[] | undefined;
  localizationResource: string | undefined;
}

export class ExtensionEnumFieldDto implements IExtensionEnumFieldDto {
  name!: string | undefined;
  value!: any | undefined;

  constructor(data?: IExtensionEnumFieldDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): ExtensionEnumFieldDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionEnumFieldDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface IExtensionEnumFieldDto {
  name: string | undefined;
  value: any | undefined;
}

export class ExtensionPropertyApiCreateDto implements IExtensionPropertyApiCreateDto {
  isAvailable!: boolean;

  constructor(data?: IExtensionPropertyApiCreateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isAvailable = _data['isAvailable'];
    }
  }

  static fromJS(data: any): ExtensionPropertyApiCreateDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyApiCreateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isAvailable'] = this.isAvailable;
    return data;
  }
}

export interface IExtensionPropertyApiCreateDto {
  isAvailable: boolean;
}

export class ExtensionPropertyApiDto implements IExtensionPropertyApiDto {
  onGet!: ExtensionPropertyApiGetDto;
  onCreate!: ExtensionPropertyApiCreateDto;
  onUpdate!: ExtensionPropertyApiUpdateDto;

  constructor(data?: IExtensionPropertyApiDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.onGet = _data['onGet']
        ? ExtensionPropertyApiGetDto.fromJS(_data['onGet'])
        : <any>undefined;
      this.onCreate = _data['onCreate']
        ? ExtensionPropertyApiCreateDto.fromJS(_data['onCreate'])
        : <any>undefined;
      this.onUpdate = _data['onUpdate']
        ? ExtensionPropertyApiUpdateDto.fromJS(_data['onUpdate'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExtensionPropertyApiDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyApiDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['onGet'] = this.onGet ? this.onGet.toJSON() : <any>undefined;
    data['onCreate'] = this.onCreate ? this.onCreate.toJSON() : <any>undefined;
    data['onUpdate'] = this.onUpdate ? this.onUpdate.toJSON() : <any>undefined;
    return data;
  }
}

export interface IExtensionPropertyApiDto {
  onGet: ExtensionPropertyApiGetDto;
  onCreate: ExtensionPropertyApiCreateDto;
  onUpdate: ExtensionPropertyApiUpdateDto;
}

export class ExtensionPropertyApiGetDto implements IExtensionPropertyApiGetDto {
  isAvailable!: boolean;

  constructor(data?: IExtensionPropertyApiGetDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isAvailable = _data['isAvailable'];
    }
  }

  static fromJS(data: any): ExtensionPropertyApiGetDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyApiGetDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isAvailable'] = this.isAvailable;
    return data;
  }
}

export interface IExtensionPropertyApiGetDto {
  isAvailable: boolean;
}

export class ExtensionPropertyApiUpdateDto implements IExtensionPropertyApiUpdateDto {
  isAvailable!: boolean;

  constructor(data?: IExtensionPropertyApiUpdateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isAvailable = _data['isAvailable'];
    }
  }

  static fromJS(data: any): ExtensionPropertyApiUpdateDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyApiUpdateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isAvailable'] = this.isAvailable;
    return data;
  }
}

export interface IExtensionPropertyApiUpdateDto {
  isAvailable: boolean;
}

export class ExtensionPropertyAttributeDto implements IExtensionPropertyAttributeDto {
  typeSimple!: string | undefined;
  config!: { [key: string]: any } | undefined;

  constructor(data?: IExtensionPropertyAttributeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.typeSimple = _data['typeSimple'];
      if (_data['config']) {
        this.config = {} as any;
        for (let key in _data['config']) {
          if (_data['config'].hasOwnProperty(key)) (<any>this.config)![key] = _data['config'][key];
        }
      }
    }
  }

  static fromJS(data: any): ExtensionPropertyAttributeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyAttributeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['typeSimple'] = this.typeSimple;
    if (this.config) {
      data['config'] = {};
      for (let key in this.config) {
        if (this.config.hasOwnProperty(key)) (<any>data['config'])[key] = (<any>this.config)[key];
      }
    }
    return data;
  }
}

export interface IExtensionPropertyAttributeDto {
  typeSimple: string | undefined;
  config: { [key: string]: any } | undefined;
}

export class ExtensionPropertyDto implements IExtensionPropertyDto {
  type!: string | undefined;
  typeSimple!: string | undefined;
  displayName!: LocalizableStringDto;
  api!: ExtensionPropertyApiDto;
  ui!: ExtensionPropertyUiDto;
  attributes!: ExtensionPropertyAttributeDto[] | undefined;
  configuration!: { [key: string]: any } | undefined;
  defaultValue!: any | undefined;

  constructor(data?: IExtensionPropertyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.typeSimple = _data['typeSimple'];
      this.displayName = _data['displayName']
        ? LocalizableStringDto.fromJS(_data['displayName'])
        : <any>undefined;
      this.api = _data['api'] ? ExtensionPropertyApiDto.fromJS(_data['api']) : <any>undefined;
      this.ui = _data['ui'] ? ExtensionPropertyUiDto.fromJS(_data['ui']) : <any>undefined;
      if (Array.isArray(_data['attributes'])) {
        this.attributes = [] as any;
        for (let item of _data['attributes'])
          this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item));
      }
      if (_data['configuration']) {
        this.configuration = {} as any;
        for (let key in _data['configuration']) {
          if (_data['configuration'].hasOwnProperty(key))
            (<any>this.configuration)![key] = _data['configuration'][key];
        }
      }
      this.defaultValue = _data['defaultValue'];
    }
  }

  static fromJS(data: any): ExtensionPropertyDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['typeSimple'] = this.typeSimple;
    data['displayName'] = this.displayName ? this.displayName.toJSON() : <any>undefined;
    data['api'] = this.api ? this.api.toJSON() : <any>undefined;
    data['ui'] = this.ui ? this.ui.toJSON() : <any>undefined;
    if (Array.isArray(this.attributes)) {
      data['attributes'] = [];
      for (let item of this.attributes) data['attributes'].push(item.toJSON());
    }
    if (this.configuration) {
      data['configuration'] = {};
      for (let key in this.configuration) {
        if (this.configuration.hasOwnProperty(key))
          (<any>data['configuration'])[key] = (<any>this.configuration)[key];
      }
    }
    data['defaultValue'] = this.defaultValue;
    return data;
  }
}

export interface IExtensionPropertyDto {
  type: string | undefined;
  typeSimple: string | undefined;
  displayName: LocalizableStringDto;
  api: ExtensionPropertyApiDto;
  ui: ExtensionPropertyUiDto;
  attributes: ExtensionPropertyAttributeDto[] | undefined;
  configuration: { [key: string]: any } | undefined;
  defaultValue: any | undefined;
}

export class ExtensionPropertyUiDto implements IExtensionPropertyUiDto {
  onTable!: ExtensionPropertyUiTableDto;
  onCreateForm!: ExtensionPropertyUiFormDto;
  onEditForm!: ExtensionPropertyUiFormDto;
  lookup!: ExtensionPropertyUiLookupDto;

  constructor(data?: IExtensionPropertyUiDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.onTable = _data['onTable']
        ? ExtensionPropertyUiTableDto.fromJS(_data['onTable'])
        : <any>undefined;
      this.onCreateForm = _data['onCreateForm']
        ? ExtensionPropertyUiFormDto.fromJS(_data['onCreateForm'])
        : <any>undefined;
      this.onEditForm = _data['onEditForm']
        ? ExtensionPropertyUiFormDto.fromJS(_data['onEditForm'])
        : <any>undefined;
      this.lookup = _data['lookup']
        ? ExtensionPropertyUiLookupDto.fromJS(_data['lookup'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExtensionPropertyUiDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyUiDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['onTable'] = this.onTable ? this.onTable.toJSON() : <any>undefined;
    data['onCreateForm'] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>undefined;
    data['onEditForm'] = this.onEditForm ? this.onEditForm.toJSON() : <any>undefined;
    data['lookup'] = this.lookup ? this.lookup.toJSON() : <any>undefined;
    return data;
  }
}

export interface IExtensionPropertyUiDto {
  onTable: ExtensionPropertyUiTableDto;
  onCreateForm: ExtensionPropertyUiFormDto;
  onEditForm: ExtensionPropertyUiFormDto;
  lookup: ExtensionPropertyUiLookupDto;
}

export class ExtensionPropertyUiFormDto implements IExtensionPropertyUiFormDto {
  isVisible!: boolean;

  constructor(data?: IExtensionPropertyUiFormDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isVisible = _data['isVisible'];
    }
  }

  static fromJS(data: any): ExtensionPropertyUiFormDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyUiFormDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isVisible'] = this.isVisible;
    return data;
  }
}

export interface IExtensionPropertyUiFormDto {
  isVisible: boolean;
}

export class ExtensionPropertyUiLookupDto implements IExtensionPropertyUiLookupDto {
  url!: string | undefined;
  resultListPropertyName!: string | undefined;
  displayPropertyName!: string | undefined;
  valuePropertyName!: string | undefined;
  filterParamName!: string | undefined;

  constructor(data?: IExtensionPropertyUiLookupDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.url = _data['url'];
      this.resultListPropertyName = _data['resultListPropertyName'];
      this.displayPropertyName = _data['displayPropertyName'];
      this.valuePropertyName = _data['valuePropertyName'];
      this.filterParamName = _data['filterParamName'];
    }
  }

  static fromJS(data: any): ExtensionPropertyUiLookupDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyUiLookupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['url'] = this.url;
    data['resultListPropertyName'] = this.resultListPropertyName;
    data['displayPropertyName'] = this.displayPropertyName;
    data['valuePropertyName'] = this.valuePropertyName;
    data['filterParamName'] = this.filterParamName;
    return data;
  }
}

export interface IExtensionPropertyUiLookupDto {
  url: string | undefined;
  resultListPropertyName: string | undefined;
  displayPropertyName: string | undefined;
  valuePropertyName: string | undefined;
  filterParamName: string | undefined;
}

export class ExtensionPropertyUiTableDto implements IExtensionPropertyUiTableDto {
  isVisible!: boolean;

  constructor(data?: IExtensionPropertyUiTableDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isVisible = _data['isVisible'];
    }
  }

  static fromJS(data: any): ExtensionPropertyUiTableDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtensionPropertyUiTableDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isVisible'] = this.isVisible;
    return data;
  }
}

export interface IExtensionPropertyUiTableDto {
  isVisible: boolean;
}

export class FileAggregateRoute implements IFileAggregateRoute {
  routeKeys!: string[] | undefined;
  routeKeysConfig!: AggregateRouteConfig[] | undefined;
  upstreamPathTemplate!: string | undefined;
  upstreamHost!: string | undefined;
  routeIsCaseSensitive!: boolean;
  aggregator!: string | undefined;
  readonly upstreamHttpMethod!: string[] | undefined;
  priority!: number;

  constructor(data?: IFileAggregateRoute) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['routeKeys'])) {
        this.routeKeys = [] as any;
        for (let item of _data['routeKeys']) this.routeKeys!.push(item);
      }
      if (Array.isArray(_data['routeKeysConfig'])) {
        this.routeKeysConfig = [] as any;
        for (let item of _data['routeKeysConfig'])
          this.routeKeysConfig!.push(AggregateRouteConfig.fromJS(item));
      }
      this.upstreamPathTemplate = _data['upstreamPathTemplate'];
      this.upstreamHost = _data['upstreamHost'];
      this.routeIsCaseSensitive = _data['routeIsCaseSensitive'];
      this.aggregator = _data['aggregator'];
      if (Array.isArray(_data['upstreamHttpMethod'])) {
        (<any>this).upstreamHttpMethod = [] as any;
        for (let item of _data['upstreamHttpMethod']) (<any>this).upstreamHttpMethod!.push(item);
      }
      this.priority = _data['priority'];
    }
  }

  static fromJS(data: any): FileAggregateRoute {
    data = typeof data === 'object' ? data : {};
    let result = new FileAggregateRoute();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.routeKeys)) {
      data['routeKeys'] = [];
      for (let item of this.routeKeys) data['routeKeys'].push(item);
    }
    if (Array.isArray(this.routeKeysConfig)) {
      data['routeKeysConfig'] = [];
      for (let item of this.routeKeysConfig) data['routeKeysConfig'].push(item.toJSON());
    }
    data['upstreamPathTemplate'] = this.upstreamPathTemplate;
    data['upstreamHost'] = this.upstreamHost;
    data['routeIsCaseSensitive'] = this.routeIsCaseSensitive;
    data['aggregator'] = this.aggregator;
    if (Array.isArray(this.upstreamHttpMethod)) {
      data['upstreamHttpMethod'] = [];
      for (let item of this.upstreamHttpMethod) data['upstreamHttpMethod'].push(item);
    }
    data['priority'] = this.priority;
    return data;
  }
}

export interface IFileAggregateRoute {
  routeKeys: string[] | undefined;
  routeKeysConfig: AggregateRouteConfig[] | undefined;
  upstreamPathTemplate: string | undefined;
  upstreamHost: string | undefined;
  routeIsCaseSensitive: boolean;
  aggregator: string | undefined;
  upstreamHttpMethod: string[] | undefined;
  priority: number;
}

export class FileAuthenticationOptions implements IFileAuthenticationOptions {
  authenticationProviderKey!: string | undefined;
  allowedScopes!: string[] | undefined;

  constructor(data?: IFileAuthenticationOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authenticationProviderKey = _data['authenticationProviderKey'];
      if (Array.isArray(_data['allowedScopes'])) {
        this.allowedScopes = [] as any;
        for (let item of _data['allowedScopes']) this.allowedScopes!.push(item);
      }
    }
  }

  static fromJS(data: any): FileAuthenticationOptions {
    data = typeof data === 'object' ? data : {};
    let result = new FileAuthenticationOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['authenticationProviderKey'] = this.authenticationProviderKey;
    if (Array.isArray(this.allowedScopes)) {
      data['allowedScopes'] = [];
      for (let item of this.allowedScopes) data['allowedScopes'].push(item);
    }
    return data;
  }
}

export interface IFileAuthenticationOptions {
  authenticationProviderKey: string | undefined;
  allowedScopes: string[] | undefined;
}

export class FileCacheOptions implements IFileCacheOptions {
  ttlSeconds!: number;
  region!: string | undefined;

  constructor(data?: IFileCacheOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ttlSeconds = _data['ttlSeconds'];
      this.region = _data['region'];
    }
  }

  static fromJS(data: any): FileCacheOptions {
    data = typeof data === 'object' ? data : {};
    let result = new FileCacheOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ttlSeconds'] = this.ttlSeconds;
    data['region'] = this.region;
    return data;
  }
}

export interface IFileCacheOptions {
  ttlSeconds: number;
  region: string | undefined;
}

export class FileConfiguration implements IFileConfiguration {
  routes!: FileRoute[] | undefined;
  dynamicRoutes!: FileDynamicRoute[] | undefined;
  aggregates!: FileAggregateRoute[] | undefined;
  globalConfiguration!: FileGlobalConfiguration;

  constructor(data?: IFileConfiguration) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['routes'])) {
        this.routes = [] as any;
        for (let item of _data['routes']) this.routes!.push(FileRoute.fromJS(item));
      }
      if (Array.isArray(_data['dynamicRoutes'])) {
        this.dynamicRoutes = [] as any;
        for (let item of _data['dynamicRoutes'])
          this.dynamicRoutes!.push(FileDynamicRoute.fromJS(item));
      }
      if (Array.isArray(_data['aggregates'])) {
        this.aggregates = [] as any;
        for (let item of _data['aggregates'])
          this.aggregates!.push(FileAggregateRoute.fromJS(item));
      }
      this.globalConfiguration = _data['globalConfiguration']
        ? FileGlobalConfiguration.fromJS(_data['globalConfiguration'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): FileConfiguration {
    data = typeof data === 'object' ? data : {};
    let result = new FileConfiguration();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.routes)) {
      data['routes'] = [];
      for (let item of this.routes) data['routes'].push(item.toJSON());
    }
    if (Array.isArray(this.dynamicRoutes)) {
      data['dynamicRoutes'] = [];
      for (let item of this.dynamicRoutes) data['dynamicRoutes'].push(item.toJSON());
    }
    if (Array.isArray(this.aggregates)) {
      data['aggregates'] = [];
      for (let item of this.aggregates) data['aggregates'].push(item.toJSON());
    }
    data['globalConfiguration'] = this.globalConfiguration
      ? this.globalConfiguration.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IFileConfiguration {
  routes: FileRoute[] | undefined;
  dynamicRoutes: FileDynamicRoute[] | undefined;
  aggregates: FileAggregateRoute[] | undefined;
  globalConfiguration: FileGlobalConfiguration;
}

export class FileDynamicRoute implements IFileDynamicRoute {
  serviceName!: string | undefined;
  rateLimitRule!: FileRateLimitRule;
  downstreamHttpVersion!: string | undefined;

  constructor(data?: IFileDynamicRoute) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serviceName = _data['serviceName'];
      this.rateLimitRule = _data['rateLimitRule']
        ? FileRateLimitRule.fromJS(_data['rateLimitRule'])
        : <any>undefined;
      this.downstreamHttpVersion = _data['downstreamHttpVersion'];
    }
  }

  static fromJS(data: any): FileDynamicRoute {
    data = typeof data === 'object' ? data : {};
    let result = new FileDynamicRoute();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['serviceName'] = this.serviceName;
    data['rateLimitRule'] = this.rateLimitRule ? this.rateLimitRule.toJSON() : <any>undefined;
    data['downstreamHttpVersion'] = this.downstreamHttpVersion;
    return data;
  }
}

export interface IFileDynamicRoute {
  serviceName: string | undefined;
  rateLimitRule: FileRateLimitRule;
  downstreamHttpVersion: string | undefined;
}

export class FileGlobalConfiguration implements IFileGlobalConfiguration {
  requestIdKey!: string | undefined;
  serviceDiscoveryProvider!: FileServiceDiscoveryProvider;
  rateLimitOptions!: FileRateLimitOptions;
  qoSOptions!: FileQoSOptions;
  baseUrl!: string | undefined;
  loadBalancerOptions!: FileLoadBalancerOptions;
  downstreamScheme!: string | undefined;
  httpHandlerOptions!: FileHttpHandlerOptions;
  downstreamHttpVersion!: string | undefined;

  constructor(data?: IFileGlobalConfiguration) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.requestIdKey = _data['requestIdKey'];
      this.serviceDiscoveryProvider = _data['serviceDiscoveryProvider']
        ? FileServiceDiscoveryProvider.fromJS(_data['serviceDiscoveryProvider'])
        : <any>undefined;
      this.rateLimitOptions = _data['rateLimitOptions']
        ? FileRateLimitOptions.fromJS(_data['rateLimitOptions'])
        : <any>undefined;
      this.qoSOptions = _data['qoSOptions']
        ? FileQoSOptions.fromJS(_data['qoSOptions'])
        : <any>undefined;
      this.baseUrl = _data['baseUrl'];
      this.loadBalancerOptions = _data['loadBalancerOptions']
        ? FileLoadBalancerOptions.fromJS(_data['loadBalancerOptions'])
        : <any>undefined;
      this.downstreamScheme = _data['downstreamScheme'];
      this.httpHandlerOptions = _data['httpHandlerOptions']
        ? FileHttpHandlerOptions.fromJS(_data['httpHandlerOptions'])
        : <any>undefined;
      this.downstreamHttpVersion = _data['downstreamHttpVersion'];
    }
  }

  static fromJS(data: any): FileGlobalConfiguration {
    data = typeof data === 'object' ? data : {};
    let result = new FileGlobalConfiguration();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['requestIdKey'] = this.requestIdKey;
    data['serviceDiscoveryProvider'] = this.serviceDiscoveryProvider
      ? this.serviceDiscoveryProvider.toJSON()
      : <any>undefined;
    data['rateLimitOptions'] = this.rateLimitOptions
      ? this.rateLimitOptions.toJSON()
      : <any>undefined;
    data['qoSOptions'] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
    data['baseUrl'] = this.baseUrl;
    data['loadBalancerOptions'] = this.loadBalancerOptions
      ? this.loadBalancerOptions.toJSON()
      : <any>undefined;
    data['downstreamScheme'] = this.downstreamScheme;
    data['httpHandlerOptions'] = this.httpHandlerOptions
      ? this.httpHandlerOptions.toJSON()
      : <any>undefined;
    data['downstreamHttpVersion'] = this.downstreamHttpVersion;
    return data;
  }
}

export interface IFileGlobalConfiguration {
  requestIdKey: string | undefined;
  serviceDiscoveryProvider: FileServiceDiscoveryProvider;
  rateLimitOptions: FileRateLimitOptions;
  qoSOptions: FileQoSOptions;
  baseUrl: string | undefined;
  loadBalancerOptions: FileLoadBalancerOptions;
  downstreamScheme: string | undefined;
  httpHandlerOptions: FileHttpHandlerOptions;
  downstreamHttpVersion: string | undefined;
}

export class FileHostAndPort implements IFileHostAndPort {
  host!: string | undefined;
  port!: number;

  constructor(data?: IFileHostAndPort) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.host = _data['host'];
      this.port = _data['port'];
    }
  }

  static fromJS(data: any): FileHostAndPort {
    data = typeof data === 'object' ? data : {};
    let result = new FileHostAndPort();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['host'] = this.host;
    data['port'] = this.port;
    return data;
  }
}

export interface IFileHostAndPort {
  host: string | undefined;
  port: number;
}

export class FileHttpHandlerOptions implements IFileHttpHandlerOptions {
  allowAutoRedirect!: boolean;
  useCookieContainer!: boolean;
  useTracing!: boolean;
  useProxy!: boolean;
  maxConnectionsPerServer!: number;

  constructor(data?: IFileHttpHandlerOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.allowAutoRedirect = _data['allowAutoRedirect'];
      this.useCookieContainer = _data['useCookieContainer'];
      this.useTracing = _data['useTracing'];
      this.useProxy = _data['useProxy'];
      this.maxConnectionsPerServer = _data['maxConnectionsPerServer'];
    }
  }

  static fromJS(data: any): FileHttpHandlerOptions {
    data = typeof data === 'object' ? data : {};
    let result = new FileHttpHandlerOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['allowAutoRedirect'] = this.allowAutoRedirect;
    data['useCookieContainer'] = this.useCookieContainer;
    data['useTracing'] = this.useTracing;
    data['useProxy'] = this.useProxy;
    data['maxConnectionsPerServer'] = this.maxConnectionsPerServer;
    return data;
  }
}

export interface IFileHttpHandlerOptions {
  allowAutoRedirect: boolean;
  useCookieContainer: boolean;
  useTracing: boolean;
  useProxy: boolean;
  maxConnectionsPerServer: number;
}

export class FileLoadBalancerOptions implements IFileLoadBalancerOptions {
  type!: string | undefined;
  key!: string | undefined;
  expiry!: number;

  constructor(data?: IFileLoadBalancerOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.key = _data['key'];
      this.expiry = _data['expiry'];
    }
  }

  static fromJS(data: any): FileLoadBalancerOptions {
    data = typeof data === 'object' ? data : {};
    let result = new FileLoadBalancerOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['key'] = this.key;
    data['expiry'] = this.expiry;
    return data;
  }
}

export interface IFileLoadBalancerOptions {
  type: string | undefined;
  key: string | undefined;
  expiry: number;
}

export class FileQoSOptions implements IFileQoSOptions {
  exceptionsAllowedBeforeBreaking!: number;
  durationOfBreak!: number;
  timeoutValue!: number;

  constructor(data?: IFileQoSOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.exceptionsAllowedBeforeBreaking = _data['exceptionsAllowedBeforeBreaking'];
      this.durationOfBreak = _data['durationOfBreak'];
      this.timeoutValue = _data['timeoutValue'];
    }
  }

  static fromJS(data: any): FileQoSOptions {
    data = typeof data === 'object' ? data : {};
    let result = new FileQoSOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['exceptionsAllowedBeforeBreaking'] = this.exceptionsAllowedBeforeBreaking;
    data['durationOfBreak'] = this.durationOfBreak;
    data['timeoutValue'] = this.timeoutValue;
    return data;
  }
}

export interface IFileQoSOptions {
  exceptionsAllowedBeforeBreaking: number;
  durationOfBreak: number;
  timeoutValue: number;
}

export class FileRateLimitOptions implements IFileRateLimitOptions {
  clientIdHeader!: string | undefined;
  quotaExceededMessage!: string | undefined;
  rateLimitCounterPrefix!: string | undefined;
  disableRateLimitHeaders!: boolean;
  httpStatusCode!: number;

  constructor(data?: IFileRateLimitOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientIdHeader = _data['clientIdHeader'];
      this.quotaExceededMessage = _data['quotaExceededMessage'];
      this.rateLimitCounterPrefix = _data['rateLimitCounterPrefix'];
      this.disableRateLimitHeaders = _data['disableRateLimitHeaders'];
      this.httpStatusCode = _data['httpStatusCode'];
    }
  }

  static fromJS(data: any): FileRateLimitOptions {
    data = typeof data === 'object' ? data : {};
    let result = new FileRateLimitOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['clientIdHeader'] = this.clientIdHeader;
    data['quotaExceededMessage'] = this.quotaExceededMessage;
    data['rateLimitCounterPrefix'] = this.rateLimitCounterPrefix;
    data['disableRateLimitHeaders'] = this.disableRateLimitHeaders;
    data['httpStatusCode'] = this.httpStatusCode;
    return data;
  }
}

export interface IFileRateLimitOptions {
  clientIdHeader: string | undefined;
  quotaExceededMessage: string | undefined;
  rateLimitCounterPrefix: string | undefined;
  disableRateLimitHeaders: boolean;
  httpStatusCode: number;
}

export class FileRateLimitRule implements IFileRateLimitRule {
  clientWhitelist!: string[] | undefined;
  enableRateLimiting!: boolean;
  period!: string | undefined;
  periodTimespan!: number;
  limit!: number;

  constructor(data?: IFileRateLimitRule) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['clientWhitelist'])) {
        this.clientWhitelist = [] as any;
        for (let item of _data['clientWhitelist']) this.clientWhitelist!.push(item);
      }
      this.enableRateLimiting = _data['enableRateLimiting'];
      this.period = _data['period'];
      this.periodTimespan = _data['periodTimespan'];
      this.limit = _data['limit'];
    }
  }

  static fromJS(data: any): FileRateLimitRule {
    data = typeof data === 'object' ? data : {};
    let result = new FileRateLimitRule();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.clientWhitelist)) {
      data['clientWhitelist'] = [];
      for (let item of this.clientWhitelist) data['clientWhitelist'].push(item);
    }
    data['enableRateLimiting'] = this.enableRateLimiting;
    data['period'] = this.period;
    data['periodTimespan'] = this.periodTimespan;
    data['limit'] = this.limit;
    return data;
  }
}

export interface IFileRateLimitRule {
  clientWhitelist: string[] | undefined;
  enableRateLimiting: boolean;
  period: string | undefined;
  periodTimespan: number;
  limit: number;
}

export class FileRoute implements IFileRoute {
  downstreamPathTemplate!: string | undefined;
  upstreamPathTemplate!: string | undefined;
  upstreamHttpMethod!: string[] | undefined;
  downstreamHttpMethod!: string | undefined;
  addHeadersToRequest!: { [key: string]: string } | undefined;
  upstreamHeaderTransform!: { [key: string]: string } | undefined;
  downstreamHeaderTransform!: { [key: string]: string } | undefined;
  addClaimsToRequest!: { [key: string]: string } | undefined;
  routeClaimsRequirement!: { [key: string]: string } | undefined;
  addQueriesToRequest!: { [key: string]: string } | undefined;
  changeDownstreamPathTemplate!: { [key: string]: string } | undefined;
  requestIdKey!: string | undefined;
  fileCacheOptions!: FileCacheOptions;
  routeIsCaseSensitive!: boolean;
  serviceName!: string | undefined;
  serviceNamespace!: string | undefined;
  downstreamScheme!: string | undefined;
  qoSOptions!: FileQoSOptions;
  loadBalancerOptions!: FileLoadBalancerOptions;
  rateLimitOptions!: FileRateLimitRule;
  authenticationOptions!: FileAuthenticationOptions;
  httpHandlerOptions!: FileHttpHandlerOptions;
  downstreamHostAndPorts!: FileHostAndPort[] | undefined;
  upstreamHost!: string | undefined;
  key!: string | undefined;
  delegatingHandlers!: string[] | undefined;
  priority!: number;
  timeout!: number;
  dangerousAcceptAnyServerCertificateValidator!: boolean;
  securityOptions!: FileSecurityOptions;
  downstreamHttpVersion!: string | undefined;

  constructor(data?: IFileRoute) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.downstreamPathTemplate = _data['downstreamPathTemplate'];
      this.upstreamPathTemplate = _data['upstreamPathTemplate'];
      if (Array.isArray(_data['upstreamHttpMethod'])) {
        this.upstreamHttpMethod = [] as any;
        for (let item of _data['upstreamHttpMethod']) this.upstreamHttpMethod!.push(item);
      }
      this.downstreamHttpMethod = _data['downstreamHttpMethod'];
      if (_data['addHeadersToRequest']) {
        this.addHeadersToRequest = {} as any;
        for (let key in _data['addHeadersToRequest']) {
          if (_data['addHeadersToRequest'].hasOwnProperty(key))
            (<any>this.addHeadersToRequest)![key] = _data['addHeadersToRequest'][key];
        }
      }
      if (_data['upstreamHeaderTransform']) {
        this.upstreamHeaderTransform = {} as any;
        for (let key in _data['upstreamHeaderTransform']) {
          if (_data['upstreamHeaderTransform'].hasOwnProperty(key))
            (<any>this.upstreamHeaderTransform)![key] = _data['upstreamHeaderTransform'][key];
        }
      }
      if (_data['downstreamHeaderTransform']) {
        this.downstreamHeaderTransform = {} as any;
        for (let key in _data['downstreamHeaderTransform']) {
          if (_data['downstreamHeaderTransform'].hasOwnProperty(key))
            (<any>this.downstreamHeaderTransform)![key] = _data['downstreamHeaderTransform'][key];
        }
      }
      if (_data['addClaimsToRequest']) {
        this.addClaimsToRequest = {} as any;
        for (let key in _data['addClaimsToRequest']) {
          if (_data['addClaimsToRequest'].hasOwnProperty(key))
            (<any>this.addClaimsToRequest)![key] = _data['addClaimsToRequest'][key];
        }
      }
      if (_data['routeClaimsRequirement']) {
        this.routeClaimsRequirement = {} as any;
        for (let key in _data['routeClaimsRequirement']) {
          if (_data['routeClaimsRequirement'].hasOwnProperty(key))
            (<any>this.routeClaimsRequirement)![key] = _data['routeClaimsRequirement'][key];
        }
      }
      if (_data['addQueriesToRequest']) {
        this.addQueriesToRequest = {} as any;
        for (let key in _data['addQueriesToRequest']) {
          if (_data['addQueriesToRequest'].hasOwnProperty(key))
            (<any>this.addQueriesToRequest)![key] = _data['addQueriesToRequest'][key];
        }
      }
      if (_data['changeDownstreamPathTemplate']) {
        this.changeDownstreamPathTemplate = {} as any;
        for (let key in _data['changeDownstreamPathTemplate']) {
          if (_data['changeDownstreamPathTemplate'].hasOwnProperty(key))
            (<any>this.changeDownstreamPathTemplate)![key] =
              _data['changeDownstreamPathTemplate'][key];
        }
      }
      this.requestIdKey = _data['requestIdKey'];
      this.fileCacheOptions = _data['fileCacheOptions']
        ? FileCacheOptions.fromJS(_data['fileCacheOptions'])
        : <any>undefined;
      this.routeIsCaseSensitive = _data['routeIsCaseSensitive'];
      this.serviceName = _data['serviceName'];
      this.serviceNamespace = _data['serviceNamespace'];
      this.downstreamScheme = _data['downstreamScheme'];
      this.qoSOptions = _data['qoSOptions']
        ? FileQoSOptions.fromJS(_data['qoSOptions'])
        : <any>undefined;
      this.loadBalancerOptions = _data['loadBalancerOptions']
        ? FileLoadBalancerOptions.fromJS(_data['loadBalancerOptions'])
        : <any>undefined;
      this.rateLimitOptions = _data['rateLimitOptions']
        ? FileRateLimitRule.fromJS(_data['rateLimitOptions'])
        : <any>undefined;
      this.authenticationOptions = _data['authenticationOptions']
        ? FileAuthenticationOptions.fromJS(_data['authenticationOptions'])
        : <any>undefined;
      this.httpHandlerOptions = _data['httpHandlerOptions']
        ? FileHttpHandlerOptions.fromJS(_data['httpHandlerOptions'])
        : <any>undefined;
      if (Array.isArray(_data['downstreamHostAndPorts'])) {
        this.downstreamHostAndPorts = [] as any;
        for (let item of _data['downstreamHostAndPorts'])
          this.downstreamHostAndPorts!.push(FileHostAndPort.fromJS(item));
      }
      this.upstreamHost = _data['upstreamHost'];
      this.key = _data['key'];
      if (Array.isArray(_data['delegatingHandlers'])) {
        this.delegatingHandlers = [] as any;
        for (let item of _data['delegatingHandlers']) this.delegatingHandlers!.push(item);
      }
      this.priority = _data['priority'];
      this.timeout = _data['timeout'];
      this.dangerousAcceptAnyServerCertificateValidator =
        _data['dangerousAcceptAnyServerCertificateValidator'];
      this.securityOptions = _data['securityOptions']
        ? FileSecurityOptions.fromJS(_data['securityOptions'])
        : <any>undefined;
      this.downstreamHttpVersion = _data['downstreamHttpVersion'];
    }
  }

  static fromJS(data: any): FileRoute {
    data = typeof data === 'object' ? data : {};
    let result = new FileRoute();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['downstreamPathTemplate'] = this.downstreamPathTemplate;
    data['upstreamPathTemplate'] = this.upstreamPathTemplate;
    if (Array.isArray(this.upstreamHttpMethod)) {
      data['upstreamHttpMethod'] = [];
      for (let item of this.upstreamHttpMethod) data['upstreamHttpMethod'].push(item);
    }
    data['downstreamHttpMethod'] = this.downstreamHttpMethod;
    if (this.addHeadersToRequest) {
      data['addHeadersToRequest'] = {};
      for (let key in this.addHeadersToRequest) {
        if (this.addHeadersToRequest.hasOwnProperty(key))
          (<any>data['addHeadersToRequest'])[key] = (<any>this.addHeadersToRequest)[key];
      }
    }
    if (this.upstreamHeaderTransform) {
      data['upstreamHeaderTransform'] = {};
      for (let key in this.upstreamHeaderTransform) {
        if (this.upstreamHeaderTransform.hasOwnProperty(key))
          (<any>data['upstreamHeaderTransform'])[key] = (<any>this.upstreamHeaderTransform)[key];
      }
    }
    if (this.downstreamHeaderTransform) {
      data['downstreamHeaderTransform'] = {};
      for (let key in this.downstreamHeaderTransform) {
        if (this.downstreamHeaderTransform.hasOwnProperty(key))
          (<any>data['downstreamHeaderTransform'])[key] = (<any>this.downstreamHeaderTransform)[
            key
          ];
      }
    }
    if (this.addClaimsToRequest) {
      data['addClaimsToRequest'] = {};
      for (let key in this.addClaimsToRequest) {
        if (this.addClaimsToRequest.hasOwnProperty(key))
          (<any>data['addClaimsToRequest'])[key] = (<any>this.addClaimsToRequest)[key];
      }
    }
    if (this.routeClaimsRequirement) {
      data['routeClaimsRequirement'] = {};
      for (let key in this.routeClaimsRequirement) {
        if (this.routeClaimsRequirement.hasOwnProperty(key))
          (<any>data['routeClaimsRequirement'])[key] = (<any>this.routeClaimsRequirement)[key];
      }
    }
    if (this.addQueriesToRequest) {
      data['addQueriesToRequest'] = {};
      for (let key in this.addQueriesToRequest) {
        if (this.addQueriesToRequest.hasOwnProperty(key))
          (<any>data['addQueriesToRequest'])[key] = (<any>this.addQueriesToRequest)[key];
      }
    }
    if (this.changeDownstreamPathTemplate) {
      data['changeDownstreamPathTemplate'] = {};
      for (let key in this.changeDownstreamPathTemplate) {
        if (this.changeDownstreamPathTemplate.hasOwnProperty(key))
          (<any>data['changeDownstreamPathTemplate'])[key] = (<any>(
            this.changeDownstreamPathTemplate
          ))[key];
      }
    }
    data['requestIdKey'] = this.requestIdKey;
    data['fileCacheOptions'] = this.fileCacheOptions
      ? this.fileCacheOptions.toJSON()
      : <any>undefined;
    data['routeIsCaseSensitive'] = this.routeIsCaseSensitive;
    data['serviceName'] = this.serviceName;
    data['serviceNamespace'] = this.serviceNamespace;
    data['downstreamScheme'] = this.downstreamScheme;
    data['qoSOptions'] = this.qoSOptions ? this.qoSOptions.toJSON() : <any>undefined;
    data['loadBalancerOptions'] = this.loadBalancerOptions
      ? this.loadBalancerOptions.toJSON()
      : <any>undefined;
    data['rateLimitOptions'] = this.rateLimitOptions
      ? this.rateLimitOptions.toJSON()
      : <any>undefined;
    data['authenticationOptions'] = this.authenticationOptions
      ? this.authenticationOptions.toJSON()
      : <any>undefined;
    data['httpHandlerOptions'] = this.httpHandlerOptions
      ? this.httpHandlerOptions.toJSON()
      : <any>undefined;
    if (Array.isArray(this.downstreamHostAndPorts)) {
      data['downstreamHostAndPorts'] = [];
      for (let item of this.downstreamHostAndPorts)
        data['downstreamHostAndPorts'].push(item.toJSON());
    }
    data['upstreamHost'] = this.upstreamHost;
    data['key'] = this.key;
    if (Array.isArray(this.delegatingHandlers)) {
      data['delegatingHandlers'] = [];
      for (let item of this.delegatingHandlers) data['delegatingHandlers'].push(item);
    }
    data['priority'] = this.priority;
    data['timeout'] = this.timeout;
    data['dangerousAcceptAnyServerCertificateValidator'] =
      this.dangerousAcceptAnyServerCertificateValidator;
    data['securityOptions'] = this.securityOptions ? this.securityOptions.toJSON() : <any>undefined;
    data['downstreamHttpVersion'] = this.downstreamHttpVersion;
    return data;
  }
}

export interface IFileRoute {
  downstreamPathTemplate: string | undefined;
  upstreamPathTemplate: string | undefined;
  upstreamHttpMethod: string[] | undefined;
  downstreamHttpMethod: string | undefined;
  addHeadersToRequest: { [key: string]: string } | undefined;
  upstreamHeaderTransform: { [key: string]: string } | undefined;
  downstreamHeaderTransform: { [key: string]: string } | undefined;
  addClaimsToRequest: { [key: string]: string } | undefined;
  routeClaimsRequirement: { [key: string]: string } | undefined;
  addQueriesToRequest: { [key: string]: string } | undefined;
  changeDownstreamPathTemplate: { [key: string]: string } | undefined;
  requestIdKey: string | undefined;
  fileCacheOptions: FileCacheOptions;
  routeIsCaseSensitive: boolean;
  serviceName: string | undefined;
  serviceNamespace: string | undefined;
  downstreamScheme: string | undefined;
  qoSOptions: FileQoSOptions;
  loadBalancerOptions: FileLoadBalancerOptions;
  rateLimitOptions: FileRateLimitRule;
  authenticationOptions: FileAuthenticationOptions;
  httpHandlerOptions: FileHttpHandlerOptions;
  downstreamHostAndPorts: FileHostAndPort[] | undefined;
  upstreamHost: string | undefined;
  key: string | undefined;
  delegatingHandlers: string[] | undefined;
  priority: number;
  timeout: number;
  dangerousAcceptAnyServerCertificateValidator: boolean;
  securityOptions: FileSecurityOptions;
  downstreamHttpVersion: string | undefined;
}

export class FileSecurityOptions implements IFileSecurityOptions {
  ipAllowedList!: string[] | undefined;
  ipBlockedList!: string[] | undefined;

  constructor(data?: IFileSecurityOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['ipAllowedList'])) {
        this.ipAllowedList = [] as any;
        for (let item of _data['ipAllowedList']) this.ipAllowedList!.push(item);
      }
      if (Array.isArray(_data['ipBlockedList'])) {
        this.ipBlockedList = [] as any;
        for (let item of _data['ipBlockedList']) this.ipBlockedList!.push(item);
      }
    }
  }

  static fromJS(data: any): FileSecurityOptions {
    data = typeof data === 'object' ? data : {};
    let result = new FileSecurityOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.ipAllowedList)) {
      data['ipAllowedList'] = [];
      for (let item of this.ipAllowedList) data['ipAllowedList'].push(item);
    }
    if (Array.isArray(this.ipBlockedList)) {
      data['ipBlockedList'] = [];
      for (let item of this.ipBlockedList) data['ipBlockedList'].push(item);
    }
    return data;
  }
}

export interface IFileSecurityOptions {
  ipAllowedList: string[] | undefined;
  ipBlockedList: string[] | undefined;
}

export class FileServiceDiscoveryProvider implements IFileServiceDiscoveryProvider {
  scheme!: string | undefined;
  host!: string | undefined;
  port!: number;
  type!: string | undefined;
  token!: string | undefined;
  configurationKey!: string | undefined;
  pollingInterval!: number;
  namespace!: string | undefined;

  constructor(data?: IFileServiceDiscoveryProvider) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.scheme = _data['scheme'];
      this.host = _data['host'];
      this.port = _data['port'];
      this.type = _data['type'];
      this.token = _data['token'];
      this.configurationKey = _data['configurationKey'];
      this.pollingInterval = _data['pollingInterval'];
      this.namespace = _data['namespace'];
    }
  }

  static fromJS(data: any): FileServiceDiscoveryProvider {
    data = typeof data === 'object' ? data : {};
    let result = new FileServiceDiscoveryProvider();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['scheme'] = this.scheme;
    data['host'] = this.host;
    data['port'] = this.port;
    data['type'] = this.type;
    data['token'] = this.token;
    data['configurationKey'] = this.configurationKey;
    data['pollingInterval'] = this.pollingInterval;
    data['namespace'] = this.namespace;
    return data;
  }
}

export interface IFileServiceDiscoveryProvider {
  scheme: string | undefined;
  host: string | undefined;
  port: number;
  type: string | undefined;
  token: string | undefined;
  configurationKey: string | undefined;
  pollingInterval: number;
  namespace: string | undefined;
}

export class FindTenantByNameInput implements IFindTenantByNameInput {
  name!: string | undefined;

  constructor(data?: IFindTenantByNameInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): FindTenantByNameInput {
    data = typeof data === 'object' ? data : {};
    let result = new FindTenantByNameInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface IFindTenantByNameInput {
  name: string | undefined;
}

export class FindTenantResultDto implements IFindTenantResultDto {
  success!: boolean;
  tenantId!: string | undefined;
  name!: string | undefined;
  isActive!: boolean;

  constructor(data?: IFindTenantResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.success = _data['success'];
      this.tenantId = _data['tenantId'];
      this.name = _data['name'];
      this.isActive = _data['isActive'];
    }
  }

  static fromJS(data: any): FindTenantResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new FindTenantResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['success'] = this.success;
    data['tenantId'] = this.tenantId;
    data['name'] = this.name;
    data['isActive'] = this.isActive;
    return data;
  }
}

export interface IFindTenantResultDto {
  success: boolean;
  tenantId: string | undefined;
  name: string | undefined;
  isActive: boolean;
}

export class GetOrganizationUnitRoleInput implements IGetOrganizationUnitRoleInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  organizationUnitId!: string;

  constructor(data?: IGetOrganizationUnitRoleInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.organizationUnitId = _data['organizationUnitId'];
    }
  }

  static fromJS(data: any): GetOrganizationUnitRoleInput {
    data = typeof data === 'object' ? data : {};
    let result = new GetOrganizationUnitRoleInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['organizationUnitId'] = this.organizationUnitId;
    return data;
  }
}

export interface IGetOrganizationUnitRoleInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  organizationUnitId: string;
}

export class GetOrganizationUnitRoleOutput implements IGetOrganizationUnitRoleOutput {
  id!: string;
  name!: string | undefined;

  constructor(data?: IGetOrganizationUnitRoleOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): GetOrganizationUnitRoleOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetOrganizationUnitRoleOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IGetOrganizationUnitRoleOutput {
  id: string;
  name: string | undefined;
}

export class GetOrganizationUnitRoleOutputPagedResultDto
  implements IGetOrganizationUnitRoleOutputPagedResultDto
{
  items!: GetOrganizationUnitRoleOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IGetOrganizationUnitRoleOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(GetOrganizationUnitRoleOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): GetOrganizationUnitRoleOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetOrganizationUnitRoleOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IGetOrganizationUnitRoleOutputPagedResultDto {
  items: GetOrganizationUnitRoleOutput[] | undefined;
  totalCount: number;
}

export class GetOrganizationUnitUserInput implements IGetOrganizationUnitUserInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  organizationUnitId!: string;
  filter!: string | undefined;

  constructor(data?: IGetOrganizationUnitUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.organizationUnitId = _data['organizationUnitId'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): GetOrganizationUnitUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new GetOrganizationUnitUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['organizationUnitId'] = this.organizationUnitId;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IGetOrganizationUnitUserInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  organizationUnitId: string;
  filter: string | undefined;
}

export class GetOrganizationUnitUserOutput implements IGetOrganizationUnitUserOutput {
  id!: string;
  userName!: string | undefined;
  email!: string | undefined;

  constructor(data?: IGetOrganizationUnitUserOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): GetOrganizationUnitUserOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetOrganizationUnitUserOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['email'] = this.email;
    return data;
  }
}

export interface IGetOrganizationUnitUserOutput {
  id: string;
  userName: string | undefined;
  email: string | undefined;
}

export class GetOrganizationUnitUserOutputPagedResultDto
  implements IGetOrganizationUnitUserOutputPagedResultDto
{
  items!: GetOrganizationUnitUserOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IGetOrganizationUnitUserOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(GetOrganizationUnitUserOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): GetOrganizationUnitUserOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetOrganizationUnitUserOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IGetOrganizationUnitUserOutputPagedResultDto {
  items: GetOrganizationUnitUserOutput[] | undefined;
  totalCount: number;
}

export class GetPermissionInput implements IGetPermissionInput {
  providerName!: string | undefined;
  providerKey!: string | undefined;

  constructor(data?: IGetPermissionInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.providerName = _data['providerName'];
      this.providerKey = _data['providerKey'];
    }
  }

  static fromJS(data: any): GetPermissionInput {
    data = typeof data === 'object' ? data : {};
    let result = new GetPermissionInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['providerName'] = this.providerName;
    data['providerKey'] = this.providerKey;
    return data;
  }
}

export interface IGetPermissionInput {
  providerName: string | undefined;
  providerKey: string | undefined;
}

export class GetUnAddRoleInput implements IGetUnAddRoleInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  organizationUnitId!: string;
  filter!: string | undefined;

  constructor(data?: IGetUnAddRoleInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.organizationUnitId = _data['organizationUnitId'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): GetUnAddRoleInput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnAddRoleInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['organizationUnitId'] = this.organizationUnitId;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IGetUnAddRoleInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  organizationUnitId: string;
  filter: string | undefined;
}

export class GetUnAddRoleOutput implements IGetUnAddRoleOutput {
  id!: string;
  name!: string | undefined;

  constructor(data?: IGetUnAddRoleOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): GetUnAddRoleOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnAddRoleOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IGetUnAddRoleOutput {
  id: string;
  name: string | undefined;
}

export class GetUnAddRoleOutputPagedResultDto implements IGetUnAddRoleOutputPagedResultDto {
  items!: GetUnAddRoleOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IGetUnAddRoleOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetUnAddRoleOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): GetUnAddRoleOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnAddRoleOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IGetUnAddRoleOutputPagedResultDto {
  items: GetUnAddRoleOutput[] | undefined;
  totalCount: number;
}

export class GetUnAddUserInput implements IGetUnAddUserInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  organizationUnitId!: string;
  filter!: string | undefined;

  constructor(data?: IGetUnAddUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.organizationUnitId = _data['organizationUnitId'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): GetUnAddUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnAddUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['organizationUnitId'] = this.organizationUnitId;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IGetUnAddUserInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  organizationUnitId: string;
  filter: string | undefined;
}

export class GetUnAddUserOutput implements IGetUnAddUserOutput {
  id!: string;
  userName!: string | undefined;
  email!: string | undefined;

  constructor(data?: IGetUnAddUserOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): GetUnAddUserOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnAddUserOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['email'] = this.email;
    return data;
  }
}

export interface IGetUnAddUserOutput {
  id: string;
  userName: string | undefined;
  email: string | undefined;
}

export class GetUnAddUserOutputPagedResultDto implements IGetUnAddUserOutputPagedResultDto {
  items!: GetUnAddUserOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IGetUnAddUserOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(GetUnAddUserOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): GetUnAddUserOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetUnAddUserOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IGetUnAddUserOutputPagedResultDto {
  items: GetUnAddUserOutput[] | undefined;
  totalCount: number;
}

export enum HttpStatusCode {
  Continue = 100,
  SwitchingProtocols = 101,
  Processing = 102,
  EarlyHints = 103,
  OK = 200,
  Created = 201,
  Accepted = 202,
  NonAuthoritativeInformation = 203,
  NoContent = 204,
  ResetContent = 205,
  PartialContent = 206,
  MultiStatus = 207,
  AlreadyReported = 208,
  IMUsed = 226,
  MultipleChoices = 300,
  Ambiguous = 301,
  MovedPermanently = 302,
  Moved = 303,
  Found = 304,
  Redirect = 305,
  SeeOther = 306,
  RedirectMethod = 307,
  NotModified = 308,
  UseProxy = 400,
  Unused = 401,
  TemporaryRedirect = 402,
  RedirectKeepVerb = 403,
  PermanentRedirect = 404,
  BadRequest = 405,
  Unauthorized = 406,
  PaymentRequired = 407,
  Forbidden = 408,
  NotFound = 409,
  MethodNotAllowed = 410,
  NotAcceptable = 411,
  ProxyAuthenticationRequired = 412,
  RequestTimeout = 413,
  Conflict = 414,
  Gone = 415,
  LengthRequired = 416,
  PreconditionFailed = 417,
  RequestEntityTooLarge = 421,
  RequestUriTooLong = 422,
  UnsupportedMediaType = 423,
  RequestedRangeNotSatisfiable = 424,
  ExpectationFailed = 426,
  MisdirectedRequest = 428,
  UnprocessableEntity = 429,
  UnprocessableContent = 431,
  Locked = 451,
  FailedDependency = 500,
  UpgradeRequired = 501,
  PreconditionRequired = 502,
  TooManyRequests = 503,
  RequestHeaderFieldsTooLarge = 504,
  UnavailableForLegalReasons = 505,
  InternalServerError = 506,
  NotImplemented = 507,
  BadGateway = 508,
  ServiceUnavailable = 510,
  GatewayTimeout = 511,
}

export class IanaTimeZone implements IIanaTimeZone {
  timeZoneName!: string | undefined;

  constructor(data?: IIanaTimeZone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.timeZoneName = _data['timeZoneName'];
    }
  }

  static fromJS(data: any): IanaTimeZone {
    data = typeof data === 'object' ? data : {};
    let result = new IanaTimeZone();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['timeZoneName'] = this.timeZoneName;
    return data;
  }
}

export interface IIanaTimeZone {
  timeZoneName: string | undefined;
}

export class IdInput implements IIdInput {
  id!: string;

  constructor(data?: IIdInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): IdInput {
    data = typeof data === 'object' ? data : {};
    let result = new IdInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IIdInput {
  id: string;
}

export class IdentityRoleCreateDto implements IIdentityRoleCreateDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  name!: string;
  isDefault!: boolean;
  isPublic!: boolean;

  constructor(data?: IIdentityRoleCreateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.name = _data['name'];
      this.isDefault = _data['isDefault'];
      this.isPublic = _data['isPublic'];
    }
  }

  static fromJS(data: any): IdentityRoleCreateDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityRoleCreateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['name'] = this.name;
    data['isDefault'] = this.isDefault;
    data['isPublic'] = this.isPublic;
    return data;
  }
}

export interface IIdentityRoleCreateDto {
  extraProperties: { [key: string]: any } | undefined;
  name: string;
  isDefault: boolean;
  isPublic: boolean;
}

export class IdentityRoleDto implements IIdentityRoleDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  id!: string;
  name!: string | undefined;
  isDefault!: boolean;
  isStatic!: boolean;
  isPublic!: boolean;
  concurrencyStamp!: string | undefined;

  constructor(data?: IIdentityRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.id = _data['id'];
      this.name = _data['name'];
      this.isDefault = _data['isDefault'];
      this.isStatic = _data['isStatic'];
      this.isPublic = _data['isPublic'];
      this.concurrencyStamp = _data['concurrencyStamp'];
    }
  }

  static fromJS(data: any): IdentityRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['id'] = this.id;
    data['name'] = this.name;
    data['isDefault'] = this.isDefault;
    data['isStatic'] = this.isStatic;
    data['isPublic'] = this.isPublic;
    data['concurrencyStamp'] = this.concurrencyStamp;
    return data;
  }
}

export interface IIdentityRoleDto {
  extraProperties: { [key: string]: any } | undefined;
  id: string;
  name: string | undefined;
  isDefault: boolean;
  isStatic: boolean;
  isPublic: boolean;
  concurrencyStamp: string | undefined;
}

export class IdentityRoleDtoListResultDto implements IIdentityRoleDtoListResultDto {
  items!: IdentityRoleDto[] | undefined;

  constructor(data?: IIdentityRoleDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(IdentityRoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): IdentityRoleDtoListResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityRoleDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IIdentityRoleDtoListResultDto {
  items: IdentityRoleDto[] | undefined;
}

export class IdentityRoleDtoPagedResultDto implements IIdentityRoleDtoPagedResultDto {
  items!: IdentityRoleDto[] | undefined;
  totalCount!: number;

  constructor(data?: IIdentityRoleDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(IdentityRoleDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): IdentityRoleDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityRoleDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IIdentityRoleDtoPagedResultDto {
  items: IdentityRoleDto[] | undefined;
  totalCount: number;
}

export class IdentityRoleUpdateDto implements IIdentityRoleUpdateDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  name!: string;
  isDefault!: boolean;
  isPublic!: boolean;
  concurrencyStamp!: string | undefined;

  constructor(data?: IIdentityRoleUpdateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.name = _data['name'];
      this.isDefault = _data['isDefault'];
      this.isPublic = _data['isPublic'];
      this.concurrencyStamp = _data['concurrencyStamp'];
    }
  }

  static fromJS(data: any): IdentityRoleUpdateDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityRoleUpdateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['name'] = this.name;
    data['isDefault'] = this.isDefault;
    data['isPublic'] = this.isPublic;
    data['concurrencyStamp'] = this.concurrencyStamp;
    return data;
  }
}

export interface IIdentityRoleUpdateDto {
  extraProperties: { [key: string]: any } | undefined;
  name: string;
  isDefault: boolean;
  isPublic: boolean;
  concurrencyStamp: string | undefined;
}

export enum IdentityType {
  AccessToken = 0,
  AccountPassword = 1,
}

export class IdentityUserCreateDto implements IIdentityUserCreateDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  userName!: string;
  name!: string | undefined;
  surname!: string | undefined;
  email!: string;
  phoneNumber!: string | undefined;
  isActive!: boolean;
  lockoutEnabled!: boolean;
  roleNames!: string[] | undefined;
  password!: string;

  constructor(data?: IIdentityUserCreateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.userName = _data['userName'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
      this.isActive = _data['isActive'];
      this.lockoutEnabled = _data['lockoutEnabled'];
      if (Array.isArray(_data['roleNames'])) {
        this.roleNames = [] as any;
        for (let item of _data['roleNames']) this.roleNames!.push(item);
      }
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): IdentityUserCreateDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityUserCreateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['userName'] = this.userName;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    data['isActive'] = this.isActive;
    data['lockoutEnabled'] = this.lockoutEnabled;
    if (Array.isArray(this.roleNames)) {
      data['roleNames'] = [];
      for (let item of this.roleNames) data['roleNames'].push(item);
    }
    data['password'] = this.password;
    return data;
  }
}

export interface IIdentityUserCreateDto {
  extraProperties: { [key: string]: any } | undefined;
  userName: string;
  name: string | undefined;
  surname: string | undefined;
  email: string;
  phoneNumber: string | undefined;
  isActive: boolean;
  lockoutEnabled: boolean;
  roleNames: string[] | undefined;
  password: string;
}

export class IdentityUserDto implements IIdentityUserDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  id!: string;
  creationTime!: dayjs.Dayjs;
  creatorId!: string | undefined;
  lastModificationTime!: dayjs.Dayjs | undefined;
  lastModifierId!: string | undefined;
  isDeleted!: boolean;
  deleterId!: string | undefined;
  deletionTime!: dayjs.Dayjs | undefined;
  tenantId!: string | undefined;
  userName!: string | undefined;
  name!: string | undefined;
  surname!: string | undefined;
  email!: string | undefined;
  emailConfirmed!: boolean;
  phoneNumber!: string | undefined;
  phoneNumberConfirmed!: boolean;
  isActive!: boolean;
  lockoutEnabled!: boolean;
  accessFailedCount!: number;
  lockoutEnd!: dayjs.Dayjs | undefined;
  concurrencyStamp!: string | undefined;
  entityVersion!: number;
  lastPasswordChangeTime!: dayjs.Dayjs | undefined;

  constructor(data?: IIdentityUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.id = _data['id'];
      this.creationTime = _data['creationTime']
        ? dayjs(_data['creationTime'].toString())
        : <any>undefined;
      this.creatorId = _data['creatorId'];
      this.lastModificationTime = _data['lastModificationTime']
        ? dayjs(_data['lastModificationTime'].toString())
        : <any>undefined;
      this.lastModifierId = _data['lastModifierId'];
      this.isDeleted = _data['isDeleted'];
      this.deleterId = _data['deleterId'];
      this.deletionTime = _data['deletionTime']
        ? dayjs(_data['deletionTime'].toString())
        : <any>undefined;
      this.tenantId = _data['tenantId'];
      this.userName = _data['userName'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.email = _data['email'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.isActive = _data['isActive'];
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
      this.lockoutEnd = _data['lockoutEnd']
        ? dayjs(_data['lockoutEnd'].toString())
        : <any>undefined;
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.entityVersion = _data['entityVersion'];
      this.lastPasswordChangeTime = _data['lastPasswordChangeTime']
        ? dayjs(_data['lastPasswordChangeTime'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): IdentityUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['id'] = this.id;
    data['creationTime'] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
    data['creatorId'] = this.creatorId;
    data['lastModificationTime'] = this.lastModificationTime
      ? this.lastModificationTime.toLocaleString()
      : <any>undefined;
    data['lastModifierId'] = this.lastModifierId;
    data['isDeleted'] = this.isDeleted;
    data['deleterId'] = this.deleterId;
    data['deletionTime'] = this.deletionTime ? this.deletionTime.toLocaleString() : <any>undefined;
    data['tenantId'] = this.tenantId;
    data['userName'] = this.userName;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['email'] = this.email;
    data['emailConfirmed'] = this.emailConfirmed;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['isActive'] = this.isActive;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toLocaleString() : <any>undefined;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['entityVersion'] = this.entityVersion;
    data['lastPasswordChangeTime'] = this.lastPasswordChangeTime
      ? this.lastPasswordChangeTime.toLocaleString()
      : <any>undefined;
    return data;
  }
}

export interface IIdentityUserDto {
  extraProperties: { [key: string]: any } | undefined;
  id: string;
  creationTime: dayjs.Dayjs;
  creatorId: string | undefined;
  lastModificationTime: dayjs.Dayjs | undefined;
  lastModifierId: string | undefined;
  isDeleted: boolean;
  deleterId: string | undefined;
  deletionTime: dayjs.Dayjs | undefined;
  tenantId: string | undefined;
  userName: string | undefined;
  name: string | undefined;
  surname: string | undefined;
  email: string | undefined;
  emailConfirmed: boolean;
  phoneNumber: string | undefined;
  phoneNumberConfirmed: boolean;
  isActive: boolean;
  lockoutEnabled: boolean;
  accessFailedCount: number;
  lockoutEnd: dayjs.Dayjs | undefined;
  concurrencyStamp: string | undefined;
  entityVersion: number;
  lastPasswordChangeTime: dayjs.Dayjs | undefined;
}

export class IdentityUserDtoPagedResultDto implements IIdentityUserDtoPagedResultDto {
  items!: IdentityUserDto[] | undefined;
  totalCount!: number;

  constructor(data?: IIdentityUserDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(IdentityUserDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): IdentityUserDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityUserDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IIdentityUserDtoPagedResultDto {
  items: IdentityUserDto[] | undefined;
  totalCount: number;
}

export class IdentityUserUpdateDto implements IIdentityUserUpdateDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  userName!: string;
  name!: string | undefined;
  surname!: string | undefined;
  email!: string;
  phoneNumber!: string | undefined;
  isActive!: boolean;
  lockoutEnabled!: boolean;
  roleNames!: string[] | undefined;
  password!: string | undefined;
  concurrencyStamp!: string | undefined;

  constructor(data?: IIdentityUserUpdateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.userName = _data['userName'];
      this.name = _data['name'];
      this.surname = _data['surname'];
      this.email = _data['email'];
      this.phoneNumber = _data['phoneNumber'];
      this.isActive = _data['isActive'];
      this.lockoutEnabled = _data['lockoutEnabled'];
      if (Array.isArray(_data['roleNames'])) {
        this.roleNames = [] as any;
        for (let item of _data['roleNames']) this.roleNames!.push(item);
      }
      this.password = _data['password'];
      this.concurrencyStamp = _data['concurrencyStamp'];
    }
  }

  static fromJS(data: any): IdentityUserUpdateDto {
    data = typeof data === 'object' ? data : {};
    let result = new IdentityUserUpdateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['userName'] = this.userName;
    data['name'] = this.name;
    data['surname'] = this.surname;
    data['email'] = this.email;
    data['phoneNumber'] = this.phoneNumber;
    data['isActive'] = this.isActive;
    data['lockoutEnabled'] = this.lockoutEnabled;
    if (Array.isArray(this.roleNames)) {
      data['roleNames'] = [];
      for (let item of this.roleNames) data['roleNames'].push(item);
    }
    data['password'] = this.password;
    data['concurrencyStamp'] = this.concurrencyStamp;
    return data;
  }
}

export interface IIdentityUserUpdateDto {
  extraProperties: { [key: string]: any } | undefined;
  userName: string;
  name: string | undefined;
  surname: string | undefined;
  email: string;
  phoneNumber: string | undefined;
  isActive: boolean;
  lockoutEnabled: boolean;
  roleNames: string[] | undefined;
  password: string | undefined;
  concurrencyStamp: string | undefined;
}

export class Int32NameValue implements IInt32NameValue {
  name!: string | undefined;
  value!: number;

  constructor(data?: IInt32NameValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): Int32NameValue {
    data = typeof data === 'object' ? data : {};
    let result = new Int32NameValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface IInt32NameValue {
  name: string | undefined;
  value: number;
}

export class InterfaceMethodApiDescriptionModel implements IInterfaceMethodApiDescriptionModel {
  name!: string | undefined;
  parametersOnMethod!: MethodParameterApiDescriptionModel[] | undefined;
  returnValue!: ReturnValueApiDescriptionModel;

  constructor(data?: IInterfaceMethodApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      if (Array.isArray(_data['parametersOnMethod'])) {
        this.parametersOnMethod = [] as any;
        for (let item of _data['parametersOnMethod'])
          this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
      }
      this.returnValue = _data['returnValue']
        ? ReturnValueApiDescriptionModel.fromJS(_data['returnValue'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): InterfaceMethodApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new InterfaceMethodApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (Array.isArray(this.parametersOnMethod)) {
      data['parametersOnMethod'] = [];
      for (let item of this.parametersOnMethod) data['parametersOnMethod'].push(item.toJSON());
    }
    data['returnValue'] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
    return data;
  }
}

export interface IInterfaceMethodApiDescriptionModel {
  name: string | undefined;
  parametersOnMethod: MethodParameterApiDescriptionModel[] | undefined;
  returnValue: ReturnValueApiDescriptionModel;
}

export class LanguageInfo implements ILanguageInfo {
  cultureName!: string | undefined;
  uiCultureName!: string | undefined;
  displayName!: string | undefined;
  readonly twoLetterISOLanguageName!: string | undefined;
  flagIcon!: string | undefined;

  constructor(data?: ILanguageInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cultureName = _data['cultureName'];
      this.uiCultureName = _data['uiCultureName'];
      this.displayName = _data['displayName'];
      (<any>this).twoLetterISOLanguageName = _data['twoLetterISOLanguageName'];
      this.flagIcon = _data['flagIcon'];
    }
  }

  static fromJS(data: any): LanguageInfo {
    data = typeof data === 'object' ? data : {};
    let result = new LanguageInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cultureName'] = this.cultureName;
    data['uiCultureName'] = this.uiCultureName;
    data['displayName'] = this.displayName;
    data['twoLetterISOLanguageName'] = this.twoLetterISOLanguageName;
    data['flagIcon'] = this.flagIcon;
    return data;
  }
}

export interface ILanguageInfo {
  cultureName: string | undefined;
  uiCultureName: string | undefined;
  displayName: string | undefined;
  twoLetterISOLanguageName: string | undefined;
  flagIcon: string | undefined;
}

export class ListPropertyInputDto implements IListPropertyInputDto {
  deviceId!: string;
  propertyType!: PropertyType;

  constructor(data?: IListPropertyInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deviceId = _data['deviceId'];
      this.propertyType = _data['propertyType'];
    }
  }

  static fromJS(data: any): ListPropertyInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListPropertyInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['deviceId'] = this.deviceId;
    data['propertyType'] = this.propertyType;
    return data;
  }
}

export interface IListPropertyInputDto {
  deviceId: string;
  propertyType: PropertyType;
}

export class ListTelemetryChartDataInputDto implements IListTelemetryChartDataInputDto {
  deviceId!: string | undefined;
  deviceName!: string | undefined;
  keyNameList!: string[] | undefined;
  queryCount!: number;

  constructor(data?: IListTelemetryChartDataInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deviceId = _data['deviceId'];
      this.deviceName = _data['deviceName'];
      if (Array.isArray(_data['keyNameList'])) {
        this.keyNameList = [] as any;
        for (let item of _data['keyNameList']) this.keyNameList!.push(item);
      }
      this.queryCount = _data['queryCount'];
    }
  }

  static fromJS(data: any): ListTelemetryChartDataInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListTelemetryChartDataInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['deviceId'] = this.deviceId;
    data['deviceName'] = this.deviceName;
    if (Array.isArray(this.keyNameList)) {
      data['keyNameList'] = [];
      for (let item of this.keyNameList) data['keyNameList'].push(item);
    }
    data['queryCount'] = this.queryCount;
    return data;
  }
}

export interface IListTelemetryChartDataInputDto {
  deviceId: string | undefined;
  deviceName: string | undefined;
  keyNameList: string[] | undefined;
  queryCount: number;
}

export class LocalizableStringDto implements ILocalizableStringDto {
  name!: string | undefined;
  resource!: string | undefined;

  constructor(data?: ILocalizableStringDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.resource = _data['resource'];
    }
  }

  static fromJS(data: any): LocalizableStringDto {
    data = typeof data === 'object' ? data : {};
    let result = new LocalizableStringDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['resource'] = this.resource;
    return data;
  }
}

export interface ILocalizableStringDto {
  name: string | undefined;
  resource: string | undefined;
}

export class LockUserInput implements ILockUserInput {
  userId!: string;
  locked!: boolean;

  constructor(data?: ILockUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.locked = _data['locked'];
    }
  }

  static fromJS(data: any): LockUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new LockUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['locked'] = this.locked;
    return data;
  }
}

export interface ILockUserInput {
  userId: string;
  locked: boolean;
}

export class LoginInput implements ILoginInput {
  name!: string | undefined;
  password!: string | undefined;

  constructor(data?: ILoginInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginInput {
    data = typeof data === 'object' ? data : {};
    let result = new LoginInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginInput {
  name: string | undefined;
  password: string | undefined;
}

export class LoginOutput implements ILoginOutput {
  id!: string;
  name!: string | undefined;
  userName!: string | undefined;
  token!: string | undefined;
  roles!: string[] | undefined;

  constructor(data?: ILoginOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userName = _data['userName'];
      this.token = _data['token'];
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): LoginOutput {
    data = typeof data === 'object' ? data : {};
    let result = new LoginOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userName'] = this.userName;
    data['token'] = this.token;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    return data;
  }
}

export interface ILoginOutput {
  id: string;
  name: string | undefined;
  userName: string | undefined;
  token: string | undefined;
  roles: string[] | undefined;
}

export enum LoginResultType {
  Success = 1,
  InvalidUserNameOrPassword = 2,
  NotAllowed = 3,
  LockedOut = 4,
  RequiresTwoFactor = 5,
}

export class MapDataDto implements IMapDataDto {
  voltageLevel!: string[] | undefined;
  colors!: string[] | undefined;
  categoryData!: { [key: string]: NameValue[] } | undefined;
  topData!: { [key: string]: DoubleListNameValue[] } | undefined;

  constructor(data?: IMapDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['voltageLevel'])) {
        this.voltageLevel = [] as any;
        for (let item of _data['voltageLevel']) this.voltageLevel!.push(item);
      }
      if (Array.isArray(_data['colors'])) {
        this.colors = [] as any;
        for (let item of _data['colors']) this.colors!.push(item);
      }
      if (_data['categoryData']) {
        this.categoryData = {} as any;
        for (let key in _data['categoryData']) {
          if (_data['categoryData'].hasOwnProperty(key))
            (<any>this.categoryData)![key] = _data['categoryData'][key]
              ? _data['categoryData'][key].map((i: any) => NameValue.fromJS(i))
              : <any>undefined;
        }
      }
      if (_data['topData']) {
        this.topData = {} as any;
        for (let key in _data['topData']) {
          if (_data['topData'].hasOwnProperty(key))
            (<any>this.topData)![key] = _data['topData'][key]
              ? _data['topData'][key].map((i: any) => DoubleListNameValue.fromJS(i))
              : <any>undefined;
        }
      }
    }
  }

  static fromJS(data: any): MapDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new MapDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.voltageLevel)) {
      data['voltageLevel'] = [];
      for (let item of this.voltageLevel) data['voltageLevel'].push(item);
    }
    if (Array.isArray(this.colors)) {
      data['colors'] = [];
      for (let item of this.colors) data['colors'].push(item);
    }
    if (this.categoryData) {
      data['categoryData'] = {};
      for (let key in this.categoryData) {
        if (this.categoryData.hasOwnProperty(key))
          (<any>data['categoryData'])[key] = (<any>this.categoryData)[key];
      }
    }
    if (this.topData) {
      data['topData'] = {};
      for (let key in this.topData) {
        if (this.topData.hasOwnProperty(key))
          (<any>data['topData'])[key] = (<any>this.topData)[key];
      }
    }
    return data;
  }
}

export interface IMapDataDto {
  voltageLevel: string[] | undefined;
  colors: string[] | undefined;
  categoryData: { [key: string]: NameValue[] } | undefined;
  topData: { [key: string]: DoubleListNameValue[] } | undefined;
}

export enum MessageLevel {
  Warning = 10,
  Information = 20,
  Error = 30,
}

export enum MessageType {
  BroadCast = 10,
  Common = 20,
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
  name!: string | undefined;
  typeAsString!: string | undefined;
  type!: string | undefined;
  typeSimple!: string | undefined;
  isOptional!: boolean;
  defaultValue!: any | undefined;

  constructor(data?: IMethodParameterApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.typeAsString = _data['typeAsString'];
      this.type = _data['type'];
      this.typeSimple = _data['typeSimple'];
      this.isOptional = _data['isOptional'];
      this.defaultValue = _data['defaultValue'];
    }
  }

  static fromJS(data: any): MethodParameterApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new MethodParameterApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['typeAsString'] = this.typeAsString;
    data['type'] = this.type;
    data['typeSimple'] = this.typeSimple;
    data['isOptional'] = this.isOptional;
    data['defaultValue'] = this.defaultValue;
    return data;
  }
}

export interface IMethodParameterApiDescriptionModel {
  name: string | undefined;
  typeAsString: string | undefined;
  type: string | undefined;
  typeSimple: string | undefined;
  isOptional: boolean;
  defaultValue: any | undefined;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
  rootPath!: string | undefined;
  remoteServiceName!: string | undefined;
  controllers!: { [key: string]: ControllerApiDescriptionModel } | undefined;

  constructor(data?: IModuleApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rootPath = _data['rootPath'];
      this.remoteServiceName = _data['remoteServiceName'];
      if (_data['controllers']) {
        this.controllers = {} as any;
        for (let key in _data['controllers']) {
          if (_data['controllers'].hasOwnProperty(key))
            (<any>this.controllers)![key] = _data['controllers'][key]
              ? ControllerApiDescriptionModel.fromJS(_data['controllers'][key])
              : new ControllerApiDescriptionModel();
        }
      }
    }
  }

  static fromJS(data: any): ModuleApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new ModuleApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['rootPath'] = this.rootPath;
    data['remoteServiceName'] = this.remoteServiceName;
    if (this.controllers) {
      data['controllers'] = {};
      for (let key in this.controllers) {
        if (this.controllers.hasOwnProperty(key))
          (<any>data['controllers'])[key] = this.controllers[key]
            ? this.controllers[key].toJSON()
            : <any>undefined;
      }
    }
    return data;
  }
}

export interface IModuleApiDescriptionModel {
  rootPath: string | undefined;
  remoteServiceName: string | undefined;
  controllers: { [key: string]: ControllerApiDescriptionModel } | undefined;
}

export class ModuleExtensionDto implements IModuleExtensionDto {
  entities!: { [key: string]: EntityExtensionDto } | undefined;
  configuration!: { [key: string]: any } | undefined;

  constructor(data?: IModuleExtensionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['entities']) {
        this.entities = {} as any;
        for (let key in _data['entities']) {
          if (_data['entities'].hasOwnProperty(key))
            (<any>this.entities)![key] = _data['entities'][key]
              ? EntityExtensionDto.fromJS(_data['entities'][key])
              : new EntityExtensionDto();
        }
      }
      if (_data['configuration']) {
        this.configuration = {} as any;
        for (let key in _data['configuration']) {
          if (_data['configuration'].hasOwnProperty(key))
            (<any>this.configuration)![key] = _data['configuration'][key];
        }
      }
    }
  }

  static fromJS(data: any): ModuleExtensionDto {
    data = typeof data === 'object' ? data : {};
    let result = new ModuleExtensionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.entities) {
      data['entities'] = {};
      for (let key in this.entities) {
        if (this.entities.hasOwnProperty(key))
          (<any>data['entities'])[key] = this.entities[key]
            ? this.entities[key].toJSON()
            : <any>undefined;
      }
    }
    if (this.configuration) {
      data['configuration'] = {};
      for (let key in this.configuration) {
        if (this.configuration.hasOwnProperty(key))
          (<any>data['configuration'])[key] = (<any>this.configuration)[key];
      }
    }
    return data;
  }
}

export interface IModuleExtensionDto {
  entities: { [key: string]: EntityExtensionDto } | undefined;
  configuration: { [key: string]: any } | undefined;
}

export class MonthTimeDto implements IMonthTimeDto {
  machineNameList!: string[] | undefined;
  runTimeList!: number[] | undefined;
  powerTimeList!: number[] | undefined;

  constructor(data?: IMonthTimeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['machineNameList'])) {
        this.machineNameList = [] as any;
        for (let item of _data['machineNameList']) this.machineNameList!.push(item);
      }
      if (Array.isArray(_data['runTimeList'])) {
        this.runTimeList = [] as any;
        for (let item of _data['runTimeList']) this.runTimeList!.push(item);
      }
      if (Array.isArray(_data['powerTimeList'])) {
        this.powerTimeList = [] as any;
        for (let item of _data['powerTimeList']) this.powerTimeList!.push(item);
      }
    }
  }

  static fromJS(data: any): MonthTimeDto {
    data = typeof data === 'object' ? data : {};
    let result = new MonthTimeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.machineNameList)) {
      data['machineNameList'] = [];
      for (let item of this.machineNameList) data['machineNameList'].push(item);
    }
    if (Array.isArray(this.runTimeList)) {
      data['runTimeList'] = [];
      for (let item of this.runTimeList) data['runTimeList'].push(item);
    }
    if (Array.isArray(this.powerTimeList)) {
      data['powerTimeList'] = [];
      for (let item of this.powerTimeList) data['powerTimeList'].push(item);
    }
    return data;
  }
}

export interface IMonthTimeDto {
  machineNameList: string[] | undefined;
  runTimeList: number[] | undefined;
  powerTimeList: number[] | undefined;
}

export class MultiTenancyInfoDto implements IMultiTenancyInfoDto {
  isEnabled!: boolean;

  constructor(data?: IMultiTenancyInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isEnabled = _data['isEnabled'];
    }
  }

  static fromJS(data: any): MultiTenancyInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new MultiTenancyInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isEnabled'] = this.isEnabled;
    return data;
  }
}

export interface IMultiTenancyInfoDto {
  isEnabled: boolean;
}

export class NameIdDto implements INameIdDto {
  name!: string | undefined;
  id!: string;

  constructor(data?: INameIdDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): NameIdDto {
    data = typeof data === 'object' ? data : {};
    let result = new NameIdDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['id'] = this.id;
    return data;
  }
}

export interface INameIdDto {
  name: string | undefined;
  id: string;
}

export class NameValue implements INameValue {
  name!: string | undefined;
  value!: string | undefined;

  constructor(data?: INameValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): NameValue {
    data = typeof data === 'object' ? data : {};
    let result = new NameValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface INameValue {
  name: string | undefined;
  value: string | undefined;
}

export class ObjectExtensionsDto implements IObjectExtensionsDto {
  modules!: { [key: string]: ModuleExtensionDto } | undefined;
  enums!: { [key: string]: ExtensionEnumDto } | undefined;

  constructor(data?: IObjectExtensionsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['modules']) {
        this.modules = {} as any;
        for (let key in _data['modules']) {
          if (_data['modules'].hasOwnProperty(key))
            (<any>this.modules)![key] = _data['modules'][key]
              ? ModuleExtensionDto.fromJS(_data['modules'][key])
              : new ModuleExtensionDto();
        }
      }
      if (_data['enums']) {
        this.enums = {} as any;
        for (let key in _data['enums']) {
          if (_data['enums'].hasOwnProperty(key))
            (<any>this.enums)![key] = _data['enums'][key]
              ? ExtensionEnumDto.fromJS(_data['enums'][key])
              : new ExtensionEnumDto();
        }
      }
    }
  }

  static fromJS(data: any): ObjectExtensionsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ObjectExtensionsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.modules) {
      data['modules'] = {};
      for (let key in this.modules) {
        if (this.modules.hasOwnProperty(key))
          (<any>data['modules'])[key] = this.modules[key]
            ? this.modules[key].toJSON()
            : <any>undefined;
      }
    }
    if (this.enums) {
      data['enums'] = {};
      for (let key in this.enums) {
        if (this.enums.hasOwnProperty(key))
          (<any>data['enums'])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>undefined;
      }
    }
    return data;
  }
}

export interface IObjectExtensionsDto {
  modules: { [key: string]: ModuleExtensionDto } | undefined;
  enums: { [key: string]: ExtensionEnumDto } | undefined;
}

export class PageAlarmInputDto implements IPageAlarmInputDto {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  deviceId!: string | undefined;
  alarmText!: string | undefined;
  startTimeBegin!: dayjs.Dayjs | undefined;
  startTimeEnd!: dayjs.Dayjs | undefined;
  endTimeBegin!: dayjs.Dayjs | undefined;
  endTimeEnd!: dayjs.Dayjs | undefined;
  duration!: number;
  alarmStatus!: number;
  serverity!: number;

  constructor(data?: IPageAlarmInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.deviceId = _data['deviceId'];
      this.alarmText = _data['alarmText'];
      this.startTimeBegin = _data['startTimeBegin']
        ? dayjs(_data['startTimeBegin'].toString())
        : <any>undefined;
      this.startTimeEnd = _data['startTimeEnd']
        ? dayjs(_data['startTimeEnd'].toString())
        : <any>undefined;
      this.endTimeBegin = _data['endTimeBegin']
        ? dayjs(_data['endTimeBegin'].toString())
        : <any>undefined;
      this.endTimeEnd = _data['endTimeEnd']
        ? dayjs(_data['endTimeEnd'].toString())
        : <any>undefined;
      this.duration = _data['duration'];
      this.alarmStatus = _data['alarmStatus'];
      this.serverity = _data['serverity'];
    }
  }

  static fromJS(data: any): PageAlarmInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new PageAlarmInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['deviceId'] = this.deviceId;
    data['alarmText'] = this.alarmText;
    data['startTimeBegin'] = this.startTimeBegin
      ? this.startTimeBegin.toLocaleString()
      : <any>undefined;
    data['startTimeEnd'] = this.startTimeEnd ? this.startTimeEnd.toLocaleString() : <any>undefined;
    data['endTimeBegin'] = this.endTimeBegin ? this.endTimeBegin.toLocaleString() : <any>undefined;
    data['endTimeEnd'] = this.endTimeEnd ? this.endTimeEnd.toLocaleString() : <any>undefined;
    data['duration'] = this.duration;
    data['alarmStatus'] = this.alarmStatus;
    data['serverity'] = this.serverity;
    return data;
  }
}

export interface IPageAlarmInputDto {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  deviceId: string | undefined;
  alarmText: string | undefined;
  startTimeBegin: dayjs.Dayjs | undefined;
  startTimeEnd: dayjs.Dayjs | undefined;
  endTimeBegin: dayjs.Dayjs | undefined;
  endTimeEnd: dayjs.Dayjs | undefined;
  duration: number;
  alarmStatus: number;
  serverity: number;
}

export class PageCustomerInputDto implements IPageCustomerInputDto {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPageCustomerInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PageCustomerInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new PageCustomerInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPageCustomerInputDto {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PageDeviceInputDto implements IPageDeviceInputDto {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPageDeviceInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PageDeviceInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new PageDeviceInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPageDeviceInputDto {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PageLanguageInput implements IPageLanguageInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPageLanguageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PageLanguageInput {
    data = typeof data === 'object' ? data : {};
    let result = new PageLanguageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPageLanguageInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PageLanguageOutput implements IPageLanguageOutput {
  id!: string;
  cultureName!: string | undefined;
  uiCultureName!: string | undefined;
  displayName!: string | undefined;
  flagIcon!: string | undefined;
  isEnabled!: boolean;
  creationTime!: dayjs.Dayjs;
  isDefault!: boolean;

  constructor(data?: IPageLanguageOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.cultureName = _data['cultureName'];
      this.uiCultureName = _data['uiCultureName'];
      this.displayName = _data['displayName'];
      this.flagIcon = _data['flagIcon'];
      this.isEnabled = _data['isEnabled'];
      this.creationTime = _data['creationTime']
        ? dayjs(_data['creationTime'].toString())
        : <any>undefined;
      this.isDefault = _data['isDefault'];
    }
  }

  static fromJS(data: any): PageLanguageOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PageLanguageOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['cultureName'] = this.cultureName;
    data['uiCultureName'] = this.uiCultureName;
    data['displayName'] = this.displayName;
    data['flagIcon'] = this.flagIcon;
    data['isEnabled'] = this.isEnabled;
    data['creationTime'] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
    data['isDefault'] = this.isDefault;
    return data;
  }
}

export interface IPageLanguageOutput {
  id: string;
  cultureName: string | undefined;
  uiCultureName: string | undefined;
  displayName: string | undefined;
  flagIcon: string | undefined;
  isEnabled: boolean;
  creationTime: dayjs.Dayjs;
  isDefault: boolean;
}

export class PageLanguageOutputPagedResultDto implements IPageLanguageOutputPagedResultDto {
  items!: PageLanguageOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IPageLanguageOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PageLanguageOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PageLanguageOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PageLanguageOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPageLanguageOutputPagedResultDto {
  items: PageLanguageOutput[] | undefined;
  totalCount: number;
}

export class PageLanguageTextInput implements IPageLanguageTextInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  cultureName!: string | undefined;
  resourceName!: string | undefined;
  filter!: string | undefined;

  constructor(data?: IPageLanguageTextInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.cultureName = _data['cultureName'];
      this.resourceName = _data['resourceName'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PageLanguageTextInput {
    data = typeof data === 'object' ? data : {};
    let result = new PageLanguageTextInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['cultureName'] = this.cultureName;
    data['resourceName'] = this.resourceName;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPageLanguageTextInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  cultureName: string | undefined;
  resourceName: string | undefined;
  filter: string | undefined;
}

export class PageLanguageTextOutput implements IPageLanguageTextOutput {
  resourceName!: string | undefined;
  name!: string | undefined;
  value!: string | undefined;

  constructor(data?: IPageLanguageTextOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.resourceName = _data['resourceName'];
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): PageLanguageTextOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PageLanguageTextOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['resourceName'] = this.resourceName;
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface IPageLanguageTextOutput {
  resourceName: string | undefined;
  name: string | undefined;
  value: string | undefined;
}

export class PageLanguageTextOutputPagedResultDto implements IPageLanguageTextOutputPagedResultDto {
  items!: PageLanguageTextOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IPageLanguageTextOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PageLanguageTextOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PageLanguageTextOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PageLanguageTextOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPageLanguageTextOutputPagedResultDto {
  items: PageLanguageTextOutput[] | undefined;
  totalCount: number;
}

export class PageProductInputDto implements IPageProductInputDto {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPageProductInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PageProductInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new PageProductInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPageProductInputDto {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PageRuleInputDto implements IPageRuleInputDto {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPageRuleInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PageRuleInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new PageRuleInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPageRuleInputDto {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PagingAuditLogActionOutput implements IPagingAuditLogActionOutput {
  id!: string;
  tenantId!: string | undefined;
  auditLogId!: string;
  serviceName!: string | undefined;
  methodName!: string | undefined;
  parameters!: string | undefined;
  executionTime!: string | undefined;
  executionDuration!: number;
  extraProperties!: { [key: string]: any } | undefined;

  constructor(data?: IPagingAuditLogActionOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tenantId = _data['tenantId'];
      this.auditLogId = _data['auditLogId'];
      this.serviceName = _data['serviceName'];
      this.methodName = _data['methodName'];
      this.parameters = _data['parameters'];
      this.executionTime = _data['executionTime'];
      this.executionDuration = _data['executionDuration'];
      if (_data['extraProperties']) {
        this.extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>this.extraProperties)![key] = _data['extraProperties'][key];
        }
      }
    }
  }

  static fromJS(data: any): PagingAuditLogActionOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingAuditLogActionOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tenantId'] = this.tenantId;
    data['auditLogId'] = this.auditLogId;
    data['serviceName'] = this.serviceName;
    data['methodName'] = this.methodName;
    data['parameters'] = this.parameters;
    data['executionTime'] = this.executionTime;
    data['executionDuration'] = this.executionDuration;
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    return data;
  }
}

export interface IPagingAuditLogActionOutput {
  id: string;
  tenantId: string | undefined;
  auditLogId: string;
  serviceName: string | undefined;
  methodName: string | undefined;
  parameters: string | undefined;
  executionTime: string | undefined;
  executionDuration: number;
  extraProperties: { [key: string]: any } | undefined;
}

export class PagingAuditLogInput implements IPagingAuditLogInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  sorting!: string | undefined;
  startTime!: dayjs.Dayjs | undefined;
  endTime!: dayjs.Dayjs | undefined;
  httpMethod!: string | undefined;
  url!: string | undefined;
  userId!: string | undefined;
  userName!: string | undefined;
  applicationName!: string | undefined;
  correlationId!: string | undefined;
  maxExecutionDuration!: number | undefined;
  minExecutionDuration!: number | undefined;
  hasException!: boolean | undefined;
  httpStatusCode!: HttpStatusCode;
  clientIpAddress!: string | undefined;

  constructor(data?: IPagingAuditLogInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.sorting = _data['sorting'];
      this.startTime = _data['startTime'] ? dayjs(_data['startTime'].toString()) : <any>undefined;
      this.endTime = _data['endTime'] ? dayjs(_data['endTime'].toString()) : <any>undefined;
      this.httpMethod = _data['httpMethod'];
      this.url = _data['url'];
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.applicationName = _data['applicationName'];
      this.correlationId = _data['correlationId'];
      this.maxExecutionDuration = _data['maxExecutionDuration'];
      this.minExecutionDuration = _data['minExecutionDuration'];
      this.hasException = _data['hasException'];
      this.httpStatusCode = _data['httpStatusCode'];
      this.clientIpAddress = _data['clientIpAddress'];
    }
  }

  static fromJS(data: any): PagingAuditLogInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingAuditLogInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['sorting'] = this.sorting;
    data['startTime'] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toLocaleString() : <any>undefined;
    data['httpMethod'] = this.httpMethod;
    data['url'] = this.url;
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['applicationName'] = this.applicationName;
    data['correlationId'] = this.correlationId;
    data['maxExecutionDuration'] = this.maxExecutionDuration;
    data['minExecutionDuration'] = this.minExecutionDuration;
    data['hasException'] = this.hasException;
    data['httpStatusCode'] = this.httpStatusCode;
    data['clientIpAddress'] = this.clientIpAddress;
    return data;
  }
}

export interface IPagingAuditLogInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  sorting: string | undefined;
  startTime: dayjs.Dayjs | undefined;
  endTime: dayjs.Dayjs | undefined;
  httpMethod: string | undefined;
  url: string | undefined;
  userId: string | undefined;
  userName: string | undefined;
  applicationName: string | undefined;
  correlationId: string | undefined;
  maxExecutionDuration: number | undefined;
  minExecutionDuration: number | undefined;
  hasException: boolean | undefined;
  httpStatusCode: HttpStatusCode;
  clientIpAddress: string | undefined;
}

export class PagingAuditLogOutput implements IPagingAuditLogOutput {
  applicationName!: string | undefined;
  userId!: string | undefined;
  userName!: string | undefined;
  tenantId!: string | undefined;
  tenantName!: string | undefined;
  impersonatorUserId!: string | undefined;
  impersonatorTenantId!: string | undefined;
  executionTime!: string | undefined;
  executionDuration!: number;
  clientIpAddress!: string | undefined;
  clientName!: string | undefined;
  clientId!: string | undefined;
  correlationId!: string | undefined;
  browserInfo!: string | undefined;
  httpMethod!: string | undefined;
  url!: string | undefined;
  exceptions!: string | undefined;
  comments!: string | undefined;
  httpStatusCode!: number | undefined;
  entityChanges!: PagingEntityChangeOutput[] | undefined;
  actions!: PagingAuditLogActionOutput[] | undefined;

  constructor(data?: IPagingAuditLogOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationName = _data['applicationName'];
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.tenantId = _data['tenantId'];
      this.tenantName = _data['tenantName'];
      this.impersonatorUserId = _data['impersonatorUserId'];
      this.impersonatorTenantId = _data['impersonatorTenantId'];
      this.executionTime = _data['executionTime'];
      this.executionDuration = _data['executionDuration'];
      this.clientIpAddress = _data['clientIpAddress'];
      this.clientName = _data['clientName'];
      this.clientId = _data['clientId'];
      this.correlationId = _data['correlationId'];
      this.browserInfo = _data['browserInfo'];
      this.httpMethod = _data['httpMethod'];
      this.url = _data['url'];
      this.exceptions = _data['exceptions'];
      this.comments = _data['comments'];
      this.httpStatusCode = _data['httpStatusCode'];
      if (Array.isArray(_data['entityChanges'])) {
        this.entityChanges = [] as any;
        for (let item of _data['entityChanges'])
          this.entityChanges!.push(PagingEntityChangeOutput.fromJS(item));
      }
      if (Array.isArray(_data['actions'])) {
        this.actions = [] as any;
        for (let item of _data['actions'])
          this.actions!.push(PagingAuditLogActionOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagingAuditLogOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingAuditLogOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['applicationName'] = this.applicationName;
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['tenantId'] = this.tenantId;
    data['tenantName'] = this.tenantName;
    data['impersonatorUserId'] = this.impersonatorUserId;
    data['impersonatorTenantId'] = this.impersonatorTenantId;
    data['executionTime'] = this.executionTime;
    data['executionDuration'] = this.executionDuration;
    data['clientIpAddress'] = this.clientIpAddress;
    data['clientName'] = this.clientName;
    data['clientId'] = this.clientId;
    data['correlationId'] = this.correlationId;
    data['browserInfo'] = this.browserInfo;
    data['httpMethod'] = this.httpMethod;
    data['url'] = this.url;
    data['exceptions'] = this.exceptions;
    data['comments'] = this.comments;
    data['httpStatusCode'] = this.httpStatusCode;
    if (Array.isArray(this.entityChanges)) {
      data['entityChanges'] = [];
      for (let item of this.entityChanges) data['entityChanges'].push(item.toJSON());
    }
    if (Array.isArray(this.actions)) {
      data['actions'] = [];
      for (let item of this.actions) data['actions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPagingAuditLogOutput {
  applicationName: string | undefined;
  userId: string | undefined;
  userName: string | undefined;
  tenantId: string | undefined;
  tenantName: string | undefined;
  impersonatorUserId: string | undefined;
  impersonatorTenantId: string | undefined;
  executionTime: string | undefined;
  executionDuration: number;
  clientIpAddress: string | undefined;
  clientName: string | undefined;
  clientId: string | undefined;
  correlationId: string | undefined;
  browserInfo: string | undefined;
  httpMethod: string | undefined;
  url: string | undefined;
  exceptions: string | undefined;
  comments: string | undefined;
  httpStatusCode: number | undefined;
  entityChanges: PagingEntityChangeOutput[] | undefined;
  actions: PagingAuditLogActionOutput[] | undefined;
}

export class PagingAuditLogOutputPagedResultDto implements IPagingAuditLogOutputPagedResultDto {
  items!: PagingAuditLogOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IPagingAuditLogOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PagingAuditLogOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PagingAuditLogOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagingAuditLogOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPagingAuditLogOutputPagedResultDto {
  items: PagingAuditLogOutput[] | undefined;
  totalCount: number;
}

export class PagingDataDictionaryDetailInput implements IPagingDataDictionaryDetailInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  dataDictionaryId!: string;
  filter!: string | undefined;

  constructor(data?: IPagingDataDictionaryDetailInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.dataDictionaryId = _data['dataDictionaryId'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PagingDataDictionaryDetailInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingDataDictionaryDetailInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['dataDictionaryId'] = this.dataDictionaryId;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPagingDataDictionaryDetailInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  dataDictionaryId: string;
  filter: string | undefined;
}

export class PagingDataDictionaryDetailOutput implements IPagingDataDictionaryDetailOutput {
  id!: string;
  dataDictionaryId!: string;
  code!: string | undefined;
  order!: number;
  displayText!: string | undefined;
  description!: string | undefined;
  isEnabled!: boolean;

  constructor(data?: IPagingDataDictionaryDetailOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.dataDictionaryId = _data['dataDictionaryId'];
      this.code = _data['code'];
      this.order = _data['order'];
      this.displayText = _data['displayText'];
      this.description = _data['description'];
      this.isEnabled = _data['isEnabled'];
    }
  }

  static fromJS(data: any): PagingDataDictionaryDetailOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingDataDictionaryDetailOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['dataDictionaryId'] = this.dataDictionaryId;
    data['code'] = this.code;
    data['order'] = this.order;
    data['displayText'] = this.displayText;
    data['description'] = this.description;
    data['isEnabled'] = this.isEnabled;
    return data;
  }
}

export interface IPagingDataDictionaryDetailOutput {
  id: string;
  dataDictionaryId: string;
  code: string | undefined;
  order: number;
  displayText: string | undefined;
  description: string | undefined;
  isEnabled: boolean;
}

export class PagingDataDictionaryDetailOutputPagedResultDto
  implements IPagingDataDictionaryDetailOutputPagedResultDto
{
  items!: PagingDataDictionaryDetailOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IPagingDataDictionaryDetailOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(PagingDataDictionaryDetailOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PagingDataDictionaryDetailOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagingDataDictionaryDetailOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPagingDataDictionaryDetailOutputPagedResultDto {
  items: PagingDataDictionaryDetailOutput[] | undefined;
  totalCount: number;
}

export class PagingDataDictionaryInput implements IPagingDataDictionaryInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPagingDataDictionaryInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PagingDataDictionaryInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingDataDictionaryInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPagingDataDictionaryInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PagingDataDictionaryOutput implements IPagingDataDictionaryOutput {
  id!: string;
  code!: string | undefined;
  displayText!: string | undefined;
  description!: string | undefined;

  constructor(data?: IPagingDataDictionaryOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.displayText = _data['displayText'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): PagingDataDictionaryOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingDataDictionaryOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['displayText'] = this.displayText;
    data['description'] = this.description;
    return data;
  }
}

export interface IPagingDataDictionaryOutput {
  id: string;
  code: string | undefined;
  displayText: string | undefined;
  description: string | undefined;
}

export class PagingDataDictionaryOutputPagedResultDto
  implements IPagingDataDictionaryOutputPagedResultDto
{
  items!: PagingDataDictionaryOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IPagingDataDictionaryOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PagingDataDictionaryOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PagingDataDictionaryOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagingDataDictionaryOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPagingDataDictionaryOutputPagedResultDto {
  items: PagingDataDictionaryOutput[] | undefined;
  totalCount: number;
}

export class PagingEntityChangeOutput implements IPagingEntityChangeOutput {
  id!: string;
  auditLogId!: string;
  tenantId!: string | undefined;
  changeTime!: string | undefined;
  changeType!: EntityChangeType;
  changeTypeDescription!: string | undefined;
  entityTenantId!: string | undefined;
  entityId!: string | undefined;
  entityTypeFullName!: string | undefined;
  propertyChanges!: PagingEntityPropertyChangeOutput[] | undefined;
  extraProperties!: { [key: string]: any } | undefined;

  constructor(data?: IPagingEntityChangeOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.auditLogId = _data['auditLogId'];
      this.tenantId = _data['tenantId'];
      this.changeTime = _data['changeTime'];
      this.changeType = _data['changeType'];
      this.changeTypeDescription = _data['changeTypeDescription'];
      this.entityTenantId = _data['entityTenantId'];
      this.entityId = _data['entityId'];
      this.entityTypeFullName = _data['entityTypeFullName'];
      if (Array.isArray(_data['propertyChanges'])) {
        this.propertyChanges = [] as any;
        for (let item of _data['propertyChanges'])
          this.propertyChanges!.push(PagingEntityPropertyChangeOutput.fromJS(item));
      }
      if (_data['extraProperties']) {
        this.extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>this.extraProperties)![key] = _data['extraProperties'][key];
        }
      }
    }
  }

  static fromJS(data: any): PagingEntityChangeOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingEntityChangeOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['auditLogId'] = this.auditLogId;
    data['tenantId'] = this.tenantId;
    data['changeTime'] = this.changeTime;
    data['changeType'] = this.changeType;
    data['changeTypeDescription'] = this.changeTypeDescription;
    data['entityTenantId'] = this.entityTenantId;
    data['entityId'] = this.entityId;
    data['entityTypeFullName'] = this.entityTypeFullName;
    if (Array.isArray(this.propertyChanges)) {
      data['propertyChanges'] = [];
      for (let item of this.propertyChanges) data['propertyChanges'].push(item.toJSON());
    }
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    return data;
  }
}

export interface IPagingEntityChangeOutput {
  id: string;
  auditLogId: string;
  tenantId: string | undefined;
  changeTime: string | undefined;
  changeType: EntityChangeType;
  changeTypeDescription: string | undefined;
  entityTenantId: string | undefined;
  entityId: string | undefined;
  entityTypeFullName: string | undefined;
  propertyChanges: PagingEntityPropertyChangeOutput[] | undefined;
  extraProperties: { [key: string]: any } | undefined;
}

export class PagingEntityPropertyChangeOutput implements IPagingEntityPropertyChangeOutput {
  id!: string;
  tenantId!: string | undefined;
  entityChangeId!: string;
  newValue!: string | undefined;
  originalValue!: string | undefined;
  propertyName!: string | undefined;
  propertyTypeFullName!: string | undefined;

  constructor(data?: IPagingEntityPropertyChangeOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tenantId = _data['tenantId'];
      this.entityChangeId = _data['entityChangeId'];
      this.newValue = _data['newValue'];
      this.originalValue = _data['originalValue'];
      this.propertyName = _data['propertyName'];
      this.propertyTypeFullName = _data['propertyTypeFullName'];
    }
  }

  static fromJS(data: any): PagingEntityPropertyChangeOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingEntityPropertyChangeOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tenantId'] = this.tenantId;
    data['entityChangeId'] = this.entityChangeId;
    data['newValue'] = this.newValue;
    data['originalValue'] = this.originalValue;
    data['propertyName'] = this.propertyName;
    data['propertyTypeFullName'] = this.propertyTypeFullName;
    return data;
  }
}

export interface IPagingEntityPropertyChangeOutput {
  id: string;
  tenantId: string | undefined;
  entityChangeId: string;
  newValue: string | undefined;
  originalValue: string | undefined;
  propertyName: string | undefined;
  propertyTypeFullName: string | undefined;
}

export class PagingIdentitySecurityLogInput implements IPagingIdentitySecurityLogInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  sorting!: string | undefined;
  startTime!: dayjs.Dayjs | undefined;
  endTime!: dayjs.Dayjs | undefined;
  identity!: string | undefined;
  action!: string | undefined;
  userId!: string | undefined;
  userName!: string | undefined;
  applicationName!: string | undefined;
  correlationId!: string | undefined;
  clientId!: string | undefined;

  constructor(data?: IPagingIdentitySecurityLogInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.sorting = _data['sorting'];
      this.startTime = _data['startTime'] ? dayjs(_data['startTime'].toString()) : <any>undefined;
      this.endTime = _data['endTime'] ? dayjs(_data['endTime'].toString()) : <any>undefined;
      this.identity = _data['identity'];
      this.action = _data['action'];
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.applicationName = _data['applicationName'];
      this.correlationId = _data['correlationId'];
      this.clientId = _data['clientId'];
    }
  }

  static fromJS(data: any): PagingIdentitySecurityLogInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingIdentitySecurityLogInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['sorting'] = this.sorting;
    data['startTime'] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
    data['endTime'] = this.endTime ? this.endTime.toLocaleString() : <any>undefined;
    data['identity'] = this.identity;
    data['action'] = this.action;
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['applicationName'] = this.applicationName;
    data['correlationId'] = this.correlationId;
    data['clientId'] = this.clientId;
    return data;
  }
}

export interface IPagingIdentitySecurityLogInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  sorting: string | undefined;
  startTime: dayjs.Dayjs | undefined;
  endTime: dayjs.Dayjs | undefined;
  identity: string | undefined;
  action: string | undefined;
  userId: string | undefined;
  userName: string | undefined;
  applicationName: string | undefined;
  correlationId: string | undefined;
  clientId: string | undefined;
}

export class PagingIdentitySecurityLogOutput implements IPagingIdentitySecurityLogOutput {
  id!: string;
  tenantId!: string | undefined;
  applicationName!: string | undefined;
  identity!: string | undefined;
  action!: string | undefined;
  userId!: string | undefined;
  userName!: string | undefined;
  tenantName!: string | undefined;
  clientId!: string | undefined;
  correlationId!: string | undefined;
  clientIpAddress!: string | undefined;
  browserInfo!: string | undefined;
  creationTime!: dayjs.Dayjs;

  constructor(data?: IPagingIdentitySecurityLogOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.tenantId = _data['tenantId'];
      this.applicationName = _data['applicationName'];
      this.identity = _data['identity'];
      this.action = _data['action'];
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.tenantName = _data['tenantName'];
      this.clientId = _data['clientId'];
      this.correlationId = _data['correlationId'];
      this.clientIpAddress = _data['clientIpAddress'];
      this.browserInfo = _data['browserInfo'];
      this.creationTime = _data['creationTime']
        ? dayjs(_data['creationTime'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagingIdentitySecurityLogOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingIdentitySecurityLogOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['tenantId'] = this.tenantId;
    data['applicationName'] = this.applicationName;
    data['identity'] = this.identity;
    data['action'] = this.action;
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['tenantName'] = this.tenantName;
    data['clientId'] = this.clientId;
    data['correlationId'] = this.correlationId;
    data['clientIpAddress'] = this.clientIpAddress;
    data['browserInfo'] = this.browserInfo;
    data['creationTime'] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
    return data;
  }
}

export interface IPagingIdentitySecurityLogOutput {
  id: string;
  tenantId: string | undefined;
  applicationName: string | undefined;
  identity: string | undefined;
  action: string | undefined;
  userId: string | undefined;
  userName: string | undefined;
  tenantName: string | undefined;
  clientId: string | undefined;
  correlationId: string | undefined;
  clientIpAddress: string | undefined;
  browserInfo: string | undefined;
  creationTime: dayjs.Dayjs;
}

export class PagingIdentitySecurityLogOutputPagedResultDto
  implements IPagingIdentitySecurityLogOutputPagedResultDto
{
  items!: PagingIdentitySecurityLogOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IPagingIdentitySecurityLogOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(PagingIdentitySecurityLogOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PagingIdentitySecurityLogOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagingIdentitySecurityLogOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPagingIdentitySecurityLogOutputPagedResultDto {
  items: PagingIdentitySecurityLogOutput[] | undefined;
  totalCount: number;
}

export class PagingNotificationListInput implements IPagingNotificationListInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;

  constructor(data?: IPagingNotificationListInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
    }
  }

  static fromJS(data: any): PagingNotificationListInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingNotificationListInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    return data;
  }
}

export interface IPagingNotificationListInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
}

export class PagingNotificationListOutput implements IPagingNotificationListOutput {
  id!: string;
  title!: string | undefined;
  content!: string | undefined;
  messageType!: MessageType;
  readonly messageTypeDescription!: string | undefined;
  messageLevel!: MessageLevel;
  readonly messageLevelDescription!: string | undefined;
  senderId!: string;
  creationTime!: dayjs.Dayjs;
  read!: boolean;

  constructor(data?: IPagingNotificationListOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.messageType = _data['messageType'];
      (<any>this).messageTypeDescription = _data['messageTypeDescription'];
      this.messageLevel = _data['messageLevel'];
      (<any>this).messageLevelDescription = _data['messageLevelDescription'];
      this.senderId = _data['senderId'];
      this.creationTime = _data['creationTime']
        ? dayjs(_data['creationTime'].toString())
        : <any>undefined;
      this.read = _data['read'];
    }
  }

  static fromJS(data: any): PagingNotificationListOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingNotificationListOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['content'] = this.content;
    data['messageType'] = this.messageType;
    data['messageTypeDescription'] = this.messageTypeDescription;
    data['messageLevel'] = this.messageLevel;
    data['messageLevelDescription'] = this.messageLevelDescription;
    data['senderId'] = this.senderId;
    data['creationTime'] = this.creationTime ? this.creationTime.toLocaleString() : <any>undefined;
    data['read'] = this.read;
    return data;
  }
}

export interface IPagingNotificationListOutput {
  id: string;
  title: string | undefined;
  content: string | undefined;
  messageType: MessageType;
  messageTypeDescription: string | undefined;
  messageLevel: MessageLevel;
  messageLevelDescription: string | undefined;
  senderId: string;
  creationTime: dayjs.Dayjs;
  read: boolean;
}

export class PagingNotificationListOutputPagedResultDto
  implements IPagingNotificationListOutputPagedResultDto
{
  items!: PagingNotificationListOutput[] | undefined;
  totalCount!: number;

  constructor(data?: IPagingNotificationListOutputPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(PagingNotificationListOutput.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PagingNotificationListOutputPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagingNotificationListOutputPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPagingNotificationListOutputPagedResultDto {
  items: PagingNotificationListOutput[] | undefined;
  totalCount: number;
}

export class PagingRoleListInput implements IPagingRoleListInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPagingRoleListInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PagingRoleListInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingRoleListInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPagingRoleListInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PagingTenantInput implements IPagingTenantInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPagingTenantInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PagingTenantInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingTenantInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPagingTenantInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class PagingUserListInput implements IPagingUserListInput {
  pageIndex!: number;
  pageSize!: number;
  readonly skipCount!: number;
  filter!: string | undefined;

  constructor(data?: IPagingUserListInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageIndex = _data['pageIndex'];
      this.pageSize = _data['pageSize'];
      (<any>this).skipCount = _data['skipCount'];
      this.filter = _data['filter'];
    }
  }

  static fromJS(data: any): PagingUserListInput {
    data = typeof data === 'object' ? data : {};
    let result = new PagingUserListInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageIndex'] = this.pageIndex;
    data['pageSize'] = this.pageSize;
    data['skipCount'] = this.skipCount;
    data['filter'] = this.filter;
    return data;
  }
}

export interface IPagingUserListInput {
  pageIndex: number;
  pageSize: number;
  skipCount: number;
  filter: string | undefined;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
  nameOnMethod!: string | undefined;
  name!: string | undefined;
  jsonName!: string | undefined;
  type!: string | undefined;
  typeSimple!: string | undefined;
  isOptional!: boolean;
  defaultValue!: any | undefined;
  constraintTypes!: string[] | undefined;
  bindingSourceId!: string | undefined;
  descriptorName!: string | undefined;

  constructor(data?: IParameterApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nameOnMethod = _data['nameOnMethod'];
      this.name = _data['name'];
      this.jsonName = _data['jsonName'];
      this.type = _data['type'];
      this.typeSimple = _data['typeSimple'];
      this.isOptional = _data['isOptional'];
      this.defaultValue = _data['defaultValue'];
      if (Array.isArray(_data['constraintTypes'])) {
        this.constraintTypes = [] as any;
        for (let item of _data['constraintTypes']) this.constraintTypes!.push(item);
      }
      this.bindingSourceId = _data['bindingSourceId'];
      this.descriptorName = _data['descriptorName'];
    }
  }

  static fromJS(data: any): ParameterApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new ParameterApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nameOnMethod'] = this.nameOnMethod;
    data['name'] = this.name;
    data['jsonName'] = this.jsonName;
    data['type'] = this.type;
    data['typeSimple'] = this.typeSimple;
    data['isOptional'] = this.isOptional;
    data['defaultValue'] = this.defaultValue;
    if (Array.isArray(this.constraintTypes)) {
      data['constraintTypes'] = [];
      for (let item of this.constraintTypes) data['constraintTypes'].push(item);
    }
    data['bindingSourceId'] = this.bindingSourceId;
    data['descriptorName'] = this.descriptorName;
    return data;
  }
}

export interface IParameterApiDescriptionModel {
  nameOnMethod: string | undefined;
  name: string | undefined;
  jsonName: string | undefined;
  type: string | undefined;
  typeSimple: string | undefined;
  isOptional: boolean;
  defaultValue: any | undefined;
  constraintTypes: string[] | undefined;
  bindingSourceId: string | undefined;
  descriptorName: string | undefined;
}

export class PermissionOutput implements IPermissionOutput {
  grants!: string[] | undefined;
  allGrants!: string[] | undefined;
  permissions!: PermissionTreeDto[] | undefined;

  constructor(data?: IPermissionOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['grants'])) {
        this.grants = [] as any;
        for (let item of _data['grants']) this.grants!.push(item);
      }
      if (Array.isArray(_data['allGrants'])) {
        this.allGrants = [] as any;
        for (let item of _data['allGrants']) this.allGrants!.push(item);
      }
      if (Array.isArray(_data['permissions'])) {
        this.permissions = [] as any;
        for (let item of _data['permissions'])
          this.permissions!.push(PermissionTreeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionOutput {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.grants)) {
      data['grants'] = [];
      for (let item of this.grants) data['grants'].push(item);
    }
    if (Array.isArray(this.allGrants)) {
      data['allGrants'] = [];
      for (let item of this.allGrants) data['allGrants'].push(item);
    }
    if (Array.isArray(this.permissions)) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPermissionOutput {
  grants: string[] | undefined;
  allGrants: string[] | undefined;
  permissions: PermissionTreeDto[] | undefined;
}

export class PermissionTreeDto implements IPermissionTreeDto {
  title!: string | undefined;
  key!: string | undefined;
  children!: PermissionTreeDto[] | undefined;

  constructor(data?: IPermissionTreeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.key = _data['key'];
      if (Array.isArray(_data['children'])) {
        this.children = [] as any;
        for (let item of _data['children']) this.children!.push(PermissionTreeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionTreeDto {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionTreeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['key'] = this.key;
    if (Array.isArray(this.children)) {
      data['children'] = [];
      for (let item of this.children) data['children'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPermissionTreeDto {
  title: string | undefined;
  key: string | undefined;
  children: PermissionTreeDto[] | undefined;
}

export class ProductInputDto implements IProductInputDto {
  id!: string;
  name!: string | undefined;
  deviceType!: DeviceType;
  identityType!: IdentityType;
  timeout!: number;

  constructor(data?: IProductInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.deviceType = _data['deviceType'];
      this.identityType = _data['identityType'];
      this.timeout = _data['timeout'];
    }
  }

  static fromJS(data: any): ProductInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['deviceType'] = this.deviceType;
    data['identityType'] = this.identityType;
    data['timeout'] = this.timeout;
    return data;
  }
}

export interface IProductInputDto {
  id: string;
  name: string | undefined;
  deviceType: DeviceType;
  identityType: IdentityType;
  timeout: number;
}

export class ProductOutputDto implements IProductOutputDto {
  id!: string;
  name!: string | undefined;
  deviceType!: DeviceType;
  identityType!: IdentityType;
  timeout!: number;
  devices!: DeviceOutputDto[] | undefined;
  readonly avatorUrl!: string | undefined;

  constructor(data?: IProductOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.deviceType = _data['deviceType'];
      this.identityType = _data['identityType'];
      this.timeout = _data['timeout'];
      if (Array.isArray(_data['devices'])) {
        this.devices = [] as any;
        for (let item of _data['devices']) this.devices!.push(DeviceOutputDto.fromJS(item));
      }
      (<any>this).avatorUrl = _data['avatorUrl'];
    }
  }

  static fromJS(data: any): ProductOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['deviceType'] = this.deviceType;
    data['identityType'] = this.identityType;
    data['timeout'] = this.timeout;
    if (Array.isArray(this.devices)) {
      data['devices'] = [];
      for (let item of this.devices) data['devices'].push(item.toJSON());
    }
    data['avatorUrl'] = this.avatorUrl;
    return data;
  }
}

export interface IProductOutputDto {
  id: string;
  name: string | undefined;
  deviceType: DeviceType;
  identityType: IdentityType;
  timeout: number;
  devices: DeviceOutputDto[] | undefined;
  avatorUrl: string | undefined;
}

export class ProductOutputDtoPagedResultDto implements IProductOutputDtoPagedResultDto {
  items!: ProductOutputDto[] | undefined;
  totalCount!: number;

  constructor(data?: IProductOutputDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProductOutputDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): ProductOutputDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductOutputDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IProductOutputDtoPagedResultDto {
  items: ProductOutputDto[] | undefined;
  totalCount: number;
}

export class PropertyApiDescriptionModel implements IPropertyApiDescriptionModel {
  name!: string | undefined;
  jsonName!: string | undefined;
  type!: string | undefined;
  typeSimple!: string | undefined;
  isRequired!: boolean;
  minLength!: number | undefined;
  maxLength!: number | undefined;
  minimum!: string | undefined;
  maximum!: string | undefined;
  regex!: string | undefined;

  constructor(data?: IPropertyApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.jsonName = _data['jsonName'];
      this.type = _data['type'];
      this.typeSimple = _data['typeSimple'];
      this.isRequired = _data['isRequired'];
      this.minLength = _data['minLength'];
      this.maxLength = _data['maxLength'];
      this.minimum = _data['minimum'];
      this.maximum = _data['maximum'];
      this.regex = _data['regex'];
    }
  }

  static fromJS(data: any): PropertyApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new PropertyApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['jsonName'] = this.jsonName;
    data['type'] = this.type;
    data['typeSimple'] = this.typeSimple;
    data['isRequired'] = this.isRequired;
    data['minLength'] = this.minLength;
    data['maxLength'] = this.maxLength;
    data['minimum'] = this.minimum;
    data['maximum'] = this.maximum;
    data['regex'] = this.regex;
    return data;
  }
}

export interface IPropertyApiDescriptionModel {
  name: string | undefined;
  jsonName: string | undefined;
  type: string | undefined;
  typeSimple: string | undefined;
  isRequired: boolean;
  minLength: number | undefined;
  maxLength: number | undefined;
  minimum: string | undefined;
  maximum: string | undefined;
  regex: string | undefined;
}

export class PropertyOutputDto implements IPropertyOutputDto {
  id!: string;
  keyName!: string | undefined;
  description!: string | undefined;
  value!: string | undefined;
  dataSide!: DataSide;
  dataType!: DataType;
  propertyType!: PropertyType;
  isShow!: boolean;

  constructor(data?: IPropertyOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.keyName = _data['keyName'];
      this.description = _data['description'];
      this.value = _data['value'];
      this.dataSide = _data['dataSide'];
      this.dataType = _data['dataType'];
      this.propertyType = _data['propertyType'];
      this.isShow = _data['isShow'];
    }
  }

  static fromJS(data: any): PropertyOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new PropertyOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['keyName'] = this.keyName;
    data['description'] = this.description;
    data['value'] = this.value;
    data['dataSide'] = this.dataSide;
    data['dataType'] = this.dataType;
    data['propertyType'] = this.propertyType;
    data['isShow'] = this.isShow;
    return data;
  }
}

export interface IPropertyOutputDto {
  id: string;
  keyName: string | undefined;
  description: string | undefined;
  value: string | undefined;
  dataSide: DataSide;
  dataType: DataType;
  propertyType: PropertyType;
  isShow: boolean;
}

export class PropertyOutputDtoPagedResultDto implements IPropertyOutputDtoPagedResultDto {
  items!: PropertyOutputDto[] | undefined;
  totalCount!: number;

  constructor(data?: IPropertyOutputDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(PropertyOutputDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PropertyOutputDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new PropertyOutputDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPropertyOutputDtoPagedResultDto {
  items: PropertyOutputDto[] | undefined;
  totalCount: number;
}

export enum PropertyType {
  Attribute = 0,
  Telemetry = 1,
}

export class RealTimeAlarmDto implements IRealTimeAlarmDto {
  alarmId!: string;
  title!: string | undefined;
  content!: string | undefined;
  creationTime!: number;
  serverity!: ServerityLevel;
  startTime!: dayjs.Dayjs;
  readonly startTimeStr!: string | undefined;
  duration!: number;
  readonly durationMinute!: number;

  constructor(data?: IRealTimeAlarmDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.alarmId = _data['alarmId'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.creationTime = _data['creationTime'];
      this.serverity = _data['serverity'];
      this.startTime = _data['startTime'] ? dayjs(_data['startTime'].toString()) : <any>undefined;
      (<any>this).startTimeStr = _data['startTimeStr'];
      this.duration = _data['duration'];
      (<any>this).durationMinute = _data['durationMinute'];
    }
  }

  static fromJS(data: any): RealTimeAlarmDto {
    data = typeof data === 'object' ? data : {};
    let result = new RealTimeAlarmDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['alarmId'] = this.alarmId;
    data['title'] = this.title;
    data['content'] = this.content;
    data['creationTime'] = this.creationTime;
    data['serverity'] = this.serverity;
    data['startTime'] = this.startTime ? this.startTime.toLocaleString() : <any>undefined;
    data['startTimeStr'] = this.startTimeStr;
    data['duration'] = this.duration;
    data['durationMinute'] = this.durationMinute;
    return data;
  }
}

export interface IRealTimeAlarmDto {
  alarmId: string;
  title: string | undefined;
  content: string | undefined;
  creationTime: number;
  serverity: ServerityLevel;
  startTime: dayjs.Dayjs;
  startTimeStr: string | undefined;
  duration: number;
  durationMinute: number;
}

export class RelateDeviceRuleInputDto implements IRelateDeviceRuleInputDto {
  deviceId!: string;
  ruleIdList!: string[] | undefined;

  constructor(data?: IRelateDeviceRuleInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deviceId = _data['deviceId'];
      if (Array.isArray(_data['ruleIdList'])) {
        this.ruleIdList = [] as any;
        for (let item of _data['ruleIdList']) this.ruleIdList!.push(item);
      }
    }
  }

  static fromJS(data: any): RelateDeviceRuleInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new RelateDeviceRuleInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['deviceId'] = this.deviceId;
    if (Array.isArray(this.ruleIdList)) {
      data['ruleIdList'] = [];
      for (let item of this.ruleIdList) data['ruleIdList'].push(item);
    }
    return data;
  }
}

export interface IRelateDeviceRuleInputDto {
  deviceId: string;
  ruleIdList: string[] | undefined;
}

export class RemoteServiceErrorInfo implements IRemoteServiceErrorInfo {
  code!: string | undefined;
  message!: string | undefined;
  details!: string | undefined;
  data!: { [key: string]: any } | undefined;
  validationErrors!: RemoteServiceValidationErrorInfo[] | undefined;

  constructor(data?: IRemoteServiceErrorInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data['code'];
      this.message = _data['message'];
      this.details = _data['details'];
      if (_data['data']) {
        this.data = {} as any;
        for (let key in _data['data']) {
          if (_data['data'].hasOwnProperty(key)) (<any>this.data)![key] = _data['data'][key];
        }
      }
      if (Array.isArray(_data['validationErrors'])) {
        this.validationErrors = [] as any;
        for (let item of _data['validationErrors'])
          this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RemoteServiceErrorInfo {
    data = typeof data === 'object' ? data : {};
    let result = new RemoteServiceErrorInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['code'] = this.code;
    data['message'] = this.message;
    data['details'] = this.details;
    if (this.data) {
      data['data'] = {};
      for (let key in this.data) {
        if (this.data.hasOwnProperty(key)) (<any>data['data'])[key] = (<any>this.data)[key];
      }
    }
    if (Array.isArray(this.validationErrors)) {
      data['validationErrors'] = [];
      for (let item of this.validationErrors) data['validationErrors'].push(item.toJSON());
    }
    return data;
  }
}

export interface IRemoteServiceErrorInfo {
  code: string | undefined;
  message: string | undefined;
  details: string | undefined;
  data: { [key: string]: any } | undefined;
  validationErrors: RemoteServiceValidationErrorInfo[] | undefined;
}

export class RemoteServiceErrorResponse implements IRemoteServiceErrorResponse {
  error!: RemoteServiceErrorInfo;

  constructor(data?: IRemoteServiceErrorResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.error = _data['error'] ? RemoteServiceErrorInfo.fromJS(_data['error']) : <any>undefined;
    }
  }

  static fromJS(data: any): RemoteServiceErrorResponse {
    data = typeof data === 'object' ? data : {};
    let result = new RemoteServiceErrorResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['error'] = this.error ? this.error.toJSON() : <any>undefined;
    return data;
  }
}

export interface IRemoteServiceErrorResponse {
  error: RemoteServiceErrorInfo;
}

export class RemoteServiceValidationErrorInfo implements IRemoteServiceValidationErrorInfo {
  message!: string | undefined;
  members!: string[] | undefined;

  constructor(data?: IRemoteServiceValidationErrorInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.message = _data['message'];
      if (Array.isArray(_data['members'])) {
        this.members = [] as any;
        for (let item of _data['members']) this.members!.push(item);
      }
    }
  }

  static fromJS(data: any): RemoteServiceValidationErrorInfo {
    data = typeof data === 'object' ? data : {};
    let result = new RemoteServiceValidationErrorInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['message'] = this.message;
    if (Array.isArray(this.members)) {
      data['members'] = [];
      for (let item of this.members) data['members'].push(item);
    }
    return data;
  }
}

export interface IRemoteServiceValidationErrorInfo {
  message: string | undefined;
  members: string[] | undefined;
}

export class RemoveRoleToOrganizationUnitInput implements IRemoveRoleToOrganizationUnitInput {
  roleId!: string;
  organizationUnitId!: string;

  constructor(data?: IRemoveRoleToOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data['roleId'];
      this.organizationUnitId = _data['organizationUnitId'];
    }
  }

  static fromJS(data: any): RemoveRoleToOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new RemoveRoleToOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleId'] = this.roleId;
    data['organizationUnitId'] = this.organizationUnitId;
    return data;
  }
}

export interface IRemoveRoleToOrganizationUnitInput {
  roleId: string;
  organizationUnitId: string;
}

export class RemoveUserToOrganizationUnitInput implements IRemoveUserToOrganizationUnitInput {
  userId!: string;
  organizationUnitId!: string;

  constructor(data?: IRemoveUserToOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.organizationUnitId = _data['organizationUnitId'];
    }
  }

  static fromJS(data: any): RemoveUserToOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new RemoveUserToOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['organizationUnitId'] = this.organizationUnitId;
    return data;
  }
}

export interface IRemoveUserToOrganizationUnitInput {
  userId: string;
  organizationUnitId: string;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
  type!: string | undefined;
  typeSimple!: string | undefined;

  constructor(data?: IReturnValueApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.typeSimple = _data['typeSimple'];
    }
  }

  static fromJS(data: any): ReturnValueApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new ReturnValueApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['typeSimple'] = this.typeSimple;
    return data;
  }
}

export interface IReturnValueApiDescriptionModel {
  type: string | undefined;
  typeSimple: string | undefined;
}

export class RuleInputDto implements IRuleInputDto {
  id!: string;
  ruleName!: string | undefined;
  ruleType!: RuleType;
  scriptContent!: string | undefined;
  jsonContent!: string | undefined;

  constructor(data?: IRuleInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.ruleName = _data['ruleName'];
      this.ruleType = _data['ruleType'];
      this.scriptContent = _data['scriptContent'];
      this.jsonContent = _data['jsonContent'];
    }
  }

  static fromJS(data: any): RuleInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new RuleInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['ruleName'] = this.ruleName;
    data['ruleType'] = this.ruleType;
    data['scriptContent'] = this.scriptContent;
    data['jsonContent'] = this.jsonContent;
    return data;
  }
}

export interface IRuleInputDto {
  id: string;
  ruleName: string | undefined;
  ruleType: RuleType;
  scriptContent: string | undefined;
  jsonContent: string | undefined;
}

export class RuleOutputDto implements IRuleOutputDto {
  id!: string;
  ruleName!: string | undefined;
  ruleType!: RuleType;
  scriptContent!: string | undefined;
  jsonContent!: string | undefined;

  constructor(data?: IRuleOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.ruleName = _data['ruleName'];
      this.ruleType = _data['ruleType'];
      this.scriptContent = _data['scriptContent'];
      this.jsonContent = _data['jsonContent'];
    }
  }

  static fromJS(data: any): RuleOutputDto {
    data = typeof data === 'object' ? data : {};
    let result = new RuleOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['ruleName'] = this.ruleName;
    data['ruleType'] = this.ruleType;
    data['scriptContent'] = this.scriptContent;
    data['jsonContent'] = this.jsonContent;
    return data;
  }
}

export interface IRuleOutputDto {
  id: string;
  ruleName: string | undefined;
  ruleType: RuleType;
  scriptContent: string | undefined;
  jsonContent: string | undefined;
}

export class RuleOutputDtoPagedResultDto implements IRuleOutputDtoPagedResultDto {
  items!: RuleOutputDto[] | undefined;
  totalCount!: number;

  constructor(data?: IRuleOutputDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(RuleOutputDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): RuleOutputDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new RuleOutputDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IRuleOutputDtoPagedResultDto {
  items: RuleOutputDto[] | undefined;
  totalCount: number;
}

export enum RuleType {
  DataClean = 'DataClean',
  AlarmPublish = 'AlarmPublish',
}

export class SendBroadCastMessageInput implements ISendBroadCastMessageInput {
  title!: string | undefined;
  content!: string | undefined;

  constructor(data?: ISendBroadCastMessageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.content = _data['content'];
    }
  }

  static fromJS(data: any): SendBroadCastMessageInput {
    data = typeof data === 'object' ? data : {};
    let result = new SendBroadCastMessageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['content'] = this.content;
    return data;
  }
}

export interface ISendBroadCastMessageInput {
  title: string | undefined;
  content: string | undefined;
}

export class SendCommonMessageInput implements ISendCommonMessageInput {
  title!: string | undefined;
  content!: string | undefined;
  receiveIds!: string[] | undefined;

  constructor(data?: ISendCommonMessageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.content = _data['content'];
      if (Array.isArray(_data['receiveIds'])) {
        this.receiveIds = [] as any;
        for (let item of _data['receiveIds']) this.receiveIds!.push(item);
      }
    }
  }

  static fromJS(data: any): SendCommonMessageInput {
    data = typeof data === 'object' ? data : {};
    let result = new SendCommonMessageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['content'] = this.content;
    if (Array.isArray(this.receiveIds)) {
      data['receiveIds'] = [];
      for (let item of this.receiveIds) data['receiveIds'].push(item);
    }
    return data;
  }
}

export interface ISendCommonMessageInput {
  title: string | undefined;
  content: string | undefined;
  receiveIds: string[] | undefined;
}

export enum ServerityLevel {
  Indeterminate = 'Indeterminate',
  Warning = 'Warning',
  Minor = 'Minor',
  Major = 'Major',
  Serious = 'Serious',
}

export class SetDataDictinaryDetailInput implements ISetDataDictinaryDetailInput {
  dataDictionaryId!: string;
  dataDictionayDetailId!: string;
  isEnabled!: boolean;

  constructor(data?: ISetDataDictinaryDetailInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dataDictionaryId = _data['dataDictionaryId'];
      this.dataDictionayDetailId = _data['dataDictionayDetailId'];
      this.isEnabled = _data['isEnabled'];
    }
  }

  static fromJS(data: any): SetDataDictinaryDetailInput {
    data = typeof data === 'object' ? data : {};
    let result = new SetDataDictinaryDetailInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dataDictionaryId'] = this.dataDictionaryId;
    data['dataDictionayDetailId'] = this.dataDictionayDetailId;
    data['isEnabled'] = this.isEnabled;
    return data;
  }
}

export interface ISetDataDictinaryDetailInput {
  dataDictionaryId: string;
  dataDictionayDetailId: string;
  isEnabled: boolean;
}

export class SetReadInput implements ISetReadInput {
  id!: string;

  constructor(data?: ISetReadInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): SetReadInput {
    data = typeof data === 'object' ? data : {};
    let result = new SetReadInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface ISetReadInput {
  id: string;
}

export class SettingItemOutput implements ISettingItemOutput {
  name!: string | undefined;
  displayName!: string | undefined;
  description!: string | undefined;
  value!: string | undefined;
  type!: string | undefined;

  constructor(data?: ISettingItemOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.description = _data['description'];
      this.value = _data['value'];
      this.type = _data['type'];
    }
  }

  static fromJS(data: any): SettingItemOutput {
    data = typeof data === 'object' ? data : {};
    let result = new SettingItemOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['value'] = this.value;
    data['type'] = this.type;
    return data;
  }
}

export interface ISettingItemOutput {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
  value: string | undefined;
  type: string | undefined;
}

export class SettingOutput implements ISettingOutput {
  group!: string | undefined;
  groupDisplayName!: string | undefined;
  settingItemOutput!: SettingItemOutput[] | undefined;

  constructor(data?: ISettingOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.group = _data['group'];
      this.groupDisplayName = _data['groupDisplayName'];
      if (Array.isArray(_data['settingItemOutput'])) {
        this.settingItemOutput = [] as any;
        for (let item of _data['settingItemOutput'])
          this.settingItemOutput!.push(SettingItemOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SettingOutput {
    data = typeof data === 'object' ? data : {};
    let result = new SettingOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['group'] = this.group;
    data['groupDisplayName'] = this.groupDisplayName;
    if (Array.isArray(this.settingItemOutput)) {
      data['settingItemOutput'] = [];
      for (let item of this.settingItemOutput) data['settingItemOutput'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISettingOutput {
  group: string | undefined;
  groupDisplayName: string | undefined;
  settingItemOutput: SettingItemOutput[] | undefined;
}

export class SpecialDataDto implements ISpecialDataDto {
  x!: number;
  y!: number;
  active!: boolean;
  details!: NameValue[] | undefined;

  constructor(data?: ISpecialDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.x = _data['x'];
      this.y = _data['y'];
      this.active = _data['active'];
      if (Array.isArray(_data['details'])) {
        this.details = [] as any;
        for (let item of _data['details']) this.details!.push(NameValue.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SpecialDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new SpecialDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['x'] = this.x;
    data['y'] = this.y;
    data['active'] = this.active;
    if (Array.isArray(this.details)) {
      data['details'] = [];
      for (let item of this.details) data['details'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISpecialDataDto {
  x: number;
  y: number;
  active: boolean;
  details: NameValue[] | undefined;
}

export class StateDto implements IStateDto {
  id!: number;
  name!: string | undefined;
  value!: number;

  constructor(data?: IStateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): StateDto {
    data = typeof data === 'object' ? data : {};
    let result = new StateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface IStateDto {
  id: number;
  name: string | undefined;
  value: number;
}

export class StringNameValue implements IStringNameValue {
  name!: string | undefined;
  value!: string | undefined;

  constructor(data?: IStringNameValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): StringNameValue {
    data = typeof data === 'object' ? data : {};
    let result = new StringNameValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface IStringNameValue {
  name: string | undefined;
  value: string | undefined;
}

export class StringStringFromSelector implements IStringStringFromSelector {
  readonly value!: string | undefined;
  readonly label!: string | undefined;

  constructor(data?: IStringStringFromSelector) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).value = _data['value'];
      (<any>this).label = _data['label'];
    }
  }

  static fromJS(data: any): StringStringFromSelector {
    data = typeof data === 'object' ? data : {};
    let result = new StringStringFromSelector();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['label'] = this.label;
    return data;
  }
}

export interface IStringStringFromSelector {
  value: string | undefined;
  label: string | undefined;
}

export class TelemetryChartDataDto implements ITelemetryChartDataDto {
  legend!: string[] | undefined;
  series!: string[] | undefined;
  xDataList!: string[] | undefined;
  yDataList!: number[][] | undefined;

  constructor(data?: ITelemetryChartDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['legend'])) {
        this.legend = [] as any;
        for (let item of _data['legend']) this.legend!.push(item);
      }
      if (Array.isArray(_data['series'])) {
        this.series = [] as any;
        for (let item of _data['series']) this.series!.push(item);
      }
      if (Array.isArray(_data['xDataList'])) {
        this.xDataList = [] as any;
        for (let item of _data['xDataList']) this.xDataList!.push(item);
      }
      if (Array.isArray(_data['yDataList'])) {
        this.yDataList = [] as any;
        for (let item of _data['yDataList']) this.yDataList!.push(item);
      }
    }
  }

  static fromJS(data: any): TelemetryChartDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new TelemetryChartDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.legend)) {
      data['legend'] = [];
      for (let item of this.legend) data['legend'].push(item);
    }
    if (Array.isArray(this.series)) {
      data['series'] = [];
      for (let item of this.series) data['series'].push(item);
    }
    if (Array.isArray(this.xDataList)) {
      data['xDataList'] = [];
      for (let item of this.xDataList) data['xDataList'].push(item);
    }
    if (Array.isArray(this.yDataList)) {
      data['yDataList'] = [];
      for (let item of this.yDataList) data['yDataList'].push(item);
    }
    return data;
  }
}

export interface ITelemetryChartDataDto {
  legend: string[] | undefined;
  series: string[] | undefined;
  xDataList: string[] | undefined;
  yDataList: number[][] | undefined;
}

export class TenantCreateDto implements ITenantCreateDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  name!: string;
  adminEmailAddress!: string;
  adminPassword!: string;

  constructor(data?: ITenantCreateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.name = _data['name'];
      this.adminEmailAddress = _data['adminEmailAddress'];
      this.adminPassword = _data['adminPassword'];
    }
  }

  static fromJS(data: any): TenantCreateDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantCreateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['name'] = this.name;
    data['adminEmailAddress'] = this.adminEmailAddress;
    data['adminPassword'] = this.adminPassword;
    return data;
  }
}

export interface ITenantCreateDto {
  extraProperties: { [key: string]: any } | undefined;
  name: string;
  adminEmailAddress: string;
  adminPassword: string;
}

export class TenantDto implements ITenantDto {
  readonly extraProperties!: { [key: string]: any } | undefined;
  id!: string;
  name!: string | undefined;
  concurrencyStamp!: string | undefined;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['extraProperties']) {
        (<any>this).extraProperties = {} as any;
        for (let key in _data['extraProperties']) {
          if (_data['extraProperties'].hasOwnProperty(key))
            (<any>(<any>this).extraProperties)![key] = _data['extraProperties'][key];
        }
      }
      this.id = _data['id'];
      this.name = _data['name'];
      this.concurrencyStamp = _data['concurrencyStamp'];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.extraProperties) {
      data['extraProperties'] = {};
      for (let key in this.extraProperties) {
        if (this.extraProperties.hasOwnProperty(key))
          (<any>data['extraProperties'])[key] = (<any>this.extraProperties)[key];
      }
    }
    data['id'] = this.id;
    data['name'] = this.name;
    data['concurrencyStamp'] = this.concurrencyStamp;
    return data;
  }
}

export interface ITenantDto {
  extraProperties: { [key: string]: any } | undefined;
  id: string;
  name: string | undefined;
  concurrencyStamp: string | undefined;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
  items!: TenantDto[] | undefined;
  totalCount!: number;

  constructor(data?: ITenantDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TenantDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): TenantDtoPagedResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;
}

export class TimeZone implements ITimeZone {
  iana!: IanaTimeZone;
  windows!: WindowsTimeZone;

  constructor(data?: ITimeZone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.iana = _data['iana'] ? IanaTimeZone.fromJS(_data['iana']) : <any>undefined;
      this.windows = _data['windows'] ? WindowsTimeZone.fromJS(_data['windows']) : <any>undefined;
    }
  }

  static fromJS(data: any): TimeZone {
    data = typeof data === 'object' ? data : {};
    let result = new TimeZone();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['iana'] = this.iana ? this.iana.toJSON() : <any>undefined;
    data['windows'] = this.windows ? this.windows.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITimeZone {
  iana: IanaTimeZone;
  windows: WindowsTimeZone;
}

export class TimingDto implements ITimingDto {
  timeZone!: TimeZone;

  constructor(data?: ITimingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.timeZone = _data['timeZone'] ? TimeZone.fromJS(_data['timeZone']) : <any>undefined;
    }
  }

  static fromJS(data: any): TimingDto {
    data = typeof data === 'object' ? data : {};
    let result = new TimingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['timeZone'] = this.timeZone ? this.timeZone.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITimingDto {
  timeZone: TimeZone;
}

export class TotalAlarmDto implements ITotalAlarmDto {
  alarms!: AlarmDto[] | undefined;

  constructor(data?: ITotalAlarmDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['alarms'])) {
        this.alarms = [] as any;
        for (let item of _data['alarms']) this.alarms!.push(AlarmDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TotalAlarmDto {
    data = typeof data === 'object' ? data : {};
    let result = new TotalAlarmDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.alarms)) {
      data['alarms'] = [];
      for (let item of this.alarms) data['alarms'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITotalAlarmDto {
  alarms: AlarmDto[] | undefined;
}

export class TotalBatteryInfoDto implements ITotalBatteryInfoDto {
  batteryInfos!: BatteryInfoDto[] | undefined;

  constructor(data?: ITotalBatteryInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['batteryInfos'])) {
        this.batteryInfos = [] as any;
        for (let item of _data['batteryInfos'])
          this.batteryInfos!.push(BatteryInfoDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TotalBatteryInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new TotalBatteryInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.batteryInfos)) {
      data['batteryInfos'] = [];
      for (let item of this.batteryInfos) data['batteryInfos'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITotalBatteryInfoDto {
  batteryInfos: BatteryInfoDto[] | undefined;
}

export class TotalStateDto implements ITotalStateDto {
  machineStates!: StateDto[] | undefined;

  constructor(data?: ITotalStateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['machineStates'])) {
        this.machineStates = [] as any;
        for (let item of _data['machineStates']) this.machineStates!.push(StateDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TotalStateDto {
    data = typeof data === 'object' ? data : {};
    let result = new TotalStateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.machineStates)) {
      data['machineStates'] = [];
      for (let item of this.machineStates) data['machineStates'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITotalStateDto {
  machineStates: StateDto[] | undefined;
}

export class TotalVoltageDto implements ITotalVoltageDto {
  name!: string | undefined;
  /** 总电压 */
  totalVoltage!: number;
  /** 总电流 */
  totalAmmeter!: number;
  voltageList!: VoltageDto[] | undefined;
  max!: VoltageDto;
  min!: VoltageDto;

  constructor(data?: ITotalVoltageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.totalVoltage = _data['totalVoltage'];
      this.totalAmmeter = _data['totalAmmeter'];
      if (Array.isArray(_data['voltageList'])) {
        this.voltageList = [] as any;
        for (let item of _data['voltageList']) this.voltageList!.push(VoltageDto.fromJS(item));
      }
      this.max = _data['max'] ? VoltageDto.fromJS(_data['max']) : <any>undefined;
      this.min = _data['min'] ? VoltageDto.fromJS(_data['min']) : <any>undefined;
    }
  }

  static fromJS(data: any): TotalVoltageDto {
    data = typeof data === 'object' ? data : {};
    let result = new TotalVoltageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['totalVoltage'] = this.totalVoltage;
    data['totalAmmeter'] = this.totalAmmeter;
    if (Array.isArray(this.voltageList)) {
      data['voltageList'] = [];
      for (let item of this.voltageList) data['voltageList'].push(item.toJSON());
    }
    data['max'] = this.max ? this.max.toJSON() : <any>undefined;
    data['min'] = this.min ? this.min.toJSON() : <any>undefined;
    return data;
  }
}

export interface ITotalVoltageDto {
  name: string | undefined;
  /** 总电压 */
  totalVoltage: number;
  /** 总电流 */
  totalAmmeter: number;
  voltageList: VoltageDto[] | undefined;
  max: VoltageDto;
  min: VoltageDto;
}

export class TreeDataDto implements ITreeDataDto {
  title!: string | undefined;
  key!: string | undefined;
  icon!: string | undefined;
  disabled!: boolean;
  isActive!: boolean;
  isAlarm!: boolean;
  children!: TreeDataDto[] | undefined;

  constructor(data?: ITreeDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.key = _data['key'];
      this.icon = _data['icon'];
      this.disabled = _data['disabled'];
      this.isActive = _data['isActive'];
      this.isAlarm = _data['isAlarm'];
      if (Array.isArray(_data['children'])) {
        this.children = [] as any;
        for (let item of _data['children']) this.children!.push(TreeDataDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TreeDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new TreeDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['key'] = this.key;
    data['icon'] = this.icon;
    data['disabled'] = this.disabled;
    data['isActive'] = this.isActive;
    data['isAlarm'] = this.isAlarm;
    if (Array.isArray(this.children)) {
      data['children'] = [];
      for (let item of this.children) data['children'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITreeDataDto {
  title: string | undefined;
  key: string | undefined;
  icon: string | undefined;
  disabled: boolean;
  isActive: boolean;
  isAlarm: boolean;
  children: TreeDataDto[] | undefined;
}

export class TreeOutput implements ITreeOutput {
  title!: string | undefined;
  key!: string;
  children!: TreeOutput[] | undefined;

  constructor(data?: ITreeOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.key = _data['key'];
      if (Array.isArray(_data['children'])) {
        this.children = [] as any;
        for (let item of _data['children']) this.children!.push(TreeOutput.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TreeOutput {
    data = typeof data === 'object' ? data : {};
    let result = new TreeOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['key'] = this.key;
    if (Array.isArray(this.children)) {
      data['children'] = [];
      for (let item of this.children) data['children'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITreeOutput {
  title: string | undefined;
  key: string;
  children: TreeOutput[] | undefined;
}

export class TypeApiDescriptionModel implements ITypeApiDescriptionModel {
  baseType!: string | undefined;
  isEnum!: boolean;
  enumNames!: string[] | undefined;
  enumValues!: any[] | undefined;
  genericArguments!: string[] | undefined;
  properties!: PropertyApiDescriptionModel[] | undefined;

  constructor(data?: ITypeApiDescriptionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.baseType = _data['baseType'];
      this.isEnum = _data['isEnum'];
      if (Array.isArray(_data['enumNames'])) {
        this.enumNames = [] as any;
        for (let item of _data['enumNames']) this.enumNames!.push(item);
      }
      if (Array.isArray(_data['enumValues'])) {
        this.enumValues = [] as any;
        for (let item of _data['enumValues']) this.enumValues!.push(item);
      }
      if (Array.isArray(_data['genericArguments'])) {
        this.genericArguments = [] as any;
        for (let item of _data['genericArguments']) this.genericArguments!.push(item);
      }
      if (Array.isArray(_data['properties'])) {
        this.properties = [] as any;
        for (let item of _data['properties'])
          this.properties!.push(PropertyApiDescriptionModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TypeApiDescriptionModel {
    data = typeof data === 'object' ? data : {};
    let result = new TypeApiDescriptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['baseType'] = this.baseType;
    data['isEnum'] = this.isEnum;
    if (Array.isArray(this.enumNames)) {
      data['enumNames'] = [];
      for (let item of this.enumNames) data['enumNames'].push(item);
    }
    if (Array.isArray(this.enumValues)) {
      data['enumValues'] = [];
      for (let item of this.enumValues) data['enumValues'].push(item);
    }
    if (Array.isArray(this.genericArguments)) {
      data['genericArguments'] = [];
      for (let item of this.genericArguments) data['genericArguments'].push(item);
    }
    if (Array.isArray(this.properties)) {
      data['properties'] = [];
      for (let item of this.properties) data['properties'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITypeApiDescriptionModel {
  baseType: string | undefined;
  isEnum: boolean;
  enumNames: string[] | undefined;
  enumValues: any[] | undefined;
  genericArguments: string[] | undefined;
  properties: PropertyApiDescriptionModel[] | undefined;
}

export class UpdateConnectionStringInput implements IUpdateConnectionStringInput {
  id!: string;
  connectionString!: string | undefined;

  constructor(data?: IUpdateConnectionStringInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.connectionString = _data['connectionString'];
    }
  }

  static fromJS(data: any): UpdateConnectionStringInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateConnectionStringInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['connectionString'] = this.connectionString;
    return data;
  }
}

export interface IUpdateConnectionStringInput {
  id: string;
  connectionString: string | undefined;
}

export class UpdateContentInputDto implements IUpdateContentInputDto {
  id!: string;
  scriptContent!: string | undefined;
  jsonContent!: string | undefined;

  constructor(data?: IUpdateContentInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.scriptContent = _data['scriptContent'];
      this.jsonContent = _data['jsonContent'];
    }
  }

  static fromJS(data: any): UpdateContentInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateContentInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['scriptContent'] = this.scriptContent;
    data['jsonContent'] = this.jsonContent;
    return data;
  }
}

export interface IUpdateContentInputDto {
  id: string;
  scriptContent: string | undefined;
  jsonContent: string | undefined;
}

export class UpdateDataDictinaryInput implements IUpdateDataDictinaryInput {
  id!: string;
  code!: string | undefined;
  displayText!: string | undefined;
  description!: string | undefined;

  constructor(data?: IUpdateDataDictinaryInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.displayText = _data['displayText'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): UpdateDataDictinaryInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateDataDictinaryInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['displayText'] = this.displayText;
    data['description'] = this.description;
    return data;
  }
}

export interface IUpdateDataDictinaryInput {
  id: string;
  code: string | undefined;
  displayText: string | undefined;
  description: string | undefined;
}

export class UpdateDetailInput implements IUpdateDetailInput {
  dataDictionaryId!: string;
  id!: string;
  displayText!: string | undefined;
  description!: string | undefined;
  order!: number;

  constructor(data?: IUpdateDetailInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dataDictionaryId = _data['dataDictionaryId'];
      this.id = _data['id'];
      this.displayText = _data['displayText'];
      this.description = _data['description'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): UpdateDetailInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateDetailInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dataDictionaryId'] = this.dataDictionaryId;
    data['id'] = this.id;
    data['displayText'] = this.displayText;
    data['description'] = this.description;
    data['order'] = this.order;
    return data;
  }
}

export interface IUpdateDetailInput {
  dataDictionaryId: string;
  id: string;
  displayText: string | undefined;
  description: string | undefined;
  order: number;
}

export class UpdateLanguageInput implements IUpdateLanguageInput {
  id!: string;
  cultureName!: string | undefined;
  uiCultureName!: string | undefined;
  displayName!: string | undefined;
  flagIcon!: string | undefined;
  isEnabled!: boolean;

  constructor(data?: IUpdateLanguageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.cultureName = _data['cultureName'];
      this.uiCultureName = _data['uiCultureName'];
      this.displayName = _data['displayName'];
      this.flagIcon = _data['flagIcon'];
      this.isEnabled = _data['isEnabled'];
    }
  }

  static fromJS(data: any): UpdateLanguageInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateLanguageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['cultureName'] = this.cultureName;
    data['uiCultureName'] = this.uiCultureName;
    data['displayName'] = this.displayName;
    data['flagIcon'] = this.flagIcon;
    data['isEnabled'] = this.isEnabled;
    return data;
  }
}

export interface IUpdateLanguageInput {
  id: string;
  cultureName: string | undefined;
  uiCultureName: string | undefined;
  displayName: string | undefined;
  flagIcon: string | undefined;
  isEnabled: boolean;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
  resourceName!: string;
  cultureName!: string;
  name!: string;
  value!: string;

  constructor(data?: IUpdateLanguageTextInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.resourceName = _data['resourceName'];
      this.cultureName = _data['cultureName'];
      this.name = _data['name'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): UpdateLanguageTextInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateLanguageTextInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['resourceName'] = this.resourceName;
    data['cultureName'] = this.cultureName;
    data['name'] = this.name;
    data['value'] = this.value;
    return data;
  }
}

export interface IUpdateLanguageTextInput {
  resourceName: string;
  cultureName: string;
  name: string;
  value: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
  displayName!: string | undefined;
  id!: string;

  constructor(data?: IUpdateOrganizationUnitInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      this.id = _data['id'];
    }
  }

  static fromJS(data: any): UpdateOrganizationUnitInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOrganizationUnitInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['id'] = this.id;
    return data;
  }
}

export interface IUpdateOrganizationUnitInput {
  displayName: string | undefined;
  id: string;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
  name!: string | undefined;
  isGranted!: boolean;

  constructor(data?: IUpdatePermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.isGranted = _data['isGranted'];
    }
  }

  static fromJS(data: any): UpdatePermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['isGranted'] = this.isGranted;
    return data;
  }
}

export interface IUpdatePermissionDto {
  name: string | undefined;
  isGranted: boolean;
}

export class UpdatePermissionsDto implements IUpdatePermissionsDto {
  permissions!: UpdatePermissionDto[] | undefined;

  constructor(data?: IUpdatePermissionsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['permissions'])) {
        this.permissions = [] as any;
        for (let item of _data['permissions'])
          this.permissions!.push(UpdatePermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UpdatePermissionsDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePermissionsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.permissions)) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUpdatePermissionsDto {
  permissions: UpdatePermissionDto[] | undefined;
}

export class UpdatePropertyDesInputDto implements IUpdatePropertyDesInputDto {
  id!: string;
  description!: string | undefined;

  constructor(data?: IUpdatePropertyDesInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): UpdatePropertyDesInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdatePropertyDesInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['description'] = this.description;
    return data;
  }
}

export interface IUpdatePropertyDesInputDto {
  id: string;
  description: string | undefined;
}

export class UpdateRoleInput implements IUpdateRoleInput {
  roleId!: string;
  roleInfo!: IdentityRoleUpdateDto;

  constructor(data?: IUpdateRoleInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data['roleId'];
      this.roleInfo = _data['roleInfo']
        ? IdentityRoleUpdateDto.fromJS(_data['roleInfo'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateRoleInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateRoleInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleId'] = this.roleId;
    data['roleInfo'] = this.roleInfo ? this.roleInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateRoleInput {
  roleId: string;
  roleInfo: IdentityRoleUpdateDto;
}

export class UpdateRolePermissionsInput implements IUpdateRolePermissionsInput {
  providerName!: string | undefined;
  providerKey!: string | undefined;
  updatePermissionsDto!: UpdatePermissionsDto;

  constructor(data?: IUpdateRolePermissionsInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.providerName = _data['providerName'];
      this.providerKey = _data['providerKey'];
      this.updatePermissionsDto = _data['updatePermissionsDto']
        ? UpdatePermissionsDto.fromJS(_data['updatePermissionsDto'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateRolePermissionsInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateRolePermissionsInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['providerName'] = this.providerName;
    data['providerKey'] = this.providerKey;
    data['updatePermissionsDto'] = this.updatePermissionsDto
      ? this.updatePermissionsDto.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IUpdateRolePermissionsInput {
  providerName: string | undefined;
  providerKey: string | undefined;
  updatePermissionsDto: UpdatePermissionsDto;
}

export class UpdateSettingInput implements IUpdateSettingInput {
  values!: { [key: string]: string } | undefined;

  constructor(data?: IUpdateSettingInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['values']) {
        this.values = {} as any;
        for (let key in _data['values']) {
          if (_data['values'].hasOwnProperty(key)) (<any>this.values)![key] = _data['values'][key];
        }
      }
    }
  }

  static fromJS(data: any): UpdateSettingInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateSettingInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.values) {
      data['values'] = {};
      for (let key in this.values) {
        if (this.values.hasOwnProperty(key)) (<any>data['values'])[key] = (<any>this.values)[key];
      }
    }
    return data;
  }
}

export interface IUpdateSettingInput {
  values: { [key: string]: string } | undefined;
}

export class UpdateTenantInput implements IUpdateTenantInput {
  id!: string;
  name!: string | undefined;

  constructor(data?: IUpdateTenantInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): UpdateTenantInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateTenantInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IUpdateTenantInput {
  id: string;
  name: string | undefined;
}

export class UpdateUserInput implements IUpdateUserInput {
  userId!: string;
  userInfo!: IdentityUserUpdateDto;

  constructor(data?: IUpdateUserInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.userInfo = _data['userInfo']
        ? IdentityUserUpdateDto.fromJS(_data['userInfo'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateUserInput {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['userInfo'] = this.userInfo ? this.userInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUpdateUserInput {
  userId: string;
  userInfo: IdentityUserUpdateDto;
}

export class UserInfo implements IUserInfo {
  /** 主键Id */
  id!: string | undefined;
  /** 登录账号 */
  userName!: string | undefined;
  /** 登录密码 */
  password!: string | undefined;
  /** 用户昵称 */
  nickName!: string | undefined;
  /** 用户头像 */
  headPortrait!: string | undefined;
  /** 用户邮箱 */
  email!: string | undefined;
  /** 用户状态（0冻结，1正常，2注销） */
  status!: number;
  specialData!: SpecialDataDto;

  constructor(data?: IUserInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userName = _data['userName'];
      this.password = _data['password'];
      this.nickName = _data['nickName'];
      this.headPortrait = _data['headPortrait'];
      this.email = _data['email'];
      this.status = _data['status'];
      this.specialData = _data['specialData']
        ? SpecialDataDto.fromJS(_data['specialData'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UserInfo {
    data = typeof data === 'object' ? data : {};
    let result = new UserInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userName'] = this.userName;
    data['password'] = this.password;
    data['nickName'] = this.nickName;
    data['headPortrait'] = this.headPortrait;
    data['email'] = this.email;
    data['status'] = this.status;
    data['specialData'] = this.specialData ? this.specialData.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserInfo {
  /** 主键Id */
  id: string | undefined;
  /** 登录账号 */
  userName: string | undefined;
  /** 登录密码 */
  password: string | undefined;
  /** 用户昵称 */
  nickName: string | undefined;
  /** 用户头像 */
  headPortrait: string | undefined;
  /** 用户邮箱 */
  email: string | undefined;
  /** 用户状态（0冻结，1正常，2注销） */
  status: number;
  specialData: SpecialDataDto;
}

export class UserInfoReq implements IUserInfoReq {
  /** 登录账号 */
  userName!: string | undefined;
  /** 登录密码 */
  password!: string | undefined;
  /** 用户昵称 */
  nickName!: string | undefined;
  /** 用户头像 */
  headPortrait!: string | undefined;
  /** 用户邮箱 */
  email!: string | undefined;
  /** 用户状态（0冻结，1正常，2注销） */
  status!: number;
  specialData!: SpecialDataDto;

  constructor(data?: IUserInfoReq) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data['userName'];
      this.password = _data['password'];
      this.nickName = _data['nickName'];
      this.headPortrait = _data['headPortrait'];
      this.email = _data['email'];
      this.status = _data['status'];
      this.specialData = _data['specialData']
        ? SpecialDataDto.fromJS(_data['specialData'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UserInfoReq {
    data = typeof data === 'object' ? data : {};
    let result = new UserInfoReq();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userName'] = this.userName;
    data['password'] = this.password;
    data['nickName'] = this.nickName;
    data['headPortrait'] = this.headPortrait;
    data['email'] = this.email;
    data['status'] = this.status;
    data['specialData'] = this.specialData ? this.specialData.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserInfoReq {
  /** 登录账号 */
  userName: string | undefined;
  /** 登录密码 */
  password: string | undefined;
  /** 用户昵称 */
  nickName: string | undefined;
  /** 用户头像 */
  headPortrait: string | undefined;
  /** 用户邮箱 */
  email: string | undefined;
  /** 用户状态（0冻结，1正常，2注销） */
  status: number;
  specialData: SpecialDataDto;
}

export class UserLoginInfo implements IUserLoginInfo {
  userNameOrEmailAddress!: string;
  password!: string;
  rememberMe!: boolean;

  constructor(data?: IUserLoginInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userNameOrEmailAddress = _data['userNameOrEmailAddress'];
      this.password = _data['password'];
      this.rememberMe = _data['rememberMe'];
    }
  }

  static fromJS(data: any): UserLoginInfo {
    data = typeof data === 'object' ? data : {};
    let result = new UserLoginInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userNameOrEmailAddress'] = this.userNameOrEmailAddress;
    data['password'] = this.password;
    data['rememberMe'] = this.rememberMe;
    return data;
  }
}

export interface IUserLoginInfo {
  userNameOrEmailAddress: string;
  password: string;
  rememberMe: boolean;
}

export class VoltageDto implements IVoltageDto {
  location!: string | undefined;
  voltage!: number;

  constructor(data?: IVoltageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.location = _data['location'];
      this.voltage = _data['voltage'];
    }
  }

  static fromJS(data: any): VoltageDto {
    data = typeof data === 'object' ? data : {};
    let result = new VoltageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['location'] = this.location;
    data['voltage'] = this.voltage;
    return data;
  }
}

export interface IVoltageDto {
  location: string | undefined;
  voltage: number;
}

export class WindowsTimeZone implements IWindowsTimeZone {
  timeZoneId!: string | undefined;

  constructor(data?: IWindowsTimeZone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.timeZoneId = _data['timeZoneId'];
    }
  }

  static fromJS(data: any): WindowsTimeZone {
    data = typeof data === 'object' ? data : {};
    let result = new WindowsTimeZone();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['timeZoneId'] = this.timeZoneId;
    return data;
  }
}

export interface IWindowsTimeZone {
  timeZoneId: string | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
